
/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


!(function (t, e) {
  'object' === typeof exports && 'undefined' !== typeof module ? e(exports) : 'function' === typeof define && define.amd ? define(['exports'], e) : e(t.echarts = {});
}(this, (t) => {
  'use strict';let e = 2311; const n = function () {
    return e++;
  }; const v = 'object' === typeof wx && 'function' === typeof wx.getSystemInfoSync ? { browser: {}, os: {}, node: !1, wxa: !0, canvasSupported: !0, svgSupported: !1, touchEventsSupported: !0, domSupported: !1 } : 'undefined' === typeof document && 'undefined' !== typeof self ? { browser: {}, os: {}, node: !1, worker: !0, canvasSupported: !0, domSupported: !1 } : 'undefined' === typeof navigator ? { browser: {}, os: {}, node: !0, worker: !1, canvasSupported: !0, svgSupported: !0, domSupported: !1 } : (function (t) {
    const e = {}; const i = t.match(/Firefox\/([\d.]+)/); const n = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/); const o = t.match(/Edge\/([\d.]+)/); const a = /micromessenger/i.test(t);i && (e.firefox = !0, e.version = i[1]);n && (e.ie = !0, e.version = n[1]);o && (e.edge = !0, e.version = o[1]);a && (e.weChat = !0);return { browser: e, os: {}, node: !1, canvasSupported: !!document.createElement('canvas').getContext, svgSupported: 'undefined' !== typeof SVGRect, touchEventsSupported: 'ontouchstart' in window && !e.ie && !e.edge, pointerEventsSupported: 'onpointerdown' in window && (e.edge || e.ie && 11 <= e.version), domSupported: 'undefined' !== typeof document };
  }(navigator.userAgent));const s = { '[object Function]': 1, '[object RegExp]': 1, '[object Date]': 1, '[object Error]': 1, '[object CanvasGradient]': 1, '[object CanvasPattern]': 1, '[object Image]': 1, '[object Canvas]': 1 }; const l = { '[object Int8Array]': 1, '[object Uint8Array]': 1, '[object Uint8ClampedArray]': 1, '[object Int16Array]': 1, '[object Uint16Array]': 1, '[object Int32Array]': 1, '[object Uint32Array]': 1, '[object Float32Array]': 1, '[object Float64Array]': 1 }; const u = Object.prototype.toString; const i = Array.prototype; const r = i.forEach; const h = i.filter; const o = i.slice; const c = i.map; const d = i.reduce; const a = {};function f(t, e) {
    'createCanvas' === t && (g = null), a[t] = e;
  } function k(t) {
    if (null == t || 'object' !== typeof t) return t;let e = t; const i = u.call(t);if ('[object Array]' === i) {
      if (!$(t)) {
        e = [];for (var n = 0, o = t.length;n < o;n++)e[n] = k(t[n]);
      }
    } else if (l[i]) {
      if (!$(t)) {
        const a = t.constructor;if (t.constructor.from)e = a.from(t);else {
          e = new a(t.length);for (n = 0, o = t.length;n < o;n++)e[n] = k(t[n]);
        }
      }
    } else if (!s[i] && !$(t) && !G(t)) for (const r in e = {}, t)t.hasOwnProperty(r) && (e[r] = k(t[r]));return e;
  } function m(t, e, i) {
    if (!z(e) || !z(t)) return i ? k(e) : t;for (const n in e) if (e.hasOwnProperty(n)) {
      const o = t[n]; const a = e[n];!z(a) || !z(o) || L(a) || L(o) || G(a) || G(o) || B(a) || B(o) || $(a) || $(o) ? !i && n in t || (t[n] = k(e[n])) : m(o, a, i);
    } return t;
  } function p(t, e) {
    for (var i = t[0], n = 1, o = t.length;n < o;n++)i = m(i, t[n], e);return i;
  } function P(t, e) {
    for (const i in e)e.hasOwnProperty(i) && (t[i] = e[i]);return t;
  } function D(t, e, i) {
    for (const n in e)e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);return t;
  } function y() {
    return a.createCanvas();
  } let g;function x() {
    return g = g || y().getContext('2d');
  } function _(t, e) {
    if (t) {
      if (t.indexOf) return t.indexOf(e);for (let i = 0, n = t.length;i < n;i++) if (t[i] === e) return i;
    } return -1;
  } function w(t, e) {
    const i = t.prototype;function n() {} for (const o in n.prototype = e.prototype, t.prototype = new n, i)i.hasOwnProperty(o) && (t.prototype[o] = i[o]);(t.prototype.constructor = t).superClass = e;
  } function b(t, e, i) {
    D(t = 'prototype' in t ? t.prototype : t, e = 'prototype' in e ? e.prototype : e, i);
  } function N(t) {
    if (t) return 'string' !== typeof t && 'number' === typeof t.length;
  } function R(t, e, i) {
    if (t && e) if (t.forEach && t.forEach === r)t.forEach(e, i);else if (t.length === +t.length) for (let n = 0, o = t.length;n < o;n++)e.call(i, t[n], n, t);else for (const a in t)t.hasOwnProperty(a) && e.call(i, t[a], a, t);
  } function O(t, e, i) {
    if (t && e) {
      if (t.map && t.map === c) return t.map(e, i);for (var n = [], o = 0, a = t.length;o < a;o++)n.push(e.call(i, t[o], o, t));return n;
    }
  } function S(t, e, i, n) {
    if (t && e) {
      if (t.reduce && t.reduce === d) return t.reduce(e, i, n);for (let o = 0, a = t.length;o < a;o++)i = e.call(n, i, t[o], o, t);return i;
    }
  } function M(t, e, i) {
    if (t && e) {
      if (t.filter && t.filter === h) return t.filter(e, i);for (var n = [], o = 0, a = t.length;o < a;o++)e.call(i, t[o], o, t) && n.push(t[o]);return n;
    }
  } function I(t, e, i) {
    if (t && e) for (let n = 0, o = t.length;n < o;n++) if (e.call(i, t[n], n, t)) return t[n];
  } function A(t, e) {
    const i = o.call(arguments, 2);return function () {
      return t.apply(e, i.concat(o.call(arguments)));
    };
  } function T(t) {
    const e = o.call(arguments, 1);return function () {
      return t.apply(this, e.concat(o.call(arguments)));
    };
  } function L(t) {
    return '[object Array]' === u.call(t);
  } function C(t) {
    return 'function' === typeof t;
  } function E(t) {
    return '[object String]' === u.call(t);
  } function z(t) {
    const e = typeof t;return 'function' == e || !!t && 'object' == e;
  } function B(t) {
    return !!s[u.call(t)];
  } function V(t) {
    return !!l[u.call(t)];
  } function G(t) {
    return 'object' === typeof t && 'number' === typeof t.nodeType && 'object' === typeof t.ownerDocument;
  } function F(t) {
    return t != t;
  } function W(t) {
    for (let e = 0, i = arguments.length;e < i;e++) if (null != arguments[e]) return arguments[e];
  } function H(t, e) {
    return null != t ? t : e;
  } function Z(t, e, i) {
    return null != t ? t : null != e ? e : i;
  } function U() {
    return Function.call.apply(o, arguments);
  } function X(t) {
    if ('number' === typeof t) return [t, t, t, t];const e = t.length;return 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t;
  } function Y(t, e) {
    if (!t) throw new Error(e);
  } function j(t) {
    return null == t ? null : 'function' === typeof t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
  }a.createCanvas = function () {
    return document.createElement('canvas');
  };const q = '__ec_primitive__';function K(t) {
    t[q] = !0;
  } function $(t) {
    return t[q];
  } function J(t) {
    const i = L(t);this.data = {};const n = this;function e(t, e) {
      i ? n.set(t, e) : n.set(e, t);
    }t instanceof J ? t.each(e) : t && R(t, e);
  } function Q(t) {
    return new J(t);
  } function tt(t, e) {
    for (var i = new t.constructor(t.length + e.length), n = 0;n < t.length;n++)i[n] = t[n];const o = t.length;for (n = 0;n < e.length;n++)i[n + o] = e[n];return i;
  } function et() {}J.prototype = { constructor: J, get(t) {
    return this.data.hasOwnProperty(t) ? this.data[t] : null;
  }, set(t, e) {
    return this.data[t] = e;
  }, each(t, e) {
    for (const i in void 0 !== e && (t = A(t, e)), this.data) this.data.hasOwnProperty(i) && t(this.data[i], i);
  }, removeKey(t) {
    delete this.data[t];
  } };const it = (Object.freeze || Object)({ $override: f, clone: k, merge: m, mergeAll: p, extend: P, defaults: D, createCanvas: y, getContext: x, indexOf: _, inherits: w, mixin: b, isArrayLike: N, each: R, map: O, reduce: S, filter: M, find: I, bind: A, curry: T, isArray: L, isFunction: C, isString: E, isObject: z, isBuiltInObject: B, isTypedArray: V, isDom: G, eqNaN: F, retrieve: W, retrieve2: H, retrieve3: Z, slice: U, normalizeCssArray: X, assert: Y, trim: j, setAsPrimitive: K, isPrimitive: $, createHashMap: Q, concatArray: tt, noop: et }); const nt = 'undefined' === typeof Float32Array ? Array : Float32Array;function ot(t, e) {
    const i = new nt(2);return null == t && (t = 0), null == e && (e = 0), i[0] = t, i[1] = e, i;
  } function at(t, e) {
    return t[0] = e[0], t[1] = e[1], t;
  } function rt(t) {
    const e = new nt(2);return e[0] = t[0], e[1] = t[1], e;
  } function st(t, e, i) {
    return t[0] = e, t[1] = i, t;
  } function lt(t, e, i) {
    return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t;
  } function ut(t, e, i, n) {
    return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t;
  } function ht(t, e, i) {
    return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t;
  } function ct(t) {
    return Math.sqrt(ft(t));
  } const dt = ct;function ft(t) {
    return t[0] * t[0] + t[1] * t[1];
  } const pt = ft;function gt(t, e, i) {
    return t[0] = e[0] * i, t[1] = e[1] * i, t;
  } function mt(t, e) {
    const i = ct(e);return 0 === i ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / i, t[1] = e[1] / i), t;
  } function vt(t, e) {
    return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]));
  } const yt = vt;function xt(t, e) {
    return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]);
  } const _t = xt;function wt(t, e, i, n) {
    return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t;
  } function bt(t, e, i) {
    const n = e[0]; const o = e[1];return t[0] = i[0] * n + i[2] * o + i[4], t[1] = i[1] * n + i[3] * o + i[5], t;
  } function St(t, e, i) {
    return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t;
  } function Mt(t, e, i) {
    return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t;
  } const It = (Object.freeze || Object)({ create: ot, copy: at, clone: rt, set: st, add: lt, scaleAndAdd: ut, sub: ht, len: ct, length: dt, lenSquare: ft, lengthSquare: pt, mul(t, e, i) {
    return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t;
  }, div(t, e, i) {
    return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t;
  }, dot(t, e) {
    return t[0] * e[0] + t[1] * e[1];
  }, scale: gt, normalize: mt, distance: vt, dist: yt, distanceSquare: xt, distSquare: _t, negate(t, e) {
    return t[0] = -e[0], t[1] = -e[1], t;
  }, lerp: wt, applyTransform: bt, min: St, max: Mt });function Tt() {
    this.on('mousedown', this._dragStart, this), this.on('mousemove', this._drag, this), this.on('mouseup', this._dragEnd, this);
  } function At(t, e) {
    return { target: t, topTarget: e && e.topTarget };
  }Tt.prototype = { constructor: Tt, _dragStart(t) {
    for (var e = t.target;e && !e.draggable;)e = e.parent;e && ((this._draggingTarget = e).dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.dispatchToElement(At(e, t), 'dragstart', t.event));
  }, _drag(t) {
    const e = this._draggingTarget;if (e) {
      const i = t.offsetX; const n = t.offsetY; const o = i - this._x; const a = n - this._y;this._x = i, this._y = n, e.drift(o, a, t), this.dispatchToElement(At(e, t), 'drag', t.event);const r = this.findHover(i, n, e).target; const s = this._dropTarget;e !== (this._dropTarget = r) && (s && r !== s && this.dispatchToElement(At(s, t), 'dragleave', t.event), r && r !== s && this.dispatchToElement(At(r, t), 'dragenter', t.event));
    }
  }, _dragEnd(t) {
    const e = this._draggingTarget;e && (e.dragging = !1), this.dispatchToElement(At(e, t), 'dragend', t.event), this._dropTarget && this.dispatchToElement(At(this._dropTarget, t), 'drop', t.event), this._draggingTarget = null, this._dropTarget = null;
  } };const Dt = Array.prototype.slice; const Ct = function (t) {
    this._$handlers = {}, this._$eventProcessor = t;
  };function Lt(t, e, i, n, o, a) {
    const r = t._$handlers;if ('function' === typeof i && (o = n, n = i, i = null), !n || !e) return t;i = (function (t, e) {
      const i = t._$eventProcessor;return null != e && i && i.normalizeQuery && (e = i.normalizeQuery(e)), e;
    }(t, i)), r[e] || (r[e] = []);for (let s = 0;s < r[e].length;s++) if (r[e][s].h === n) return t;const l = { h: n, one: a, query: i, ctx: o || t, callAtLast: n.zrEventfulCallAtLast }; const u = r[e].length - 1; const h = r[e][u];return h && h.callAtLast ? r[e].splice(u, 0, l) : r[e].push(l), t;
  }Ct.prototype = { constructor: Ct, one(t, e, i, n) {
    return Lt(this, t, e, i, n, !0);
  }, on(t, e, i, n) {
    return Lt(this, t, e, i, n, !1);
  }, isSilent(t) {
    const e = this._$handlers;return !e[t] || !e[t].length;
  }, off(t, e) {
    const i = this._$handlers;if (!t) return this._$handlers = {}, this;if (e) {
      if (i[t]) {
        for (var n = [], o = 0, a = i[t].length;o < a;o++)i[t][o].h !== e && n.push(i[t][o]);i[t] = n;
      }i[t] && 0 === i[t].length && delete i[t];
    } else delete i[t];return this;
  }, trigger(t) {
    const e = this._$handlers[t]; const i = this._$eventProcessor;if (e) {
      let n = arguments; const o = n.length;3 < o && (n = Dt.call(n, 1));for (let a = e.length, r = 0;r < a;) {
        const s = e[r];if (i && i.filter && null != s.query && !i.filter(t, s.query))r++;else {
          switch (o) {
            case 1:s.h.call(s.ctx);break;case 2:s.h.call(s.ctx, n[1]);break;case 3:s.h.call(s.ctx, n[1], n[2]);break;default:s.h.apply(s.ctx, n);
          }s.one ? (e.splice(r, 1), a--) : r++;
        }
      }
    } return i && i.afterTrigger && i.afterTrigger(t), this;
  }, triggerWithContext(t) {
    const e = this._$handlers[t]; const i = this._$eventProcessor;if (e) {
      let n = arguments; const o = n.length;4 < o && (n = Dt.call(n, 1, n.length - 1));for (let a = n[n.length - 1], r = e.length, s = 0;s < r;) {
        const l = e[s];if (i && i.filter && null != l.query && !i.filter(t, l.query))s++;else {
          switch (o) {
            case 1:l.h.call(a);break;case 2:l.h.call(a, n[1]);break;case 3:l.h.call(a, n[1], n[2]);break;default:l.h.apply(a, n);
          }l.one ? (e.splice(s, 1), r--) : s++;
        }
      }
    } return i && i.afterTrigger && i.afterTrigger(t), this;
  } };const kt = Math.log(2);function Pt(t, e, i, n, o, a) {
    const r = `${n}-${o}`; const s = t.length;if (a.hasOwnProperty(r)) return a[r];if (1 === e) {
      const l = Math.round(Math.log((1 << s) - 1 & ~o) / kt);return t[i][l];
    } for (var u = n | 1 << i, h = i + 1;n & 1 << h;)h++;for (var c = 0, d = 0, f = 0;d < s;d++) {
      const p = 1 << d;p & o || (c += (f % 2 ? -1 : 1) * t[i][d] * Pt(t, e - 1, h, u, o | p, a), f++);
    } return a[r] = c;
  } function Nt(t, e) {
    const i = [[t[0], t[1], 1, 0, 0, 0, -e[0] * t[0], -e[0] * t[1]], [0, 0, 0, t[0], t[1], 1, -e[1] * t[0], -e[1] * t[1]], [t[2], t[3], 1, 0, 0, 0, -e[2] * t[2], -e[2] * t[3]], [0, 0, 0, t[2], t[3], 1, -e[3] * t[2], -e[3] * t[3]], [t[4], t[5], 1, 0, 0, 0, -e[4] * t[4], -e[4] * t[5]], [0, 0, 0, t[4], t[5], 1, -e[5] * t[4], -e[5] * t[5]], [t[6], t[7], 1, 0, 0, 0, -e[6] * t[6], -e[6] * t[7]], [0, 0, 0, t[6], t[7], 1, -e[7] * t[6], -e[7] * t[7]]]; const n = {}; const o = Pt(i, 8, 0, 0, 0, n);if (0 !== o) {
      for (var a = [], r = 0;r < 8;r++) for (let s = 0;s < 8;s++)null == a[s] && (a[s] = 0), a[s] += ((r + s) % 2 ? -1 : 1) * Pt(i, 7, 0 === r ? 1 : 0, 1 << r, 1 << s, n) / o * e[r];return function (t, e, i) {
        const n = e * a[6] + i * a[7] + 1;t[0] = (e * a[0] + i * a[1] + a[2]) / n, t[1] = (e * a[3] + i * a[4] + a[5]) / n;
      };
    }
  } const Ot = '___zrEVENTSAVED'; const Rt = [];function Et(t, e, i, n, o) {
    if (e.getBoundingClientRect && v.domSupported && !zt(e)) {
      const a = e[Ot] || (e[Ot] = {}); const r = (function (t, e, i) {
        for (var n = i ? 'invTrans' : 'trans', o = e[n], a = e.srcCoords, r = !0, s = [], l = [], u = 0;u < 4;u++) {
          const h = t[u].getBoundingClientRect(); const c = 2 * u; const d = h.left; const f = h.top;s.push(d, f), r = r && a && d === a[c] && f === a[1 + c], l.push(t[u].offsetLeft, t[u].offsetTop);
        } return r && o ? o : (e.srcCoords = s, e[n] = i ? Nt(l, s) : Nt(s, l));
      }((function (t, e) {
        let i = e.markers;if (i) return i;i = e.markers = [];for (let n = ['left', 'right'], o = ['top', 'bottom'], a = 0;a < 4;a++) {
          const r = document.createElement('div'); const s = r.style; const l = a % 2; const u = (a >> 1) % 2;s.cssText = ['position: absolute', 'visibility: hidden', 'padding: 0', 'margin: 0', 'border-width: 0', 'user-select: none', 'width:0', 'height:0', `${n[l]}:0`, `${o[u]}:0`, `${n[1 - l]}:auto`, `${o[1 - u]}:auto`, ''].join('!important;'), t.appendChild(r), i.push(r);
        } return i;
      }(e, a)), a, o));if (r) return r(t, i, n), !0;
    } return !1;
  } function zt(t) {
    return 'CANVAS' === t.nodeName.toUpperCase();
  } const Bt = 'undefined' !== typeof window && !!window.addEventListener; const Vt = /^(?:mouse|pointer|contextmenu|drag|drop)|click/; const Gt = [];function Ft(t, e, i, n) {
    return i = i || {}, n || !v.canvasSupported ? Wt(t, e, i) : v.browser.firefox && null != e.layerX && e.layerX !== e.offsetX ? (i.zrX = e.layerX, i.zrY = e.layerY) : null != e.offsetX ? (i.zrX = e.offsetX, i.zrY = e.offsetY) : Wt(t, e, i), i;
  } function Wt(t, e, i) {
    if (v.domSupported && t.getBoundingClientRect) {
      const n = e.clientX; const o = e.clientY;if (zt(t)) {
        const a = t.getBoundingClientRect();return i.zrX = n - a.left, void(i.zrY = o - a.top);
      } if (Et(Gt, t, n, o)) return i.zrX = Gt[0], void(i.zrY = Gt[1]);
    }i.zrX = i.zrY = 0;
  } function Ht(t) {
    return t || window.event;
  } function Zt(t, e, i) {
    if (null != (e = Ht(e)).zrX) return e;const n = e.type;if (n && 0 <= n.indexOf('touch')) {
      const o = 'touchend' !== n ? e.targetTouches[0] : e.changedTouches[0];o && Ft(t, o, e, i);
    } else Ft(t, e, e, i), e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;const a = e.button;return null == e.which && void 0 !== a && Vt.test(e.type) && (e.which = 1 & a ? 1 : 2 & a ? 3 : 4 & a ? 2 : 0), e;
  } function Ut(t, e, i, n) {
    Bt ? t.addEventListener(e, i, n) : t.attachEvent(`on${e}`, i);
  } const Xt = Bt ? function (t) {
    t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0;
  } : function (t) {
    t.returnValue = !1, t.cancelBubble = !0;
  };function Yt(t) {
    return 2 === t.which || 3 === t.which;
  } function jt() {
    this._track = [];
  } function qt(t) {
    const e = t[1][0] - t[0][0]; const i = t[1][1] - t[0][1];return Math.sqrt(e * e + i * i);
  }jt.prototype = { constructor: jt, recognize(t, e, i) {
    return this._doTrack(t, e, i), this._recognize(t);
  }, clear() {
    return this._track.length = 0, this;
  }, _doTrack(t, e, i) {
    const n = t.touches;if (n) {
      for (var o = { points: [], touches: [], target: e, event: t }, a = 0, r = n.length;a < r;a++) {
        const s = n[a]; const l = Ft(i, s, {});o.points.push([l.zrX, l.zrY]), o.touches.push(s);
      } this._track.push(o);
    }
  }, _recognize(t) {
    for (const e in Kt) if (Kt.hasOwnProperty(e)) {
      const i = Kt[e](this._track, t);if (i) return i;
    }
  } };var Kt = { pinch(t, e) {
    const i = t.length;if (i) {
      const n = (t[i - 1] || {}).points; const o = (t[i - 2] || {}).points || n;if (o && 1 < o.length && n && 1 < n.length) {
        let a = qt(n) / qt(o);isFinite(a) || (a = 1), e.pinchScale = a;const r = (function (t) {
          return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2];
        }(n));return e.pinchX = r[0], e.pinchY = r[1], { type: 'pinch', target: t[0].target, event: e };
      }
    }
  } }; const $t = 'silent';function Jt() {
    Xt(this.event);
  } function Qt() {}Qt.prototype.dispose = function () {};function te(t, e, i, n) {
    Ct.call(this), this.storage = t, this.painter = e, this.painterRoot = n, i = i || new Qt, this.proxy = null, this._hovered = {}, this._lastTouchMoment, this._lastX, this._lastY, this._gestureMgr, Tt.call(this), this.setHandlerProxy(i);
  } const ee = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];function ie(t, e, i) {
    if (t[t.rectHover ? 'rectContain' : 'contain'](e, i)) {
      for (var n, o = t;o;) {
        if (o.clipPath && !o.clipPath.contain(e, i)) return !1;o.silent && (n = !0), o = o.parent;
      } return !n || $t;
    } return !1;
  } function ne(t, e, i) {
    const n = t.painter;return e < 0 || e > n.getWidth() || i < 0 || i > n.getHeight();
  }te.prototype = { constructor: te, setHandlerProxy(e) {
    this.proxy && this.proxy.dispose(), e && (R(ee, function (t) {
      e.on && e.on(t, this[t], this);
    }, this), e.handler = this), this.proxy = e;
  }, mousemove(t) {
    const e = t.zrX; const i = t.zrY; const n = ne(this, e, i); let o = this._hovered; let a = o.target;a && !a.__zr && (a = (o = this.findHover(o.x, o.y)).target);const r = this._hovered = n ? { x: e, y: i } : this.findHover(e, i); const s = r.target; const l = this.proxy;l.setCursor && l.setCursor(s ? s.cursor : 'default'), a && s !== a && this.dispatchToElement(o, 'mouseout', t), this.dispatchToElement(r, 'mousemove', t), s && s !== a && this.dispatchToElement(r, 'mouseover', t);
  }, mouseout(t) {
    const e = t.zrEventControl; const i = t.zrIsToLocalDOM;'only_globalout' !== e && this.dispatchToElement(this._hovered, 'mouseout', t), 'no_globalout' !== e && (i || this.trigger('globalout', { type: 'globalout', event: t }));
  }, resize(t) {
    this._hovered = {};
  }, dispatch(t, e) {
    const i = this[t];i && i.call(this, e);
  }, dispose() {
    this.proxy.dispose(), this.storage = this.proxy = this.painter = null;
  }, setCursorStyle(t) {
    const e = this.proxy;e.setCursor && e.setCursor(t);
  }, dispatchToElement(t, e, i) {
    let n = (t = t || {}).target;if (!n || !n.silent) {
      for (var o = `on${e}`, a = (function (t, e, i) {
        return { type: t, event: i, target: e.target, topTarget: e.topTarget, cancelBubble: !1, offsetX: i.zrX, offsetY: i.zrY, gestureEvent: i.gestureEvent, pinchX: i.pinchX, pinchY: i.pinchY, pinchScale: i.pinchScale, wheelDelta: i.zrDelta, zrByTouch: i.zrByTouch, which: i.which, stop: Jt };
      }(e, t, i));n && (n[o] && (a.cancelBubble = n[o].call(n, a)), n.trigger(e, a), n = n.parent, !a.cancelBubble););a.cancelBubble || (this.trigger(e, a), this.painter && this.painter.eachOtherLayer((t) => {
        'function' === typeof t[o] && t[o].call(t, a), t.trigger && t.trigger(e, a);
      }));
    }
  }, findHover(t, e, i) {
    for (var n = this.storage.getDisplayList(), o = { x: t, y: e }, a = n.length - 1;0 <= a;a--) {
      var r;if (n[a] !== i && !n[a].ignore && (r = ie(n[a], t, e)) && (o.topTarget || (o.topTarget = n[a]), r !== $t)) {
        o.target = n[a];break;
      }
    } return o;
  }, processGesture(t, e) {
    this._gestureMgr || (this._gestureMgr = new jt);const i = this._gestureMgr;'start' === e && i.clear();const n = i.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom);if ('end' === e && i.clear(), n) {
      const o = n.type;t.gestureEvent = o, this.dispatchToElement({ target: n.target }, o, n.event);
    }
  } }, R(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], (r) => {
    te.prototype[r] = function (t) {
      let e; let i; const n = t.zrX; const o = t.zrY; const a = ne(this, n, o);if ('mouseup' === r && a || (i = (e = this.findHover(n, o)).target), 'mousedown' === r) this._downEl = i, this._downPoint = [t.zrX, t.zrY], this._upEl = i;else if ('mouseup' === r) this._upEl = i;else if ('click' === r) {
        if (this._downEl !== this._upEl || !this._downPoint || 4 < yt(this._downPoint, [t.zrX, t.zrY])) return;this._downPoint = null;
      } this.dispatchToElement(e, r, t);
    };
  }), b(te, Ct), b(te, Tt);const oe = 'undefined' === typeof Float32Array ? Array : Float32Array;function ae() {
    const t = new oe(6);return re(t), t;
  } function re(t) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;
  } function se(t, e) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t;
  } function le(t, e, i) {
    const n = e[0] * i[0] + e[2] * i[1]; const o = e[1] * i[0] + e[3] * i[1]; const a = e[0] * i[2] + e[2] * i[3]; const r = e[1] * i[2] + e[3] * i[3]; const s = e[0] * i[4] + e[2] * i[5] + e[4]; const l = e[1] * i[4] + e[3] * i[5] + e[5];return t[0] = n, t[1] = o, t[2] = a, t[3] = r, t[4] = s, t[5] = l, t;
  } function ue(t, e, i) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t;
  } function he(t, e, i) {
    const n = e[0]; const o = e[2]; const a = e[4]; const r = e[1]; const s = e[3]; const l = e[5]; const u = Math.sin(i); const h = Math.cos(i);return t[0] = n * h + r * u, t[1] = -n * u + r * h, t[2] = o * h + s * u, t[3] = -o * u + h * s, t[4] = h * a + u * l, t[5] = h * l - u * a, t;
  } function ce(t, e, i) {
    const n = i[0]; const o = i[1];return t[0] = e[0] * n, t[1] = e[1] * o, t[2] = e[2] * n, t[3] = e[3] * o, t[4] = e[4] * n, t[5] = e[5] * o, t;
  } function de(t, e) {
    const i = e[0]; const n = e[2]; const o = e[4]; const a = e[1]; const r = e[3]; const s = e[5]; let l = i * r - a * n;return l ? (l = 1 / l, t[0] = r * l, t[1] = -a * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - r * o) * l, t[5] = (a * o - i * s) * l, t) : null;
  } function fe(t) {
    const e = ae();return se(e, t), e;
  } const pe = (Object.freeze || Object)({ create: ae, identity: re, copy: se, mul: le, translate: ue, rotate: he, scale: ce, invert: de, clone: fe }); const ge = re;function me(t) {
    return 5e-5 < t || t < -5e-5;
  } const ve = function (t) {
    (t = t || {}).position || (this.position = [0, 0]), null == t.rotation && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null;
  }; const ye = ve.prototype;ye.transform = null, ye.needLocalTransform = function () {
    return me(this.rotation) || me(this.position[0]) || me(this.position[1]) || me(this.scale[0] - 1) || me(this.scale[1] - 1);
  };const xe = [];ye.updateTransform = function () {
    const t = this.parent; const e = t && t.transform; const i = this.needLocalTransform(); let n = this.transform;if (i || e) {
      n = n || ae(), i ? this.getLocalTransform(n) : ge(n), e && (i ? le(n, t.transform, n) : se(n, t.transform)), this.transform = n;const o = this.globalScaleRatio;if (null != o && 1 !== o) {
        this.getGlobalScale(xe);const a = xe[0] < 0 ? -1 : 1; const r = xe[1] < 0 ? -1 : 1; const s = ((xe[0] - a) * o + a) / xe[0] || 0; const l = ((xe[1] - r) * o + r) / xe[1] || 0;n[0] *= s, n[1] *= s, n[2] *= l, n[3] *= l;
      } this.invTransform = this.invTransform || ae(), de(this.invTransform, n);
    } else n && ge(n);
  }, ye.getLocalTransform = function (t) {
    return ve.getLocalTransform(this, t);
  }, ye.setTransform = function (t) {
    const e = this.transform; const i = t.dpr || 1;e ? t.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : t.setTransform(i, 0, 0, i, 0, 0);
  }, ye.restoreTransform = function (t) {
    const e = t.dpr || 1;t.setTransform(e, 0, 0, e, 0, 0);
  };const _e = []; const we = ae();ye.setLocalTransform = function (t) {
    if (t) {
      let e = t[0] * t[0] + t[1] * t[1]; let i = t[2] * t[2] + t[3] * t[3]; const n = this.position; const o = this.scale;me(e - 1) && (e = Math.sqrt(e)), me(i - 1) && (i = Math.sqrt(i)), t[0] < 0 && (e = -e), t[3] < 0 && (i = -i), n[0] = t[4], n[1] = t[5], o[0] = e, o[1] = i, this.rotation = Math.atan2(-t[1] / i, t[0] / e);
    }
  }, ye.decomposeTransform = function () {
    if (this.transform) {
      const t = this.parent; let e = this.transform;t && t.transform && (le(_e, t.invTransform, e), e = _e);const i = this.origin;i && (i[0] || i[1]) && (we[4] = i[0], we[5] = i[1], le(_e, e, we), _e[4] -= i[0], _e[5] -= i[1], e = _e), this.setLocalTransform(e);
    }
  }, ye.getGlobalScale = function (t) {
    const e = this.transform;return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1])) : (t[0] = 1, t[1] = 1), t;
  }, ye.transformCoordToLocal = function (t, e) {
    const i = [t, e]; const n = this.invTransform;return n && bt(i, i, n), i;
  }, ye.transformCoordToGlobal = function (t, e) {
    const i = [t, e]; const n = this.transform;return n && bt(i, i, n), i;
  }, ve.getLocalTransform = function (t, e) {
    ge(e = e || []);const i = t.origin; const n = t.scale || [1, 1]; const o = t.rotation || 0; const a = t.position || [0, 0];return i && (e[4] -= i[0], e[5] -= i[1]), ce(e, e, n), o && he(e, e, o), i && (e[4] += i[0], e[5] += i[1]), e[4] += a[0], e[5] += a[1], e;
  };var be = { linear(t) {
    return t;
  }, quadraticIn(t) {
    return t * t;
  }, quadraticOut(t) {
    return t * (2 - t);
  }, quadraticInOut(t) {
    return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1);
  }, cubicIn(t) {
    return t * t * t;
  }, cubicOut(t) {
    return --t * t * t + 1;
  }, cubicInOut(t) {
    return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2);
  }, quarticIn(t) {
    return t * t * t * t;
  }, quarticOut(t) {
    return 1 - --t * t * t * t;
  }, quarticInOut(t) {
    return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2);
  }, quinticIn(t) {
    return t * t * t * t * t;
  }, quinticOut(t) {
    return --t * t * t * t * t + 1;
  }, quinticInOut(t) {
    return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2);
  }, sinusoidalIn(t) {
    return 1 - Math.cos(t * Math.PI / 2);
  }, sinusoidalOut(t) {
    return Math.sin(t * Math.PI / 2);
  }, sinusoidalInOut(t) {
    return.5 * (1 - Math.cos(Math.PI * t));
  }, exponentialIn(t) {
    return 0 === t ? 0 : Math.pow(1024, t - 1);
  }, exponentialOut(t) {
    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
  }, exponentialInOut(t) {
    return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)));
  }, circularIn(t) {
    return 1 - Math.sqrt(1 - t * t);
  }, circularOut(t) {
    return Math.sqrt(1 - --t * t);
  }, circularInOut(t) {
    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
  }, elasticIn(t) {
    let e; let i = .1;return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4));
  }, elasticOut(t) {
    let e; let i = .1;return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1);
  }, elasticInOut(t) {
    let e; let i = .1;return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1);
  }, backIn(t) {
    return t * t * (2.70158 * t - 1.70158);
  }, backOut(t) {
    return --t * t * (2.70158 * t + 1.70158) + 1;
  }, backInOut(t) {
    const e = 2.5949095;return (t *= 2) < 1 ? t * t * ((1 + e) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + e) * t + e) + 2);
  }, bounceIn(t) {
    return 1 - be.bounceOut(1 - t);
  }, bounceOut(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }, bounceInOut(t) {
    return t < .5 ? .5 * be.bounceIn(2 * t) : .5 * be.bounceOut(2 * t - 1) + .5;
  } };function Se(t) {
    this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null != t.loop && t.loop, this.gap = t.gap || 0, this.easing = t.easing || 'Linear', this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart, this._pausedTime = 0, this._paused = !1;
  }Se.prototype = { constructor: Se, step(t, e) {
    if (this._initialized || (this._startTime = t + this._delay, this._initialized = !0), this._paused) this._pausedTime += e;else {
      let i = (t - this._startTime - this._pausedTime) / this._life;if (!(i < 0)) {
        i = Math.min(i, 1);const n = this.easing; const o = 'string' === typeof n ? be[n] : n; const a = 'function' === typeof o ? o(i) : i;return this.fire('frame', a), 1 === i ? this.loop ? (this.restart(t), 'restart') : (this._needsRemove = !0, 'destroy') : null;
      }
    }
  }, restart(t) {
    const e = (t - this._startTime - this._pausedTime) % this._life;this._startTime = t - e + this.gap, this._pausedTime = 0, this._needsRemove = !1;
  }, fire(t, e) {
    this[t = `on${t}`] && this[t](this._target, e);
  }, pause() {
    this._paused = !0;
  }, resume() {
    this._paused = !1;
  } };function Me() {
    this.head = null, this.tail = null, this._len = 0;
  } const Ie = Me.prototype;Ie.insert = function (t) {
    const e = new Ae(t);return this.insertEntry(e), e;
  }, Ie.insertEntry = function (t) {
    this.head ? ((this.tail.next = t).prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
  }, Ie.remove = function (t) {
    const e = t.prev; const i = t.next;e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--;
  }, Ie.len = function () {
    return this._len;
  }, Ie.clear = function () {
    this.head = this.tail = null, this._len = 0;
  };function Te(t) {
    this._list = new Me, this._map = {}, this._maxSize = t || 10, this._lastRemovedEntry = null;
  } var Ae = function (t) {
    this.value = t, this.next, this.prev;
  }; const De = Te.prototype;De.put = function (t, e) {
    const i = this._list; const n = this._map; let o = null;if (null == n[t]) {
      const a = i.len(); let r = this._lastRemovedEntry;if (a >= this._maxSize && 0 < a) {
        const s = i.head;i.remove(s), delete n[s.key], o = s.value, this._lastRemovedEntry = s;
      }r ? r.value = e : r = new Ae(e), r.key = t, i.insertEntry(r), n[t] = r;
    } return o;
  }, De.get = function (t) {
    const e = this._map[t]; const i = this._list;if (null != e) return e !== i.tail && (i.remove(e), i.insertEntry(e)), e.value;
  }, De.clear = function () {
    this._list.clear(), this._map = {};
  };const Ce = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };function Le(t) {
    return (t = Math.round(t)) < 0 ? 0 : 255 < t ? 255 : t;
  } function ke(t) {
    return t < 0 ? 0 : 1 < t ? 1 : t;
  } function Pe(t) {
    return t.length && '%' === t.charAt(t.length - 1) ? Le(parseFloat(t) / 100 * 255) : Le(parseInt(t, 10));
  } function Ne(t) {
    return t.length && '%' === t.charAt(t.length - 1) ? ke(parseFloat(t) / 100) : ke(parseFloat(t));
  } function Oe(t, e, i) {
    return i < 0 ? i += 1 : 1 < i && (i -= 1), 6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t;
  } function Re(t, e, i) {
    return t + (e - t) * i;
  } function Ee(t, e, i, n, o) {
    return t[0] = e, t[1] = i, t[2] = n, t[3] = o, t;
  } function ze(t, e) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;
  } const Be = new Te(20); let Ve = null;function Ge(t, e) {
    Ve && ze(Ve, e), Ve = Be.put(t, Ve || e.slice());
  } function Fe(t, e) {
    if (t) {
      e = e || [];const i = Be.get(t);if (i) return ze(e, i);let n; const o = (t += '').replace(/ /g, '').toLowerCase();if (o in Ce) return ze(e, Ce[o]), Ge(t, e), e;if ('#' === o.charAt(0)) return 4 === o.length ? 0 <= (n = parseInt(o.substr(1), 16)) && n <= 4095 ? (Ee(e, (3840 & n) >> 4 | (3840 & n) >> 8, 240 & n | (240 & n) >> 4, 15 & n | (15 & n) << 4, 1), Ge(t, e), e) : void Ee(e, 0, 0, 0, 1) : 7 === o.length ? 0 <= (n = parseInt(o.substr(1), 16)) && n <= 16777215 ? (Ee(e, (16711680 & n) >> 16, (65280 & n) >> 8, 255 & n, 1), Ge(t, e), e) : void Ee(e, 0, 0, 0, 1) : void 0;const a = o.indexOf('('); const r = o.indexOf(')');if (-1 !== a && r + 1 === o.length) {
        const s = o.substr(0, a); const l = o.substr(a + 1, r - (a + 1)).split(','); let u = 1;switch (s) {
          case 'rgba':if (4 !== l.length) return void Ee(e, 0, 0, 0, 1);u = Ne(l.pop());case 'rgb':return 3 !== l.length ? void Ee(e, 0, 0, 0, 1) : (Ee(e, Pe(l[0]), Pe(l[1]), Pe(l[2]), u), Ge(t, e), e);case 'hsla':return 4 !== l.length ? void Ee(e, 0, 0, 0, 1) : (l[3] = Ne(l[3]), We(l, e), Ge(t, e), e);case 'hsl':return 3 !== l.length ? void Ee(e, 0, 0, 0, 1) : (We(l, e), Ge(t, e), e);default:return;
        }
      }Ee(e, 0, 0, 0, 1);
    }
  } function We(t, e) {
    const i = (parseFloat(t[0]) % 360 + 360) % 360 / 360; const n = Ne(t[1]); const o = Ne(t[2]); const a = o <= .5 ? o * (n + 1) : o + n - o * n; const r = 2 * o - a;return Ee(e = e || [], Le(255 * Oe(r, a, i + 1 / 3)), Le(255 * Oe(r, a, i)), Le(255 * Oe(r, a, i - 1 / 3)), 1), 4 === t.length && (e[3] = t[3]), e;
  } function He(t, e) {
    const i = Fe(t);if (i) {
      for (let n = 0;n < 3;n++)i[n] = e < 0 ? i[n] * (1 - e) | 0 : (255 - i[n]) * e + i[n] | 0, 255 < i[n] ? i[n] = 255 : t[n] < 0 && (i[n] = 0);return $e(i, 4 === i.length ? 'rgba' : 'rgb');
    }
  } function Ze(t) {
    const e = Fe(t);if (e) return ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1);
  } function Ue(t, e, i) {
    if (e && e.length && 0 <= t && t <= 1) {
      i = i || [];const n = t * (e.length - 1); const o = Math.floor(n); const a = Math.ceil(n); const r = e[o]; const s = e[a]; const l = n - o;return i[0] = Le(Re(r[0], s[0], l)), i[1] = Le(Re(r[1], s[1], l)), i[2] = Le(Re(r[2], s[2], l)), i[3] = ke(Re(r[3], s[3], l)), i;
    }
  } const Xe = Ue;function Ye(t, e, i) {
    if (e && e.length && 0 <= t && t <= 1) {
      const n = t * (e.length - 1); const o = Math.floor(n); const a = Math.ceil(n); const r = Fe(e[o]); const s = Fe(e[a]); const l = n - o; const u = $e([Le(Re(r[0], s[0], l)), Le(Re(r[1], s[1], l)), Le(Re(r[2], s[2], l)), ke(Re(r[3], s[3], l))], 'rgba');return i ? { color: u, leftIndex: o, rightIndex: a, value: n } : u;
    }
  } const je = Ye;function qe(t, e, i, n) {
    if (t = Fe(t)) return t = (function (t) {
      if (t) {
        let e; let i; const n = t[0] / 255; const o = t[1] / 255; const a = t[2] / 255; const r = Math.min(n, o, a); const s = Math.max(n, o, a); const l = s - r; const u = (s + r) / 2;if (0 == l)i = e = 0;else {
          i = u < .5 ? l / (s + r) : l / (2 - s - r);const h = ((s - n) / 6 + l / 2) / l; const c = ((s - o) / 6 + l / 2) / l; const d = ((s - a) / 6 + l / 2) / l;n === s ? e = d - c : o === s ? e = 1 / 3 + h - d : a === s && (e = 2 / 3 + c - h), e < 0 && (e += 1), 1 < e && (e -= 1);
        } const f = [360 * e, i, u];return null != t[3] && f.push(t[3]), f;
      }
    }(t)), null != e && (t[0] = (function (t) {
      return (t = Math.round(t)) < 0 ? 0 : 360 < t ? 360 : t;
    }(e))), null != i && (t[1] = Ne(i)), null != n && (t[2] = Ne(n)), $e(We(t), 'rgba');
  } function Ke(t, e) {
    if ((t = Fe(t)) && null != e) return t[3] = ke(e), $e(t, 'rgba');
  } function $e(t, e) {
    if (t && t.length) {
      let i = `${t[0]},${t[1]},${t[2]}`;return 'rgba' !== e && 'hsva' !== e && 'hsla' !== e || (i += `,${t[3]}`), `${e}(${i})`;
    }
  } const Je = (Object.freeze || Object)({ parse: Fe, lift: He, toHex: Ze, fastLerp: Ue, fastMapToColor: Xe, lerp: Ye, mapToColor: je, modifyHSL: qe, modifyAlpha: Ke, stringify: $e }); const Qe = Array.prototype.slice;function ti(t, e) {
    return t[e];
  } function ei(t, e, i) {
    t[e] = i;
  } function ii(t, e, i) {
    return (e - t) * i + t;
  } function ni(t, e, i) {
    return.5 < i ? e : t;
  } function oi(t, e, i, n, o) {
    const a = t.length;if (1 === o) for (var r = 0;r < a;r++)n[r] = ii(t[r], e[r], i);else {
      const s = a && t[0].length;for (r = 0;r < a;r++) for (let l = 0;l < s;l++)n[r][l] = ii(t[r][l], e[r][l], i);
    }
  } function ai(t, e, i) {
    const n = t.length; const o = e.length;if (n !== o) if (o < n)t.length = o;else for (var a = n;a < o;a++)t.push(1 === i ? e[a] : Qe.call(e[a]));const r = t[0] && t[0].length;for (a = 0;a < t.length;a++) if (1 === i)isNaN(t[a]) && (t[a] = e[a]);else for (let s = 0;s < r;s++)isNaN(t[a][s]) && (t[a][s] = e[a][s]);
  } function ri(t, e, i) {
    if (t === e) return !0;const n = t.length;if (n !== e.length) return !1;if (1 === i) {
      for (var o = 0;o < n;o++) if (t[o] !== e[o]) return !1;
    } else {
      const a = t[0].length;for (o = 0;o < n;o++) for (let r = 0;r < a;r++) if (t[o][r] !== e[o][r]) return !1;
    } return !0;
  } function si(t, e, i, n, o, a, r, s, l) {
    const u = t.length;if (1 === l) for (var h = 0;h < u;h++)s[h] = li(t[h], e[h], i[h], n[h], o, a, r);else {
      const c = t[0].length;for (h = 0;h < u;h++) for (let d = 0;d < c;d++)s[h][d] = li(t[h][d], e[h][d], i[h][d], n[h][d], o, a, r);
    }
  } function li(t, e, i, n, o, a, r) {
    const s = .5 * (i - t); const l = .5 * (n - e);return (2 * (e - i) + s + l) * r + (-3 * (e - i) - 2 * s - l) * a + s * o + e;
  } function ui(t) {
    if (N(t)) {
      const e = t.length;if (N(t[0])) {
        for (var i = [], n = 0;n < e;n++)i.push(Qe.call(t[n]));return i;
      } return Qe.call(t);
    } return t;
  } function hi(t) {
    return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), `rgba(${t.join(',')})`;
  } function ci(t, e, i, n, a, o) {
    const r = t._getter; const s = t._setter; const l = 'spline' === e; const u = n.length;if (u) {
      let h; const c = N(n[0].value); let d = !1; let f = !1; const p = c ? (function (t) {
        const e = t[t.length - 1].value;return N(e && e[0]) ? 2 : 1;
      }(n)) : 0;n.sort((t, e) => t.time - e.time), h = n[u - 1].time;for (var g = [], m = [], v = n[0].value, y = !0, x = 0;x < u;x++) {
        g.push(n[x].time / h);let _ = n[x].value;if (c && ri(_, v, p) || !c && _ === v || (y = !1), 'string' === typeof(v = _)) {
          const w = Fe(_);w ? (_ = w, d = !0) : f = !0;
        }m.push(_);
      } if (o || !y) {
        const b = m[u - 1];for (x = 0;x < u - 1;x++)c ? ai(m[x], b, p) : !isNaN(m[x]) || isNaN(b) || f || d || (m[x] = b);c && ai(r(t._target, a), b, p);let S; let M; let I; let T; let A; let D = 0; let C = 0;if (d) var L = [0, 0, 0, 0];const k = new Se({ target: t._target, life: h, loop: t._loop, delay: t._delay, onframe(t, e) {
          let i;if (e < 0)i = 0;else if (e < C) {
            for (i = Math.min(D + 1, u - 1);0 <= i && !(g[i] <= e);i--);i = Math.min(i, u - 2);
          } else {
            for (i = D;i < u && !(g[i] > e);i++);i = Math.min(i - 1, u - 2);
          }C = e;const n = g[(D = i) + 1] - g[i];if (0 != n) if (S = (e - g[i]) / n, l) if (I = m[i], M = m[0 === i ? i : i - 1], T = m[u - 2 < i ? u - 1 : i + 1], A = m[u - 3 < i ? u - 1 : i + 2], c)si(M, I, T, A, S, S * S, S * S * S, r(t, a), p);else {
            if (d)o = si(M, I, T, A, S, S * S, S * S * S, L, 1), o = hi(L);else {
              if (f) return ni(I, T, S);o = li(M, I, T, A, S, S * S, S * S * S);
            }s(t, a, o);
          } else if (c)oi(m[i], m[i + 1], S, r(t, a), p);else {
            var o;if (d)oi(m[i], m[i + 1], S, L, 1), o = hi(L);else {
              if (f) return ni(m[i], m[i + 1], S);o = ii(m[i], m[i + 1], S);
            }s(t, a, o);
          }
        }, ondestroy: i });return e && 'spline' !== e && (k.easing = e), k;
      }
    }
  } function di(t, e, i, n) {
    this._tracks = {}, this._target = t, this._loop = e || !1, this._getter = i || ti, this._setter = n || ei, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = [];
  }di.prototype = { when(t, e) {
    const i = this._tracks;for (const n in e) if (e.hasOwnProperty(n)) {
      if (!i[n]) {
        i[n] = [];const o = this._getter(this._target, n);if (null == o) continue;0 !== t && i[n].push({ time: 0, value: ui(o) });
      }i[n].push({ time: t, value: e[n] });
    } return this;
  }, during(t) {
    return this._onframeList.push(t), this;
  }, pause() {
    for (let t = 0;t < this._clipList.length;t++) this._clipList[t].pause();this._paused = !0;
  }, resume() {
    for (let t = 0;t < this._clipList.length;t++) this._clipList[t].resume();this._paused = !1;
  }, isPaused() {
    return !!this._paused;
  }, _doneCallback() {
    this._tracks = {}, this._clipList.length = 0;for (let t = this._doneList, e = t.length, i = 0;i < e;i++)t[i].call(this);
  }, start(t, e) {
    function i() {
      --a || o._doneCallback();
    } let n; var o = this; var a = 0;for (const r in this._tracks) if (this._tracks.hasOwnProperty(r)) {
      const s = ci(this, t, i, this._tracks[r], r, e);s && (this._clipList.push(s), a++, this.animation && this.animation.addClip(s), n = s);
    } if (n) {
      const l = n.onframe;n.onframe = function (t, e) {
        l(t, e);for (let i = 0;i < o._onframeList.length;i++)o._onframeList[i](t, e);
      };
    } return a || this._doneCallback(), this;
  }, stop(t) {
    for (var e = this._clipList, i = this.animation, n = 0;n < e.length;n++) {
      const o = e[n];t && o.onframe(this._target, 1), i && i.removeClip(o);
    }e.length = 0;
  }, delay(t) {
    return this._delay = t, this;
  }, done(t) {
    return t && this._doneList.push(t), this;
  }, getClips() {
    return this._clipList;
  } };let fi = 1;'undefined' !== typeof window && (fi = Math.max(window.devicePixelRatio || 1, 1));const pi = fi; const gi = function () {};function mi() {
    this.animators = [];
  } const vi = gi;function yi(t, e, i, n, o, a, r, s) {
    E(n) ? (a = o, o = n, n = 0) : C(o) ? (a = o, o = 'linear', n = 0) : C(n) ? (a = n, n = 0) : i = C(i) ? (a = i, 500) : i || 500, t.stopAnimation(), (function t(e, i, n, o, a, r, s) {
      const l = {};let u = 0;for (const h in o)o.hasOwnProperty(h) && (null != n[h] ? z(o[h]) && !N(o[h]) ? t(e, i ? `${i}.${h}` : h, n[h], o[h], a, r, s) : (s ? (l[h] = n[h], xi(e, i, h, o[h])) : l[h] = o[h], u++) : null == o[h] || s || xi(e, i, h, o[h]));0 < u && e.animate(i, !1).when(null == a ? 500 : a, l)
        .delay(r || 0);
    }(t, '', t, e, i, n, s));const l = t.animators.slice(); let u = l.length;function h() {
      --u || a && a();
    }u || a && a();for (let c = 0;c < l.length;c++)l[c].done(h).start(o, r);
  } function xi(t, e, i, n) {
    if (e) {
      const o = {};o[e] = {}, o[e][i] = n, t.attr(o);
    } else t.attr(i, n);
  }mi.prototype = { constructor: mi, animate(t, e) {
    let i; let n = !1; const o = this; const a = this.__zr;if (t) {
      const r = t.split('.'); let s = o;n = 'shape' === r[0];for (let l = 0, u = r.length;l < u;l++)s = s && s[r[l]];s && (i = s);
    } else i = o;if (i) {
      const h = o.animators; const c = new di(i, e);return c.during((t) => {
        o.dirty(n);
      }).done(() => {
        h.splice(_(h, c), 1);
      }), h.push(c), a && a.animation.addAnimator(c), c;
    }vi(`Property "${t}" is not existed in element ${o.id}`);
  }, stopAnimation(t) {
    for (var e = this.animators, i = e.length, n = 0;n < i;n++)e[n].stop(t);return e.length = 0, this;
  }, animateTo(t, e, i, n, o, a) {
    yi(this, t, e, i, n, o, a);
  }, animateFrom(t, e, i, n, o, a) {
    yi(this, t, e, i, n, o, a, !0);
  } };const _i = function (t) {
    ve.call(this, t), Ct.call(this, t), mi.call(this, t), this.id = t.id || n();
  };_i.prototype = { type: 'element', name: '', __zr: null, ignore: !1, clipPath: null, isGroup: !1, drift(t, e) {
    switch (this.draggable) {
      case 'horizontal':e = 0;break;case 'vertical':t = 0;
    } let i = this.transform;(i = i || (this.transform = [1, 0, 0, 1, 0, 0]))[4] += t, i[5] += e, this.decomposeTransform(), this.dirty(!1);
  }, beforeUpdate() {}, afterUpdate() {}, update() {
    this.updateTransform();
  }, traverse(t, e) {}, attrKV(t, e) {
    if ('position' === t || 'scale' === t || 'origin' === t) {
      if (e) {
        let i = this[t];(i = i || (this[t] = []))[0] = e[0], i[1] = e[1];
      }
    } else this[t] = e;
  }, hide() {
    this.ignore = !0, this.__zr && this.__zr.refresh();
  }, show() {
    this.ignore = !1, this.__zr && this.__zr.refresh();
  }, attr(t, e) {
    if ('string' === typeof t) this.attrKV(t, e);else if (z(t)) for (const i in t)t.hasOwnProperty(i) && this.attrKV(i, t[i]);return this.dirty(!1), this;
  }, setClipPath(t) {
    const e = this.__zr;e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), (this.clipPath = t).__zr = e, (t.__clipTarget = this).dirty(!1);
  }, removeClipPath() {
    const t = this.clipPath;t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty(!1));
  }, addSelfToZr(t) {
    this.__zr = t;const e = this.animators;if (e) for (let i = 0;i < e.length;i++)t.animation.addAnimator(e[i]);this.clipPath && this.clipPath.addSelfToZr(t);
  }, removeSelfFromZr(t) {
    this.__zr = null;const e = this.animators;if (e) for (let i = 0;i < e.length;i++)t.animation.removeAnimator(e[i]);this.clipPath && this.clipPath.removeSelfFromZr(t);
  } }, b(_i, mi), b(_i, ve), b(_i, Ct);let wi; let bi; let Si; let Mi; const Ii = bt; const Ti = Math.min; const Ai = Math.max;function Di(t, e, i, n) {
    i < 0 && (t += i, i = -i), n < 0 && (e += n, n = -n), this.x = t, this.y = e, this.width = i, this.height = n;
  }Di.prototype = { constructor: Di, union(t) {
    const e = Ti(t.x, this.x); const i = Ti(t.y, this.y);this.width = Ai(t.x + t.width, this.x + this.width) - e, this.height = Ai(t.y + t.height, this.y + this.height) - i, this.x = e, this.y = i;
  }, applyTransform: (wi = [], bi = [], Si = [], Mi = [], function (t) {
    if (t) {
      wi[0] = Si[0] = this.x, wi[1] = Mi[1] = this.y, bi[0] = Mi[0] = this.x + this.width, bi[1] = Si[1] = this.y + this.height, Ii(wi, wi, t), Ii(bi, bi, t), Ii(Si, Si, t), Ii(Mi, Mi, t), this.x = Ti(wi[0], bi[0], Si[0], Mi[0]), this.y = Ti(wi[1], bi[1], Si[1], Mi[1]);const e = Ai(wi[0], bi[0], Si[0], Mi[0]); const i = Ai(wi[1], bi[1], Si[1], Mi[1]);this.width = e - this.x, this.height = i - this.y;
    }
  }), calculateTransform(t) {
    const e = t.width / this.width; const i = t.height / this.height; const n = ae();return ue(n, n, [-this.x, -this.y]), ce(n, n, [e, i]), ue(n, n, [t.x, t.y]), n;
  }, intersect(t) {
    if (!t) return !1;t instanceof Di || (t = Di.create(t));const e = this; const i = e.x; const n = e.x + e.width; const o = e.y; const a = e.y + e.height; const r = t.x; const s = t.x + t.width; const l = t.y; const u = t.y + t.height;return !(n < r || s < i || a < l || u < o);
  }, contain(t, e) {
    const i = this;return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i.height;
  }, clone() {
    return new Di(this.x, this.y, this.width, this.height);
  }, copy(t) {
    this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height;
  }, plain() {
    return { x: this.x, y: this.y, width: this.width, height: this.height };
  } }, Di.create = function (t) {
    return new Di(t.x, t.y, t.width, t.height);
  };const Ci = function (t) {
    for (const e in t = t || {}, _i.call(this, t), t)t.hasOwnProperty(e) && (this[e] = t[e]);this._children = [], this.__storage = null, this.__dirty = !0;
  };Ci.prototype = { constructor: Ci, isGroup: !0, type: 'group', silent: !1, children() {
    return this._children.slice();
  }, childAt(t) {
    return this._children[t];
  }, childOfName(t) {
    for (let e = this._children, i = 0;i < e.length;i++) if (e[i].name === t) return e[i];
  }, childCount() {
    return this._children.length;
  }, add(t) {
    return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this;
  }, addBefore(t, e) {
    if (t && t !== this && t.parent !== this && e && e.parent === this) {
      const i = this._children; const n = i.indexOf(e);0 <= n && (i.splice(n, 0, t), this._doAdd(t));
    } return this;
  }, _doAdd(t) {
    t.parent && t.parent.remove(t);const e = (t.parent = this).__storage; const i = this.__zr;e && e !== t.__storage && (e.addToStorage(t), t instanceof Ci && t.addChildrenToStorage(e)), i && i.refresh();
  }, remove(t) {
    const e = this.__zr; const i = this.__storage; const n = this._children; const o = _(n, t);return o < 0 || (n.splice(o, 1), t.parent = null, i && (i.delFromStorage(t), t instanceof Ci && t.delChildrenFromStorage(i)), e && e.refresh()), this;
  }, removeAll() {
    let t; let e; const i = this._children; const n = this.__storage;for (e = 0;e < i.length;e++)t = i[e], n && (n.delFromStorage(t), t instanceof Ci && t.delChildrenFromStorage(n)), t.parent = null;return i.length = 0, this;
  }, eachChild(t, e) {
    for (let i = this._children, n = 0;n < i.length;n++) {
      const o = i[n];t.call(e, o, n);
    } return this;
  }, traverse(t, e) {
    for (let i = 0;i < this._children.length;i++) {
      const n = this._children[i];t.call(e, n), 'group' === n.type && n.traverse(t, e);
    } return this;
  }, addChildrenToStorage(t) {
    for (let e = 0;e < this._children.length;e++) {
      const i = this._children[e];t.addToStorage(i), i instanceof Ci && i.addChildrenToStorage(t);
    }
  }, delChildrenFromStorage(t) {
    for (let e = 0;e < this._children.length;e++) {
      const i = this._children[e];t.delFromStorage(i), i instanceof Ci && i.delChildrenFromStorage(t);
    }
  }, dirty() {
    return this.__dirty = !0, this.__zr && this.__zr.refresh(), this;
  }, getBoundingRect(t) {
    for (var e = null, i = new Di(0, 0, 0, 0), n = t || this._children, o = [], a = 0;a < n.length;a++) {
      const r = n[a];if (!r.ignore && !r.invisible) {
        const s = r.getBoundingRect(); const l = r.getLocalTransform(o);l ? (i.copy(s), i.applyTransform(l), (e = e || i.clone()).union(i)) : (e = e || s.clone()).union(s);
      }
    } return e || i;
  } }, w(Ci, _i);const Li = 32; const ki = 7;function Pi(t, e, i, n) {
    let o = e + 1;if (o === i) return 1;if (n(t[o++], t[e]) < 0) {
      for (;o < i && n(t[o], t[o - 1]) < 0;)o++;!(function (t, e, i) {
        i--;for (;e < i;) {
          const n = t[e];t[e++] = t[i], t[i--] = n;
        }
      }(t, e, o));
    } else for (;o < i && 0 <= n(t[o], t[o - 1]);)o++;return o - e;
  } function Ni(t, e, i, n, o) {
    for (n === e && n++;n < i;n++) {
      for (var a, r = t[n], s = e, l = n;s < l;)o(r, t[a = s + l >>> 1]) < 0 ? l = a : s = 1 + a;let u = n - s;switch (u) {
        case 3:t[s + 3] = t[s + 2];case 2:t[s + 2] = t[s + 1];case 1:t[s + 1] = t[s];break;default:for (;0 < u;)t[s + u] = t[s + u - 1], u--;
      }t[s] = r;
    }
  } function Oi(t, e, i, n, o, a) {
    let r = 0; let s = 0; let l = 1;if (0 < a(t, e[i + o])) {
      for (s = n - o;l < s && 0 < a(t, e[i + o + l]);)(l = 1 + ((r = l) << 1)) <= 0 && (l = s);s < l && (l = s), r += o, l += o;
    } else {
      for (s = o + 1;l < s && a(t, e[i + o - l]) <= 0;)(l = 1 + ((r = l) << 1)) <= 0 && (l = s);s < l && (l = s);const u = r;r = o - l, l = o - u;
    } for (r++;r < l;) {
      const h = r + (l - r >>> 1);0 < a(t, e[i + h]) ? r = h + 1 : l = h;
    } return l;
  } function Ri(t, e, i, n, o, a) {
    let r = 0; let s = 0; let l = 1;if (a(t, e[i + o]) < 0) {
      for (s = o + 1;l < s && a(t, e[i + o - l]) < 0;)(l = 1 + ((r = l) << 1)) <= 0 && (l = s);s < l && (l = s);const u = r;r = o - l, l = o - u;
    } else {
      for (s = n - o;l < s && 0 <= a(t, e[i + o + l]);)(l = 1 + ((r = l) << 1)) <= 0 && (l = s);s < l && (l = s), r += o, l += o;
    } for (r++;r < l;) {
      const h = r + (l - r >>> 1);a(t, e[i + h]) < 0 ? l = h : r = h + 1;
    } return l;
  } function Ei(p, g) {
    let r; let s; let m = ki; let l = 0; const v = [];function e(t) {
      let e = r[t]; let i = s[t]; const n = r[t + 1]; let o = s[t + 1];s[t] = i + o, t === l - 3 && (r[t + 1] = r[t + 2], s[t + 1] = s[t + 2]), l--;const a = Ri(p[n], p, e, i, 0, g);e += a, 0 !== (i -= a) && 0 !== (o = Oi(p[e + i - 1], p, n, o, o - 1, g)) && (i <= o ? (function (t, e, i, n) {
        let o = 0;for (o = 0;o < e;o++)v[o] = p[t + o];let a = 0; let r = i; let s = t;if (p[s++] = p[r++], 0 == --n) {
          for (o = 0;o < e;o++)p[s + o] = v[a + o];return;
        } if (1 === e) {
          for (o = 0;o < n;o++)p[s + o] = p[r + o];return p[s + n] = v[a];
        } let l; let u; let h; let c = m;for (;;) {
          u = l = 0, h = !1;do {
            if (g(p[r], v[a]) < 0) {
              if (p[s++] = p[r++], u++, (l = 0) == --n) {
                h = !0;break;
              }
            } else if (p[s++] = v[a++], l++, u = 0, 1 == --e) {
              h = !0;break;
            }
          } while ((l | u) < c);if (h) break;do {
            if (0 !== (l = Ri(p[r], v, a, e, 0, g))) {
              for (o = 0;o < l;o++)p[s + o] = v[a + o];if (s += l, a += l, (e -= l) <= 1) {
                h = !0;break;
              }
            } if (p[s++] = p[r++], 0 == --n) {
              h = !0;break;
            } if (0 !== (u = Oi(v[a], p, r, n, 0, g))) {
              for (o = 0;o < u;o++)p[s + o] = p[r + o];if (s += u, r += u, 0 === (n -= u)) {
                h = !0;break;
              }
            } if (p[s++] = v[a++], 1 == --e) {
              h = !0;break;
            }c--;
          } while (ki <= l || ki <= u);if (h) break;c < 0 && (c = 0), c += 2;
        } if ((m = c) < 1 && (m = 1), 1 === e) {
          for (o = 0;o < n;o++)p[s + o] = p[r + o];p[s + n] = v[a];
        } else {
          if (0 === e) throw new Error;for (o = 0;o < e;o++)p[s + o] = v[a + o];
        }
      }(e, i, n, o)) : (function (t, e, i, n) {
        let o = 0;for (o = 0;o < n;o++)v[o] = p[i + o];let a = t + e - 1; let r = n - 1; let s = i + n - 1; let l = 0; let u = 0;if (p[s--] = p[a--], 0 == --e) {
          for (l = s - (n - 1), o = 0;o < n;o++)p[l + o] = v[o];return;
        } if (1 === n) {
          for (u = (s -= e) + 1, l = (a -= e) + 1, o = e - 1;0 <= o;o--)p[u + o] = p[l + o];return p[s] = v[r];
        } let h = m;for (;;) {
          let c = 0; let d = 0; let f = !1;do {
            if (g(v[r], p[a]) < 0) {
              if (p[s--] = p[a--], c++, (d = 0) == --e) {
                f = !0;break;
              }
            } else if (p[s--] = v[r--], d++, c = 0, 1 == --n) {
              f = !0;break;
            }
          } while ((c | d) < h);if (f) break;do {
            if (0 !== (c = e - Ri(v[r], p, t, e, e - 1, g))) {
              for (e -= c, u = (s -= c) + 1, l = (a -= c) + 1, o = c - 1;0 <= o;o--)p[u + o] = p[l + o];if (0 === e) {
                f = !0;break;
              }
            } if (p[s--] = v[r--], 1 == --n) {
              f = !0;break;
            } if (0 !== (d = n - Oi(p[a], v, 0, n, n - 1, g))) {
              for (n -= d, u = (s -= d) + 1, l = (r -= d) + 1, o = 0;o < d;o++)p[u + o] = v[l + o];if (n <= 1) {
                f = !0;break;
              }
            } if (p[s--] = p[a--], 0 == --e) {
              f = !0;break;
            }h--;
          } while (ki <= c || ki <= d);if (f) break;h < 0 && (h = 0), h += 2;
        }(m = h) < 1 && (m = 1);if (1 === n) {
          for (u = (s -= e) + 1, l = (a -= e) + 1, o = e - 1;0 <= o;o--)p[u + o] = p[l + o];p[s] = v[r];
        } else {
          if (0 === n) throw new Error;for (l = s - (n - 1), o = 0;o < n;o++)p[l + o] = v[o];
        }
      }(e, i, n, o)));
    }r = [], s = [], this.mergeRuns = function () {
      for (;1 < l;) {
        let t = l - 2;if (1 <= t && s[t - 1] <= s[t] + s[t + 1] || 2 <= t && s[t - 2] <= s[t] + s[t - 1])s[t - 1] < s[t + 1] && t--;else if (s[t] > s[t + 1]) break;e(t);
      }
    }, this.forceMergeRuns = function () {
      for (;1 < l;) {
        let t = l - 2;0 < t && s[t - 1] < s[t + 1] && t--, e(t);
      }
    }, this.pushRun = function (t, e) {
      r[l] = t, s[l] = e, l += 1;
    };
  } function zi(t, e, i, n) {
    i = i || 0;let o = (n = n || t.length) - i;if (!(o < 2)) {
      let a = 0;if (o < Li)Ni(t, i, n, i + (a = Pi(t, i, n, e)), e);else {
        const r = new Ei(t, e); const s = (function (t) {
          for (var e = 0;Li <= t;)e |= 1 & t, t >>= 1;return t + e;
        }(o));do {
          if ((a = Pi(t, i, n, e)) < s) {
            let l = o;s < l && (l = s), Ni(t, i, i + l, i + a, e), a = l;
          }r.pushRun(i, a), r.mergeRuns(), o -= a, i += a;
        } while (0 !== o);r.forceMergeRuns();
      }
    }
  } function Bi(t, e) {
    return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel;
  } function Vi() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }Vi.prototype = { constructor: Vi, traverse(t, e) {
    for (let i = 0;i < this._roots.length;i++) this._roots[i].traverse(t, e);
  }, getDisplayList(t, e) {
    return e = e || !1, t && this.updateDisplayList(e), this._displayList;
  }, updateDisplayList(t) {
    this._displayListLen = 0;for (var e = this._roots, i = this._displayList, n = 0, o = e.length;n < o;n++) this._updateAndAddDisplayable(e[n], null, t);i.length = this._displayListLen, v.canvasSupported && zi(i, Bi);
  }, _updateAndAddDisplayable(t, e, i) {
    if (!t.ignore || i) {
      t.beforeUpdate(), t.__dirty && t.update(), t.afterUpdate();const n = t.clipPath;if (n) {
        e = e ? e.slice() : [];for (let o = n, a = t;o;)o.parent = a, o.updateTransform(), e.push(o), o = (a = o).clipPath;
      } if (t.isGroup) {
        for (let r = t._children, s = 0;s < r.length;s++) {
          const l = r[s];t.__dirty && (l.__dirty = !0), this._updateAndAddDisplayable(l, e, i);
        }t.__dirty = !1;
      } else t.__clipPaths = e, this._displayList[this._displayListLen++] = t;
    }
  }, addRoot(t) {
    t.__storage !== this && (t instanceof Ci && t.addChildrenToStorage(this), this.addToStorage(t), this._roots.push(t));
  }, delRoot(t) {
    if (null == t) {
      for (var e = 0;e < this._roots.length;e++) {
        const i = this._roots[e];i instanceof Ci && i.delChildrenFromStorage(this);
      } return this._roots = [], this._displayList = [], void(this._displayListLen = 0);
    } if (t instanceof Array) {
      e = 0;for (let n = t.length;e < n;e++) this.delRoot(t[e]);
    } else {
      const o = _(this._roots, t);0 <= o && (this.delFromStorage(t), this._roots.splice(o, 1), t instanceof Ci && t.delChildrenFromStorage(this));
    }
  }, addToStorage(t) {
    return t && (t.__storage = this, t.dirty(!1)), this;
  }, delFromStorage(t) {
    return t && (t.__storage = null), this;
  }, dispose() {
    this._renderList = this._roots = null;
  }, displayableSortFunc: Bi };const Gi = { shadowBlur: 1, shadowOffsetX: 1, shadowOffsetY: 1, textShadowBlur: 1, textShadowOffsetX: 1, textShadowOffsetY: 1, textBoxShadowBlur: 1, textBoxShadowOffsetX: 1, textBoxShadowOffsetY: 1 }; const Fi = function (t, e, i) {
    return Gi.hasOwnProperty(e) ? i * t.dpr : i;
  }; const Wi = { NONE: 0, STYLE_BIND: 1, PLAIN_TEXT: 2 }; const Hi = 9; const Zi = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; const Ui = function (t) {
    this.extendFrom(t, !1);
  };function Xi(t, e, i) {
    let n = null == e.x ? 0 : e.x; let o = null == e.x2 ? 1 : e.x2; let a = null == e.y ? 0 : e.y; let r = null == e.y2 ? 0 : e.y2;return e.global || (n = n * i.width + i.x, o = o * i.width + i.x, a = a * i.height + i.y, r = r * i.height + i.y), n = isNaN(n) ? 0 : n, o = isNaN(o) ? 1 : o, a = isNaN(a) ? 0 : a, r = isNaN(r) ? 0 : r, t.createLinearGradient(n, a, o, r);
  } function Yi(t, e, i) {
    const n = i.width; const o = i.height; const a = Math.min(n, o); let r = null == e.x ? .5 : e.x; let s = null == e.y ? .5 : e.y; let l = null == e.r ? .5 : e.r;return e.global || (r = r * n + i.x, s = s * o + i.y, l *= a), t.createRadialGradient(r, s, 0, r, s, l);
  }Ui.prototype = { constructor: Ui, fill: '#000', stroke: null, opacity: 1, fillOpacity: null, strokeOpacity: null, lineDash: null, lineDashOffset: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, lineWidth: 1, strokeNoScale: !1, text: null, font: null, textFont: null, fontStyle: null, fontWeight: null, fontSize: null, fontFamily: null, textTag: null, textFill: '#000', textStroke: null, textWidth: null, textHeight: null, textStrokeWidth: 0, textLineHeight: null, textPosition: 'inside', textRect: null, textOffset: null, textAlign: null, textVerticalAlign: null, textDistance: 5, textShadowColor: 'transparent', textShadowBlur: 0, textShadowOffsetX: 0, textShadowOffsetY: 0, textBoxShadowColor: 'transparent', textBoxShadowBlur: 0, textBoxShadowOffsetX: 0, textBoxShadowOffsetY: 0, transformText: !1, textRotation: 0, textOrigin: null, textBackgroundColor: null, textBorderColor: null, textBorderWidth: 0, textBorderRadius: 0, textPadding: null, rich: null, truncate: null, blend: null, bind(t, e, i) {
    const n = this; const o = i && i.style; const a = !o || t.__attrCachedBy !== Wi.STYLE_BIND;t.__attrCachedBy = Wi.STYLE_BIND;for (let r = 0;r < Zi.length;r++) {
      const s = Zi[r]; const l = s[0];!a && n[l] === o[l] || (t[l] = Fi(t, l, n[l] || s[1]));
    } if (!a && n.fill === o.fill || (t.fillStyle = n.fill), !a && n.stroke === o.stroke || (t.strokeStyle = n.stroke), !a && n.opacity === o.opacity || (t.globalAlpha = null == n.opacity ? 1 : n.opacity), !a && n.blend === o.blend || (t.globalCompositeOperation = n.blend || 'source-over'), this.hasStroke()) {
      const u = n.lineWidth;t.lineWidth = u / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1);
    }
  }, hasFill() {
    const t = this.fill;return null != t && 'none' !== t;
  }, hasStroke() {
    const t = this.stroke;return null != t && 'none' !== t && 0 < this.lineWidth;
  }, extendFrom(t, e) {
    if (t) for (const i in t)!t.hasOwnProperty(i) || !0 !== e && (!1 === e ? this.hasOwnProperty(i) : null == t[i]) || (this[i] = t[i]);
  }, set(t, e) {
    'string' === typeof t ? this[t] = e : this.extendFrom(t, !0);
  }, clone() {
    const t = new this.constructor;return t.extendFrom(this, !0), t;
  }, getGradient(t, e, i) {
    for (var n = ('radial' === e.type ? Yi : Xi)(t, e, i), o = e.colorStops, a = 0;a < o.length;a++)n.addColorStop(o[a].offset, o[a].color);return n;
  } };for (var ji = Ui.prototype, qi = 0;qi < Zi.length;qi++) {
    const Ki = Zi[qi];Ki[0] in ji || (ji[Ki[0]] = Ki[1]);
  }Ui.getGradient = ji.getGradient;function $i(t, e) {
    this.image = t, this.repeat = e, this.type = 'pattern';
  } function Ji() {
    return !1;
  } function Qi(t, e, i) {
    const n = y(); const o = e.getWidth(); const a = e.getHeight(); const r = n.style;return r && (r.position = 'absolute', r.left = 0, r.top = 0, r.width = `${o}px`, r.height = `${a}px`, n.setAttribute('data-zr-dom-id', t)), n.width = o * i, n.height = a * i, n;
  } function tn(t, e, i) {
    let n;i = i || pi, 'string' === typeof t ? n = Qi(t, e, i) : z(t) && (t = (n = t).id), this.id = t;const o = (this.dom = n).style;o && (n.onselectstart = Ji, o['-webkit-user-select'] = 'none', o['user-select'] = 'none', o['-webkit-touch-callout'] = 'none', o['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)', o.padding = 0, o.margin = 0, o['border-width'] = 0), this.domBack = null, this.ctxBack = null, this.painter = e, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = i;
  }tn.prototype = { constructor: tn, __dirty: !0, __used: !($i.prototype.getCanvasPattern = function (t) {
    return t.createPattern(this.image, this.repeat || 'repeat');
  }), __drawIndex: 0, __startIndex: 0, __endIndex: 0, incremental: !1, getElementCount() {
    return this.__endIndex - this.__startIndex;
  }, initContext() {
    this.ctx = this.dom.getContext('2d'), this.ctx.dpr = this.dpr;
  }, createBackBuffer() {
    const t = this.dpr;this.domBack = Qi(`back-${this.id}`, this.painter, t), this.ctxBack = this.domBack.getContext('2d'), 1 !== t && this.ctxBack.scale(t, t);
  }, resize(t, e) {
    const i = this.dpr; const n = this.dom; const o = n.style; const a = this.domBack;o && (o.width = `${t}px`, o.height = `${e}px`), n.width = t * i, n.height = e * i, a && (a.width = t * i, a.height = e * i, 1 !== i && this.ctxBack.scale(i, i));
  }, clear(t, e) {
    let i; const n = this.dom; const o = this.ctx; const a = n.width; const r = n.height; const s = (e = e || this.clearColor, this.motionBlur && !t); const l = this.lastFrameAlpha; const u = this.dpr;s && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = 'copy', this.ctxBack.drawImage(n, 0, 0, a / u, r / u)), o.clearRect(0, 0, a, r), e && 'transparent' !== e && (e.colorStops ? (i = e.__canvasGradient || Ui.getGradient(o, e, { x: 0, y: 0, width: a, height: r }), e.__canvasGradient = i) : e.image && (i = $i.prototype.getCanvasPattern.call(e, o)), o.save(), o.fillStyle = i || e, o.fillRect(0, 0, a, r), o.restore());if (s) {
      const h = this.domBack;o.save(), o.globalAlpha = l, o.drawImage(h, 0, 0, a, r), o.restore();
    }
  } };const en = 'undefined' !== typeof window && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (t) {
    setTimeout(t, 16);
  }; const nn = new Te(50);function on(t) {
    if ('string' !== typeof t) return t;const e = nn.get(t);return e && e.image;
  } function an(t, e, i, n, o) {
    if (t) {
      if ('string' !== typeof t) return t;if (e && e.__zrImageSrc === t || !i) return e;const a = nn.get(t); const r = { hostEl: i, cb: n, cbPayload: o };return a ? sn(e = a.image) || a.pending.push(r) : ((e = new Image).onload = e.onerror = rn, nn.put(t, e.__cachedImgObj = { image: e, pending: [r] }), e.src = e.__zrImageSrc = t), e;
    } return e;
  } function rn() {
    const t = this.__cachedImgObj;this.onload = this.onerror = this.__cachedImgObj = null;for (let e = 0;e < t.pending.length;e++) {
      const i = t.pending[e]; const n = i.cb;n && n(this, i.cbPayload), i.hostEl.dirty();
    }t.pending.length = 0;
  } function sn(t) {
    return t && t.width && t.height;
  } let ln = {}; let un = 0; const hn = 5e3; const cn = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g; const dn = '12px sans-serif'; const fn = {};function pn(t, e) {
    const i = `${t}:${e = e || dn}`;if (ln[i]) return ln[i];for (var n, o, a = (`${t}`).split('\n'), r = 0, s = 0, l = a.length;s < l;s++)r = Math.max((n = a[s], o = e, fn.measureText(n, o)).width, r);return hn < un && (un = 0, ln = {}), un++, ln[i] = r;
  } function gn(t, e, i, n, o, a, r, s) {
    return r ? (function (t, e, i, n, o, a, r, s) {
      const l = In(t, { rich: r, truncate: s, font: e, textAlign: i, textPadding: o, textLineHeight: a }); const u = l.outerWidth; const h = l.outerHeight; const c = mn(0, u, i); const d = vn(0, h, n);return new Di(c, d, u, h);
    }(t, e, i, n, o, a, r, s)) : (function (t, e, i, n, o, a, r) {
      const s = Mn(t, e, o, a, r); let l = pn(t, e);o && (l += o[1] + o[3]);const u = s.outerHeight; const h = mn(0, l, i); const c = vn(0, u, n); const d = new Di(h, c, l, u);return d.lineHeight = s.lineHeight, d;
    }(t, e, i, n, o, a, s));
  } function mn(t, e, i) {
    return 'right' === i ? t -= e : 'center' === i && (t -= e / 2), t;
  } function vn(t, e, i) {
    return 'middle' === i ? t -= e / 2 : 'bottom' === i && (t -= e), t;
  } function yn(t, e, i) {
    const n = e.textPosition; let o = e.textDistance; let a = i.x; let r = i.y;o = o || 0;const s = i.height; const l = i.width; const u = s / 2; let h = 'left'; let c = 'top';switch (n) {
      case 'left':a -= o, r += u, h = 'right', c = 'middle';break;case 'right':a += o + l, r += u, c = 'middle';break;case 'top':a += l / 2, r -= o, h = 'center', c = 'bottom';break;case 'bottom':a += l / 2, r += s + o, h = 'center';break;case 'inside':a += l / 2, r += u, h = 'center', c = 'middle';break;case 'insideLeft':a += o, r += u, c = 'middle';break;case 'insideRight':a += l - o, r += u, h = 'right', c = 'middle';break;case 'insideTop':a += l / 2, r += o, h = 'center';break;case 'insideBottom':a += l / 2, r += s - o, h = 'center', c = 'bottom';break;case 'insideTopLeft':a += o, r += o;break;case 'insideTopRight':a += l - o, r += o, h = 'right';break;case 'insideBottomLeft':a += o, r += s - o, c = 'bottom';break;case 'insideBottomRight':a += l - o, r += s - o, h = 'right', c = 'bottom';
    } return (t = t || {}).x = a, t.y = r, t.textAlign = h, t.textVerticalAlign = c, t;
  } function xn(t, e, i, n, o) {
    if (!e) return '';const a = (`${t}`).split('\n');o = _n(e, i, n, o);for (let r = 0, s = a.length;r < s;r++)a[r] = wn(a[r], o);return a.join('\n');
  } function _n(t, e, i, n) {
    (n = P({}, n)).font = e;i = H(i, '...');n.maxIterations = H(n.maxIterations, 2);const o = n.minChar = H(n.minChar, 0);n.cnCharWidth = pn('国', e);const a = n.ascCharWidth = pn('a', e);n.placeholder = H(n.placeholder, '');for (var r = t = Math.max(0, t - 1), s = 0;s < o && a <= r;s++)r -= a;let l = pn(i, e);return r < l && (i = '', l = 0), r = t - l, n.ellipsis = i, n.ellipsisWidth = l, n.contentWidth = r, n.containerWidth = t, n;
  } function wn(t, e) {
    const i = e.containerWidth; const n = e.font; const o = e.contentWidth;if (!i) return '';let a = pn(t, n);if (a <= i) return t;for (let r = 0;;r++) {
      if (a <= o || r >= e.maxIterations) {
        t += e.ellipsis;break;
      } const s = 0 === r ? bn(t, o, e.ascCharWidth, e.cnCharWidth) : 0 < a ? Math.floor(t.length * o / a) : 0;a = pn(t = t.substr(0, s), n);
    } return '' === t && (t = e.placeholder), t;
  } function bn(t, e, i, n) {
    for (var o = 0, a = 0, r = t.length;a < r && o < e;a++) {
      const s = t.charCodeAt(a);o += 0 <= s && s <= 127 ? i : n;
    } return a;
  } function Sn(t) {
    return pn('国', t);
  } function Mn(t, e, i, n, o) {
    null != t && (t += '');const a = H(n, Sn(e)); let r = t ? t.split('\n') : []; const s = r.length * a; let l = s; let u = !0;if (i && (l += i[0] + i[2]), t && o) {
      u = !1;const h = o.outerHeight; const c = o.outerWidth;if (null != h && h < l)t = '', r = [];else if (null != c) for (let d = _n(c - (i ? i[1] + i[3] : 0), e, o.ellipsis, { minChar: o.minChar, placeholder: o.placeholder }), f = 0, p = r.length;f < p;f++)r[f] = wn(r[f], d);
    } return { lines: r, height: s, outerHeight: l, lineHeight: a, canCacheByTextString: u };
  } function In(t, e) {
    const i = { lines: [], width: 0, height: 0 };if (null != t && (t += ''), !t) return i;for (var n, o = cn.lastIndex = 0;null != (n = cn.exec(t));) {
      const a = n.index;o < a && Tn(i, t.substring(o, a)), Tn(i, n[2], n[1]), o = cn.lastIndex;
    }o < t.length && Tn(i, t.substring(o, t.length));const r = i.lines; let s = 0; let l = 0; const u = []; const h = e.textPadding; const c = e.truncate; let d = c && c.outerWidth; let f = c && c.outerHeight;h && (null != d && (d -= h[1] + h[3]), null != f && (f -= h[0] + h[2]));for (var p = 0;p < r.length;p++) {
      for (var g = r[p], m = 0, v = 0, y = 0;y < g.tokens.length;y++) {
        const x = (C = g.tokens[y]).styleName && e.rich[C.styleName] || {}; const _ = C.textPadding = x.textPadding; const w = C.font = x.font || e.font; let b = C.textHeight = H(x.textHeight, Sn(w));if (_ && (b += _[0] + _[2]), C.height = b, C.lineHeight = Z(x.textLineHeight, e.textLineHeight, b), C.textAlign = x && x.textAlign || e.textAlign, C.textVerticalAlign = x && x.textVerticalAlign || 'middle', null != f && s + C.lineHeight > f) return { lines: [], width: 0, height: 0 };C.textWidth = pn(C.text, w);let S = x.textWidth; const M = null == S || 'auto' === S;if ('string' === typeof S && '%' === S.charAt(S.length - 1))C.percentWidth = S, u.push(C), S = 0;else {
          if (M) {
            S = C.textWidth;const I = x.textBackgroundColor; let T = I && I.image;T && sn(T = on(T)) && (S = Math.max(S, T.width * b / T.height));
          } const A = _ ? _[1] + _[3] : 0;S += A;const D = null != d ? d - v : null;null != D && D < S && (!M || D < A ? (C.text = '', C.textWidth = S = 0) : (C.text = xn(C.text, D - A, w, c.ellipsis, { minChar: c.minChar }), C.textWidth = pn(C.text, w), S = C.textWidth + A));
        }v += C.width = S, x && (m = Math.max(m, C.lineHeight));
      }g.width = v, s += g.lineHeight = m, l = Math.max(l, v);
    }i.outerWidth = i.width = H(e.textWidth, l), i.outerHeight = i.height = H(e.textHeight, s), h && (i.outerWidth += h[1] + h[3], i.outerHeight += h[0] + h[2]);for (p = 0;p < u.length;p++) {
      var C; const L = (C = u[p]).percentWidth;C.width = parseInt(L, 10) / 100 * l;
    } return i;
  } function Tn(t, e, i) {
    for (let n = '' === e, o = e.split('\n'), a = t.lines, r = 0;r < o.length;r++) {
      const s = o[r]; const l = { styleName: i, text: s, isLineHolder: !s && !n };if (r)a.push({ tokens: [l] });else {
        const u = (a[a.length - 1] || (a[0] = { tokens: [] })).tokens; const h = u.length;1 === h && u[0].isLineHolder ? u[0] = l : !s && h && !n || u.push(l);
      }
    }
  } function An(t) {
    const e = (t.fontSize || t.fontFamily) && [t.fontStyle, t.fontWeight, `${t.fontSize || 12}px`, t.fontFamily || 'sans-serif'].join(' ');return e && j(e) || t.textFont || t.font;
  } function Dn(t, e) {
    let i; let n; let o; let a; let r; let s = e.x; let l = e.y; let u = e.width; let h = e.height; const c = e.r;u < 0 && (s += u, u = -u), h < 0 && (l += h, h = -h), 'number' === typeof c ? i = n = o = a = c : c instanceof Array ? 1 === c.length ? i = n = o = a = c[0] : 2 === c.length ? (i = o = c[0], n = a = c[1]) : 3 === c.length ? (i = c[0], n = a = c[1], o = c[2]) : (i = c[0], n = c[1], o = c[2], a = c[3]) : i = n = o = a = 0, u < i + n && (i *= u / (r = i + n), n *= u / r), u < o + a && (o *= u / (r = o + a), a *= u / r), h < n + o && (n *= h / (r = n + o), o *= h / r), h < i + a && (i *= h / (r = i + a), a *= h / r), t.moveTo(s + i, l), t.lineTo(s + u - n, l), 0 !== n && t.arc(s + u - n, l + n, n, -Math.PI / 2, 0), t.lineTo(s + u, l + h - o), 0 !== o && t.arc(s + u - o, l + h - o, o, 0, Math.PI / 2), t.lineTo(s + a, l + h), 0 !== a && t.arc(s + a, l + h - a, a, Math.PI / 2, Math.PI), t.lineTo(s, l + i), 0 !== i && t.arc(s + i, l + i, i, Math.PI, 1.5 * Math.PI);
  }fn.measureText = function (t, e) {
    const i = x();return i.font = e || dn, i.measureText(t);
  };const Cn = dn; const Ln = { left: 1, right: 1, center: 1 }; const kn = { top: 1, bottom: 1, middle: 1 }; const Pn = [['textShadowBlur', 'shadowBlur', 0], ['textShadowOffsetX', 'shadowOffsetX', 0], ['textShadowOffsetY', 'shadowOffsetY', 0], ['textShadowColor', 'shadowColor', 'transparent']]; const Nn = {}; const On = {};function Rn(t) {
    return En(t), R(t.rich, En), t;
  } function En(t) {
    if (t) {
      t.font = An(t);let e = t.textAlign;'middle' === e && (e = 'center'), t.textAlign = null == e || Ln[e] ? e : 'left';let i = t.textVerticalAlign || t.textBaseline;'center' === i && (i = 'middle'), t.textVerticalAlign = null == i || kn[i] ? i : 'top', t.textPadding && (t.textPadding = X(t.textPadding));
    }
  } function zn(t, e, i, n, o, a) {
    n.rich ? (function (t, e, i, n, o, a) {
      a !== Hi && (e.__attrCachedBy = Wi.NONE);let r = t.__textCotentBlock;r && !t.__dirtyText || (r = t.__textCotentBlock = In(i, n));!(function (t, e, i, n, o) {
        const a = i.width; const r = i.outerWidth; const s = i.outerHeight; const l = n.textPadding; const u = Hn(On, t, n, o); const h = u.baseX; const c = u.baseY; const d = u.textAlign; const f = u.textVerticalAlign;Bn(e, n, o, h, c);const p = mn(h, r, d); const g = vn(c, s, f); let m = p; let v = g;l && (m += l[3], v += l[0]);const y = m + a;Gn(n) && Fn(t, e, n, p, g, r, s);for (let x = 0;x < i.lines.length;x++) {
          for (var _, w = i.lines[x], b = w.tokens, S = b.length, M = w.lineHeight, I = w.width, T = 0, A = m, D = y, C = S - 1;T < S && (!(_ = b[T]).textAlign || 'left' === _.textAlign);)Vn(t, e, _, n, M, v, A, 'left'), I -= _.width, A += _.width, T++;for (;0 <= C && 'right' === (_ = b[C]).textAlign;)Vn(t, e, _, n, M, v, D, 'right'), I -= _.width, D -= _.width, C--;for (A += (a - (A - m) - (y - D) - I) / 2;T <= C;)_ = b[T], Vn(t, e, _, n, M, v, A + _.width / 2, 'center'), A += _.width, T++;v += M;
        }
      }(t, e, r, n, o));
    }(t, e, i, n, o, a)) : (function (t, e, i, n, o, a) {
      let r; const s = Gn(n); let l = !1; const u = e.__attrCachedBy === Wi.PLAIN_TEXT;a !== Hi ? (a && (r = a.style, l = !s && u && r), e.__attrCachedBy = s ? Wi.NONE : Wi.PLAIN_TEXT) : u && (e.__attrCachedBy = Wi.NONE);const h = n.font || Cn;l && h === (r.font || Cn) || (e.font = h);let c = t.__computedFont;t.__styleFont !== h && (t.__styleFont = h, c = t.__computedFont = e.font);const d = n.textPadding; const f = n.textLineHeight; let p = t.__textCotentBlock;p && !t.__dirtyText || (p = t.__textCotentBlock = Mn(i, c, d, f, n.truncate));const g = p.outerHeight; const m = p.lines; const v = p.lineHeight; const y = Hn(On, t, n, o); const x = y.baseX; const _ = y.baseY; const w = y.textAlign || 'left'; const b = y.textVerticalAlign;Bn(e, n, o, x, _);const S = vn(_, g, b); let M = x; let I = S;if (s || d) {
        let T = pn(i, c);d && (T += d[1] + d[3]);const A = mn(x, T, w);s && Fn(t, e, n, A, S, T, g), d && (M = jn(x, w, d), I += d[0]);
      }e.textAlign = w, e.textBaseline = 'middle', e.globalAlpha = n.opacity || 1;for (var D = 0;D < Pn.length;D++) {
        const C = Pn[D]; const L = C[0]; const k = C[1]; const P = n[L];l && P === r[L] || (e[k] = Fi(e, k, P || C[2]));
      }I += v / 2;const N = n.textStrokeWidth; const O = l ? r.textStrokeWidth : null; const R = !l || N !== O; const E = !l || R || n.textStroke !== r.textStroke; const z = Un(n.textStroke, N); const B = Xn(n.textFill);z && (R && (e.lineWidth = N), E && (e.strokeStyle = z));B && (l && n.textFill === r.textFill || (e.fillStyle = B));if (1 === m.length)z && e.strokeText(m[0], M, I), B && e.fillText(m[0], M, I);else for (D = 0;D < m.length;D++)z && e.strokeText(m[D], M, I), B && e.fillText(m[D], M, I), I += v;
    }(t, e, i, n, o, a));
  } function Bn(t, e, i, n, o) {
    if (i && e.textRotation) {
      const a = e.textOrigin;'center' === a ? (n = i.width / 2 + i.x, o = i.height / 2 + i.y) : a && (n = a[0] + i.x, o = a[1] + i.y), t.translate(n, o), t.rotate(-e.textRotation), t.translate(-n, -o);
    }
  } function Vn(t, e, i, n, o, a, r, s) {
    const l = n.rich[i.styleName] || {};l.text = i.text;const u = i.textVerticalAlign; let h = a + o / 2;'top' === u ? h = a + i.height / 2 : 'bottom' === u && (h = a + o - i.height / 2), !i.isLineHolder && Gn(l) && Fn(t, e, l, 'right' === s ? r - i.width : 'center' === s ? r - i.width / 2 : r, h - i.height / 2, i.width, i.height);const c = i.textPadding;c && (r = jn(r, s, c), h -= i.height / 2 - c[2] - i.textHeight / 2), Zn(e, 'shadowBlur', Z(l.textShadowBlur, n.textShadowBlur, 0)), Zn(e, 'shadowColor', l.textShadowColor || n.textShadowColor || 'transparent'), Zn(e, 'shadowOffsetX', Z(l.textShadowOffsetX, n.textShadowOffsetX, 0)), Zn(e, 'shadowOffsetY', Z(l.textShadowOffsetY, n.textShadowOffsetY, 0)), Zn(e, 'textAlign', s), Zn(e, 'textBaseline', 'middle'), Zn(e, 'font', i.font || Cn);const d = Un(l.textStroke || n.textStroke, p); const f = Xn(l.textFill || n.textFill); var p = H(l.textStrokeWidth, n.textStrokeWidth);d && (Zn(e, 'lineWidth', p), Zn(e, 'strokeStyle', d), e.strokeText(i.text, r, h)), f && (Zn(e, 'fillStyle', f), e.fillText(i.text, r, h));
  } function Gn(t) {
    return !!(t.textBackgroundColor || t.textBorderWidth && t.textBorderColor);
  } function Fn(t, e, i, n, o, a, r) {
    const s = i.textBackgroundColor; const l = i.textBorderWidth; const u = i.textBorderColor; const h = E(s);if (Zn(e, 'shadowBlur', i.textBoxShadowBlur || 0), Zn(e, 'shadowColor', i.textBoxShadowColor || 'transparent'), Zn(e, 'shadowOffsetX', i.textBoxShadowOffsetX || 0), Zn(e, 'shadowOffsetY', i.textBoxShadowOffsetY || 0), h || l && u) {
      e.beginPath();const c = i.textBorderRadius;c ? Dn(e, { x: n, y: o, width: a, height: r, r: c }) : e.rect(n, o, a, r), e.closePath();
    } if (h) if (Zn(e, 'fillStyle', s), null != i.fillOpacity) {
      var d = e.globalAlpha;e.globalAlpha = i.fillOpacity * i.opacity, e.fill(), e.globalAlpha = d;
    } else e.fill();else if (z(s)) {
      let f = s.image;(f = an(f, null, t, Wn, s)) && sn(f) && e.drawImage(f, n, o, a, r);
    } if (l && u) if (Zn(e, 'lineWidth', l), Zn(e, 'strokeStyle', u), null != i.strokeOpacity) {
      d = e.globalAlpha;e.globalAlpha = i.strokeOpacity * i.opacity, e.stroke(), e.globalAlpha = d;
    } else e.stroke();
  } function Wn(t, e) {
    e.image = t;
  } function Hn(t, e, i, n) {
    let o = i.x || 0; let a = i.y || 0; let r = i.textAlign; let s = i.textVerticalAlign;if (n) {
      const l = i.textPosition;if (l instanceof Array)o = n.x + Yn(l[0], n.width), a = n.y + Yn(l[1], n.height);else {
        const u = e && e.calculateTextPosition ? e.calculateTextPosition(Nn, i, n) : yn(Nn, i, n);o = u.x, a = u.y, r = r || u.textAlign, s = s || u.textVerticalAlign;
      } const h = i.textOffset;h && (o += h[0], a += h[1]);
    } return (t = t || {}).baseX = o, t.baseY = a, t.textAlign = r, t.textVerticalAlign = s, t;
  } function Zn(t, e, i) {
    return t[e] = Fi(t, e, i), t[e];
  } function Un(t, e) {
    return null == t || e <= 0 || 'transparent' === t || 'none' === t ? null : t.image || t.colorStops ? '#000' : t;
  } function Xn(t) {
    return null == t || 'none' === t ? null : t.image || t.colorStops ? '#000' : t;
  } function Yn(t, e) {
    return 'string' === typeof t ? 0 <= t.lastIndexOf('%') ? parseFloat(t) / 100 * e : parseFloat(t) : t;
  } function jn(t, e, i) {
    return 'right' === e ? t - i[1] : 'center' === e ? t + i[3] / 2 - i[1] / 2 : t + i[3];
  } function qn(t, e) {
    return null != t && (t || e.textBackgroundColor || e.textBorderWidth && e.textBorderColor || e.textPadding);
  } function Kn() {} const $n = new Di;function Jn(t) {
    for (const e in t = t || {}, _i.call(this, t), t)t.hasOwnProperty(e) && 'style' !== e && (this[e] = t[e]);this.style = new Ui(t.style, this), this._rect = null, this.__clipPaths = null;
  } function Qn(t) {
    Jn.call(this, t);
  }Jn.prototype = { constructor: Jn, type: 'displayable', __dirty: !0, invisible: !(Kn.prototype = { constructor: Kn, drawRectText(t, e) {
    const i = this.style;e = i.textRect || e, this.__dirty && Rn(i);let n = i.text;if (null != n && (n += ''), qn(n, i)) {
      t.save();const o = this.transform;i.transformText ? this.setTransform(t) : o && ($n.copy(e), $n.applyTransform(o), e = $n), zn(this, t, n, i, e, Hi), t.restore();
    }
  } }), z: 0, z2: 0, zlevel: 0, draggable: !1, dragging: !1, silent: !1, culling: !1, cursor: 'pointer', rectHover: !1, progressive: !1, incremental: !1, globalScaleRatio: 1, beforeBrush(t) {}, afterBrush(t) {}, brush(t, e) {}, getBoundingRect() {}, contain(t, e) {
    return this.rectContain(t, e);
  }, traverse(t, e) {
    t.call(e, this);
  }, rectContain(t, e) {
    const i = this.transformCoordToLocal(t, e);return this.getBoundingRect().contain(i[0], i[1]);
  }, dirty() {
    this.__dirty = this.__dirtyText = !0, this._rect = null, this.__zr && this.__zr.refresh();
  }, animateStyle(t) {
    return this.animate('style', t);
  }, attrKV(t, e) {
    'style' !== t ? _i.prototype.attrKV.call(this, t, e) : this.style.set(e);
  }, setStyle(t, e) {
    return this.style.set(t, e), this.dirty(!1), this;
  }, useStyle(t) {
    return this.style = new Ui(t, this), this.dirty(!1), this;
  }, calculateTextPosition: null }, w(Jn, _i), b(Jn, Kn), Qn.prototype = { constructor: Qn, type: 'image', brush(t, e) {
    const i = this.style; const n = i.image;i.bind(t, this, e);const o = this._image = an(n, this._image, this, this.onload);if (o && sn(o)) {
      const a = i.x || 0; const r = i.y || 0; let s = i.width; let l = i.height; const u = o.width / o.height;if (null == s && null != l ? s = l * u : null == l && null != s ? l = s / u : null == s && null == l && (s = o.width, l = o.height), this.setTransform(t), i.sWidth && i.sHeight) {
        var h = i.sx || 0; var c = i.sy || 0;t.drawImage(o, h, c, i.sWidth, i.sHeight, a, r, s, l);
      } else if (i.sx && i.sy) {
        const d = s - (h = i.sx); const f = l - (c = i.sy);t.drawImage(o, h, c, d, f, a, r, s, l);
      } else t.drawImage(o, a, r, s, l);null != i.text && (this.restoreTransform(t), this.drawRectText(t, this.getBoundingRect()));
    }
  }, getBoundingRect() {
    const t = this.style;return this._rect || (this._rect = new Di(t.x || 0, t.y || 0, t.width || 0, t.height || 0)), this._rect;
  } }, w(Qn, Jn);const to = 314159;function eo(t) {
    return parseInt(t, 10);
  } const io = new Di(0, 0, 0, 0); const no = new Di(0, 0, 0, 0);function oo(t, e, i) {
    this.type = 'canvas';const n = !t.nodeName || 'CANVAS' === t.nodeName.toUpperCase();this._opts = i = P({}, i || {}), this.dpr = i.devicePixelRatio || pi, this._singleCanvas = n;const o = (this.root = t).style;o && (o['-webkit-tap-highlight-color'] = 'transparent', o['-webkit-user-select'] = o['user-select'] = o['-webkit-touch-callout'] = 'none', t.innerHTML = ''), this.storage = e;const a = this._zlevelList = []; const r = this._layers = {};if (this._layerConfig = {}, this._needsManuallyCompositing = !1, n) {
      let s = t.width; let l = t.height;null != i.width && (s = i.width), null != i.height && (l = i.height), this.dpr = i.devicePixelRatio || 1, t.width = s * this.dpr, t.height = l * this.dpr, this._width = s, this._height = l;const u = new tn(t, this, this.dpr);u.__builtin__ = !0, u.initContext(), (r[to] = u).zlevel = to, a.push(to), this._domRoot = t;
    } else {
      this._width = this._getSize(0), this._height = this._getSize(1);const h = this._domRoot = (function (t, e) {
        const i = document.createElement('div');return i.style.cssText = `${['position:relative', `width:${t}px`, `height:${e}px`, 'padding:0', 'margin:0', 'border-width:0'].join(';')};`, i;
      }(this._width, this._height));t.appendChild(h);
    } this._hoverlayer = null, this._hoverElements = [];
  }oo.prototype = { constructor: oo, getType() {
    return 'canvas';
  }, isSingleCanvas() {
    return this._singleCanvas;
  }, getViewportRoot() {
    return this._domRoot;
  }, getViewportRootOffset() {
    const t = this.getViewportRoot();if (t) return { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 };
  }, refresh(t) {
    const e = this.storage.getDisplayList(!0); const i = this._zlevelList;this._redrawId = Math.random(), this._paintList(e, t, this._redrawId);for (let n = 0;n < i.length;n++) {
      const o = i[n]; const a = this._layers[o];if (!a.__builtin__ && a.refresh) {
        const r = 0 === n ? this._backgroundColor : null;a.refresh(r);
      }
    } return this.refreshHover(), this;
  }, addHover(t, e) {
    if (!t.__hoverMir) {
      const i = new t.constructor({ style: t.style, shape: t.shape, z: t.z, z2: t.z2, silent: t.silent });return (i.__from = t).__hoverMir = i, e && i.setStyle(e), this._hoverElements.push(i), i;
    }
  }, removeHover(t) {
    const e = t.__hoverMir; const i = this._hoverElements; const n = _(i, e);0 <= n && i.splice(n, 1), t.__hoverMir = null;
  }, clearHover(t) {
    for (var e = this._hoverElements, i = 0;i < e.length;i++) {
      const n = e[i].__from;n && (n.__hoverMir = null);
    }e.length = 0;
  }, refreshHover() {
    const t = this._hoverElements; let e = t.length; let i = this._hoverlayer;if (i && i.clear(), e) {
      zi(t, this.storage.displayableSortFunc);const n = {};(i = i || (this._hoverlayer = this.getLayer(1e5))).ctx.save();for (let o = 0;o < e;) {
        const a = t[o]; const r = a.__from;r && r.__zr ? (o++, r.invisible || (a.transform = r.transform, a.invTransform = r.invTransform, a.__clipPaths = r.__clipPaths, this._doPaintEl(a, i, !0, n))) : (t.splice(o, 1), r.__hoverMir = null, e--);
      }i.ctx.restore();
    }
  }, getHoverLayer() {
    return this.getLayer(1e5);
  }, _paintList(t, e, i) {
    if (this._redrawId === i) {
      e = e || !1, this._updateLayerStatus(t);const n = this._doPaintList(t, e);if (this._needsManuallyCompositing && this._compositeManually(), !n) {
        const o = this;en(() => {
          o._paintList(t, e, i);
        });
      }
    }
  }, _compositeManually() {
    const e = this.getLayer(to).ctx; const i = this._domRoot.width; const n = this._domRoot.height;e.clearRect(0, 0, i, n), this.eachBuiltinLayer((t) => {
      t.virtual && e.drawImage(t.dom, 0, 0, i, n);
    });
  }, _doPaintList(t, e) {
    for (var i = [], n = 0;n < this._zlevelList.length;n++) {
      const o = this._zlevelList[n];(s = this._layers[o]).__builtin__ && s !== this._hoverlayer && (s.__dirty || e) && i.push(s);
    } for (var a = !0, r = 0;r < i.length;r++) {
      var s; const l = (s = i[r]).ctx; const u = {};l.save();let h = e ? s.__startIndex : s.__drawIndex; const c = !e && s.incremental && Date.now; const d = c && Date.now(); const f = s.zlevel === this._zlevelList[0] ? this._backgroundColor : null;if (s.__startIndex === s.__endIndex)s.clear(!1, f);else if (h === s.__startIndex) {
        const p = t[h];p.incremental && p.notClear && !e || s.clear(!1, f);
      }-1 === h && (console.error('For some unknown reason. drawIndex is -1'), h = s.__startIndex);for (var g = h;g < s.__endIndex;g++) {
        const m = t[g];if (this._doPaintEl(m, s, e, u), m.__dirty = m.__dirtyText = !1, c) if (15 < Date.now() - d) break;
      }s.__drawIndex = g, s.__drawIndex < s.__endIndex && (a = !1), u.prevElClipPaths && l.restore(), l.restore();
    } return v.wxa && R(this._layers, (t) => {
      t && t.ctx && t.ctx.draw && t.ctx.draw();
    }), a;
  }, _doPaintEl(t, e, i, n) {
    const o = e.ctx; const a = t.transform;if ((e.__dirty || i) && !t.invisible && 0 !== t.style.opacity && (!a || a[0] || a[3]) && (!t.culling || !(function (t, e, i) {
      return io.copy(t.getBoundingRect()), t.transform && io.applyTransform(t.transform), no.width = e, no.height = i, !io.intersect(no);
    }(t, this._width, this._height)))) {
      const r = t.__clipPaths; const s = n.prevElClipPaths;s && !(function (t, e) {
        if (t === e) return !1;if (!t || !e || t.length !== e.length) return !0;for (let i = 0;i < t.length;i++) if (t[i] !== e[i]) return !0;return !1;
      }(r, s)) || (s && (o.restore(), n.prevElClipPaths = null, n.prevEl = null), r && (o.save(), (function (t, e) {
        for (let i = 0;i < t.length;i++) {
          const n = t[i];n.setTransform(e), e.beginPath(), n.buildPath(e, n.shape), e.clip(), n.restoreTransform(e);
        }
      }(r, o)), n.prevElClipPaths = r)), t.beforeBrush && t.beforeBrush(o), t.brush(o, n.prevEl || null), (n.prevEl = t).afterBrush && t.afterBrush(o);
    }
  }, getLayer(t, e) {
    this._singleCanvas && !this._needsManuallyCompositing && (t = to);let i = this._layers[t];return i || ((i = new tn(`zr_${t}`, this, this.dpr)).zlevel = t, i.__builtin__ = !0, this._layerConfig[t] ? m(i, this._layerConfig[t], !0) : this._layerConfig[t - .01] && m(i, this._layerConfig[t - .01], !0), e && (i.virtual = e), this.insertLayer(t, i), i.initContext()), i;
  }, insertLayer(t, e) {
    const i = this._layers; const n = this._zlevelList; const o = n.length; let a = null; let r = -1; const s = this._domRoot;if (i[t])vi(`ZLevel ${t} has been used already`);else if (function (t) {
      return !!t && (!!t.__builtin__ || 'function' === typeof t.resize && 'function' === typeof t.refresh);
    }(e)) {
      if (0 < o && t > n[0]) {
        for (r = 0;r < o - 1 && !(n[r] < t && n[r + 1] > t);r++);a = i[n[r]];
      } if (n.splice(r + 1, 0, t), !(i[t] = e).virtual) if (a) {
        const l = a.dom;l.nextSibling ? s.insertBefore(e.dom, l.nextSibling) : s.appendChild(e.dom);
      } else s.firstChild ? s.insertBefore(e.dom, s.firstChild) : s.appendChild(e.dom);
    } else vi(`Layer of zlevel ${t} is not valid`);
  }, eachLayer(t, e) {
    let i; let n; const o = this._zlevelList;for (n = 0;n < o.length;n++)i = o[n], t.call(e, this._layers[i], i);
  }, eachBuiltinLayer(t, e) {
    let i; let n; let o; const a = this._zlevelList;for (o = 0;o < a.length;o++)n = a[o], (i = this._layers[n]).__builtin__ && t.call(e, i, n);
  }, eachOtherLayer(t, e) {
    let i; let n; let o; const a = this._zlevelList;for (o = 0;o < a.length;o++)n = a[o], (i = this._layers[n]).__builtin__ || t.call(e, i, n);
  }, getLayers() {
    return this._layers;
  }, _updateLayerStatus(t) {
    function e(t) {
      o && (o.__endIndex !== t && (o.__dirty = !0), o.__endIndex = t);
    } if (this.eachBuiltinLayer((t, e) => {
      t.__dirty = t.__used = !1;
    }), this._singleCanvas) for (var i = 1;i < t.length;i++) {
      if ((r = t[i]).zlevel !== t[i - 1].zlevel || r.incremental) {
        this._needsManuallyCompositing = !0;break;
      }
    } let n; var o = null; let a = 0;for (i = 0;i < t.length;i++) {
      var r; var s; const l = (r = t[i]).zlevel;n !== l && (n = l, a = 0), r.incremental ? ((s = this.getLayer(l + .001, this._needsManuallyCompositing)).incremental = !0, a = 1) : s = this.getLayer(l + (0 < a ? .01 : 0), this._needsManuallyCompositing), s.__builtin__ || vi(`ZLevel ${l} has been used by unkown layer ${s.id}`), s !== o && (s.__used = !0, s.__startIndex !== i && (s.__dirty = !0), s.__startIndex = i, s.incremental ? s.__drawIndex = -1 : s.__drawIndex = i, e(i), o = s), r.__dirty && (s.__dirty = !0, s.incremental && s.__drawIndex < 0 && (s.__drawIndex = i));
    }e(i), this.eachBuiltinLayer((t, e) => {
      !t.__used && 0 < t.getElementCount() && (t.__dirty = !0, t.__startIndex = t.__endIndex = t.__drawIndex = 0), t.__dirty && t.__drawIndex < 0 && (t.__drawIndex = t.__startIndex);
    });
  }, clear() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, _clearLayer(t) {
    t.clear();
  }, setBackgroundColor(t) {
    this._backgroundColor = t;
  }, configLayer(t, e) {
    if (e) {
      const i = this._layerConfig;i[t] ? m(i[t], e, !0) : i[t] = e;for (let n = 0;n < this._zlevelList.length;n++) {
        const o = this._zlevelList[n];if (o === t || o === t + .01)m(this._layers[o], i[t], !0);
      }
    }
  }, delLayer(t) {
    const e = this._layers; const i = this._zlevelList; const n = e[t];n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i.splice(_(i, t), 1));
  }, resize(e, i) {
    if (this._domRoot.style) {
      const t = this._domRoot;t.style.display = 'none';const n = this._opts;if (null != e && (n.width = e), null != i && (n.height = i), e = this._getSize(0), i = this._getSize(1), t.style.display = '', this._width !== e || i !== this._height) {
        for (const o in t.style.width = `${e}px`, t.style.height = `${i}px`, this._layers) this._layers.hasOwnProperty(o) && this._layers[o].resize(e, i);R(this._progressiveLayers, (t) => {
          t.resize(e, i);
        }), this.refresh(!0);
      } this._width = e, this._height = i;
    } else {
      if (null == e || null == i) return;this._width = e, this._height = i, this.getLayer(to).resize(e, i);
    } return this;
  }, clearLayer(t) {
    const e = this._layers[t];e && e.clear();
  }, dispose() {
    this.root.innerHTML = '', this.root = this.storage = this._domRoot = this._layers = null;
  }, getRenderedCanvas(t) {
    if (t = t || {}, this._singleCanvas && !this._compositeManually) return this._layers[to].dom;const e = new tn('image', this, t.pixelRatio || this.dpr);if (e.initContext(), e.clear(!1, t.backgroundColor || this._backgroundColor), t.pixelRatio <= this.dpr) {
      this.refresh();const i = e.dom.width; const n = e.dom.height; const o = e.ctx;this.eachLayer((t) => {
        t.__builtin__ ? o.drawImage(t.dom, 0, 0, i, n) : t.renderToCanvas && (e.ctx.save(), t.renderToCanvas(e.ctx), e.ctx.restore());
      });
    } else for (let a = {}, r = this.storage.getDisplayList(!0), s = 0;s < r.length;s++) {
      const l = r[s];this._doPaintEl(l, e, !0, a);
    } return e.dom;
  }, getWidth() {
    return this._width;
  }, getHeight() {
    return this._height;
  }, _getSize(t) {
    const e = this._opts; const i = ['width', 'height'][t]; const n = ['clientWidth', 'clientHeight'][t]; const o = ['paddingLeft', 'paddingTop'][t]; const a = ['paddingRight', 'paddingBottom'][t];if (null != e[i] && 'auto' !== e[i]) return parseFloat(e[i]);const r = this.root; const s = document.defaultView.getComputedStyle(r);return (r[n] || eo(s[i]) || eo(r.style[i])) - (eo(s[o]) || 0) - (eo(s[a]) || 0) | 0;
  }, pathToImage(t, e) {
    e = e || this.dpr;const i = document.createElement('canvas'); const n = i.getContext('2d'); const o = t.getBoundingRect(); const a = t.style; const r = a.shadowBlur * e; const s = a.shadowOffsetX * e; const l = a.shadowOffsetY * e; const u = a.hasStroke() ? a.lineWidth : 0; const h = Math.max(u / 2, r - s); const c = Math.max(u / 2, s + r); const d = Math.max(u / 2, r - l); const f = Math.max(u / 2, l + r); const p = o.width + h + c; const g = o.height + d + f;i.width = p * e, i.height = g * e, n.scale(e, e), n.clearRect(0, 0, p, g), n.dpr = e;const m = { position: t.position, rotation: t.rotation, scale: t.scale };t.position = [h - o.x, d - o.y], t.rotation = 0, t.scale = [1, 1], t.updateTransform(), t && t.brush(n);const v = new Qn({ style: { x: 0, y: 0, image: i } });return null != m.position && (v.position = t.position = m.position), null != m.rotation && (v.rotation = t.rotation = m.rotation), null != m.scale && (v.scale = t.scale = m.scale), v;
  } };function ao(t) {
    t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function () {}, this._clips = [], this._running = !1, this._time, this._pausedTime, this._pauseStart, this._paused = !1, Ct.call(this);
  }ao.prototype = { constructor: ao, addClip(t) {
    this._clips.push(t);
  }, addAnimator(t) {
    t.animation = this;for (let e = t.getClips(), i = 0;i < e.length;i++) this.addClip(e[i]);
  }, removeClip(t) {
    const e = _(this._clips, t);0 <= e && this._clips.splice(e, 1);
  }, removeAnimator(t) {
    for (let e = t.getClips(), i = 0;i < e.length;i++) this.removeClip(e[i]);t.animation = null;
  }, _update() {
    for (var t = (new Date).getTime() - this._pausedTime, e = t - this._time, i = this._clips, n = i.length, o = [], a = [], r = 0;r < n;r++) {
      const s = i[r]; const l = s.step(t, e);l && (o.push(l), a.push(s));
    } for (r = 0;r < n;)i[r]._needsRemove ? (i[r] = i[n - 1], i.pop(), n--) : r++;n = o.length;for (r = 0;r < n;r++)a[r].fire(o[r]);this._time = t, this.onframe(e), this.trigger('frame', e), this.stage.update && this.stage.update();
  }, _startLoop() {
    const e = this;this._running = !0, en(function t() {
      e._running && (en(t), e._paused || e._update());
    });
  }, start() {
    this._time = (new Date).getTime(), this._pausedTime = 0, this._startLoop();
  }, stop() {
    this._running = !1;
  }, pause() {
    this._paused || (this._pauseStart = (new Date).getTime(), this._paused = !0);
  }, resume() {
    this._paused && (this._pausedTime += (new Date).getTime() - this._pauseStart, this._paused = !1);
  }, clear() {
    this._clips = [];
  }, isFinished() {
    return !this._clips.length;
  }, animate(t, e) {
    const i = new di(t, (e = e || {}).loop, e.getter, e.setter);return this.addAnimator(i), i;
  } }, b(ao, Ct);let ro; let so; const lo = v.domSupported; const uo = (so = { pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1 }, { mouse: ro = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'], touch: ['touchstart', 'touchend', 'touchmove'], pointer: O(ro, (t) => {
    const e = t.replace('mouse', 'pointer');return so.hasOwnProperty(e) ? e : t;
  }) }); const ho = { mouse: ['mousemove', 'mouseup'], pointer: ['pointermove', 'pointerup'] };function co(t) {
    return 'mousewheel' === t && v.browser.firefox ? 'DOMMouseScroll' : t;
  } function fo(t) {
    const e = t.pointerType;return 'pen' === e || 'touch' === e;
  } function po(t) {
    t && (t.zrByTouch = !0);
  } function go(t, e) {
    for (var i = e, n = !1;i && 9 !== i.nodeType && !(n = i.domBelongToZr || i !== e && i === t.painterRoot);)i = i.parentNode;return n;
  } function mo(t, e) {
    this.type = e.type, this.target = this.currentTarget = t.dom, this.pointerType = e.pointerType, this.clientX = e.clientX, this.clientY = e.clientY;
  } const vo = mo.prototype;vo.stopPropagation = vo.stopImmediatePropagation = vo.preventDefault = et;var yo = { mousedown(t) {
    t = Zt(this.dom, t), this._mayPointerCapture = [t.zrX, t.zrY], this.trigger('mousedown', t);
  }, mousemove(t) {
    t = Zt(this.dom, t);const e = this._mayPointerCapture;!e || t.zrX === e[0] && t.zrY === e[1] || Mo(this, !0), this.trigger('mousemove', t);
  }, mouseup(t) {
    t = Zt(this.dom, t), Mo(this, !1), this.trigger('mouseup', t);
  }, mouseout(t) {
    t = Zt(this.dom, t), this._pointerCapturing && (t.zrEventControl = 'no_globalout');const e = t.toElement || t.relatedTarget;t.zrIsToLocalDOM = go(this, e), this.trigger('mouseout', t);
  }, touchstart(t) {
    po(t = Zt(this.dom, t)), this._lastTouchMoment = new Date, this.handler.processGesture(t, 'start'), yo.mousemove.call(this, t), yo.mousedown.call(this, t);
  }, touchmove(t) {
    po(t = Zt(this.dom, t)), this.handler.processGesture(t, 'change'), yo.mousemove.call(this, t);
  }, touchend(t) {
    po(t = Zt(this.dom, t)), this.handler.processGesture(t, 'end'), yo.mouseup.call(this, t), +new Date - this._lastTouchMoment < 300 && yo.click.call(this, t);
  }, pointerdown(t) {
    yo.mousedown.call(this, t);
  }, pointermove(t) {
    fo(t) || yo.mousemove.call(this, t);
  }, pointerup(t) {
    yo.mouseup.call(this, t);
  }, pointerout(t) {
    fo(t) || yo.mouseout.call(this, t);
  } };R(['click', 'mousewheel', 'dblclick', 'contextmenu'], (e) => {
    yo[e] = function (t) {
      t = Zt(this.dom, t), this.trigger(e, t);
    };
  });var xo = { pointermove(t) {
    fo(t) || xo.mousemove.call(this, t);
  }, pointerup(t) {
    xo.mouseup.call(this, t);
  }, mousemove(t) {
    this.trigger('mousemove', t);
  }, mouseup(t) {
    const e = this._pointerCapturing;Mo(this, !1), this.trigger('mouseup', t), e && (t.zrEventControl = 'only_globalout', this.trigger('mouseout', t));
  } };function _o(i, n) {
    const o = n.domHandlers;v.pointerEventsSupported ? R(uo.pointer, (e) => {
      bo(n, e, (t) => {
        o[e].call(i, t);
      });
    }) : (v.touchEventsSupported && R(uo.touch, (e) => {
      bo(n, e, (t) => {
        o[e].call(i, t), (function (t) {
          t.touching = !0, null != t.touchTimer && (clearTimeout(t.touchTimer), t.touchTimer = null), t.touchTimer = setTimeout(() => {
            t.touching = !1, t.touchTimer = null;
          }, 700);
        }(n));
      });
    }), R(uo.mouse, (e) => {
      bo(n, e, (t) => {
        t = Ht(t), n.touching || o[e].call(i, t);
      });
    }));
  } function wo(i, n) {
    function t(e) {
      bo(n, e, (t) => {
        t = Ht(t), go(i, t.target) || (t = (function (t, e) {
          return Zt(t.dom, new mo(t, e), !0);
        }(i, t)), n.domHandlers[e].call(i, t));
      }, { capture: !0 });
    }v.pointerEventsSupported ? R(ho.pointer, t) : v.touchEventsSupported || R(ho.mouse, t);
  } function bo(t, e, i, n) {
    t.mounted[e] = i, t.listenerOpts[e] = n, Ut(t.domTarget, co(e), i, n);
  } function So(t) {
    let e; let i; let n; let o; const a = t.mounted;for (const r in a)a.hasOwnProperty(r) && (e = t.domTarget, i = co(r), n = a[r], o = t.listenerOpts[r], Bt ? e.removeEventListener(i, n, o) : e.detachEvent(`on${i}`, n));t.mounted = {};
  } function Mo(t, e) {
    if (t._mayPointerCapture = null, lo && t._pointerCapturing ^ e) {
      t._pointerCapturing = e;const i = t._globalHandlerScope;e ? wo(t, i) : So(i);
    }
  } function Io(t, e) {
    this.domTarget = t, this.domHandlers = e, this.mounted = {}, this.listenerOpts = {}, this.touchTimer = null, this.touching = !1;
  } function To(t, e) {
    Ct.call(this), this.dom = t, this.painterRoot = e, this._localHandlerScope = new Io(t, yo), lo && (this._globalHandlerScope = new Io(document, xo)), this._pointerCapturing = !1, this._mayPointerCapture = null, _o(this, this._localHandlerScope);
  } const Ao = To.prototype;Ao.dispose = function () {
    So(this._localHandlerScope), lo && So(this._globalHandlerScope);
  }, Ao.setCursor = function (t) {
    this.dom.style && (this.dom.style.cursor = t || 'default');
  }, b(To, Ct);const Do = !v.canvasSupported; const Co = { canvas: oo }; let Lo = {};function ko(t, e) {
    const i = new No(n(), t, e);return Lo[i.id] = i;
  } function Po(t, e) {
    Co[t] = e;
  } var No = function (t, e, i) {
    i = i || {}, this.dom = e, this.id = t;const n = this; const o = new Vi; let a = i.renderer;if (Do) {
      if (!Co.vml) throw new Error('You need to require \'zrender/vml/vml\' to support IE8');a = 'vml';
    } else a && Co[a] || (a = 'canvas');const r = new Co[a](e, o, i, t);this.storage = o, this.painter = r;const s = v.node || v.worker ? null : new To(r.getViewportRoot(), r.root);this.handler = new te(o, r, s, r.root), this.animation = new ao({ stage: { update: A(this.flush, this) } }), this.animation.start(), this._needsRefresh;const l = o.delFromStorage; const u = o.addToStorage;o.delFromStorage = function (t) {
      l.call(o, t), t && t.removeSelfFromZr(n);
    }, o.addToStorage = function (t) {
      u.call(o, t), t.addSelfToZr(n);
    };
  };No.prototype = { constructor: No, getId() {
    return this.id;
  }, add(t) {
    this.storage.addRoot(t), this._needsRefresh = !0;
  }, remove(t) {
    this.storage.delRoot(t), this._needsRefresh = !0;
  }, configLayer(t, e) {
    this.painter.configLayer && this.painter.configLayer(t, e), this._needsRefresh = !0;
  }, setBackgroundColor(t) {
    this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this._needsRefresh = !0;
  }, refreshImmediately() {
    this._needsRefresh = this._needsRefreshHover = !1, this.painter.refresh(), this._needsRefresh = this._needsRefreshHover = !1;
  }, refresh() {
    this._needsRefresh = !0;
  }, flush() {
    let t;this._needsRefresh && (t = !0, this.refreshImmediately()), this._needsRefreshHover && (t = !0, this.refreshHoverImmediately()), t && this.trigger('rendered');
  }, addHover(t, e) {
    if (this.painter.addHover) {
      const i = this.painter.addHover(t, e);return this.refreshHover(), i;
    }
  }, removeHover(t) {
    this.painter.removeHover && (this.painter.removeHover(t), this.refreshHover());
  }, clearHover() {
    this.painter.clearHover && (this.painter.clearHover(), this.refreshHover());
  }, refreshHover() {
    this._needsRefreshHover = !0;
  }, refreshHoverImmediately() {
    this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.refreshHover();
  }, resize(t) {
    t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize();
  }, clearAnimation() {
    this.animation.clear();
  }, getWidth() {
    return this.painter.getWidth();
  }, getHeight() {
    return this.painter.getHeight();
  }, pathToImage(t, e) {
    return this.painter.pathToImage(t, e);
  }, setCursorStyle(t) {
    this.handler.setCursorStyle(t);
  }, findHover(t, e) {
    return this.handler.findHover(t, e);
  }, on(t, e, i) {
    this.handler.on(t, e, i);
  }, off(t, e) {
    this.handler.off(t, e);
  }, trigger(t, e) {
    this.handler.trigger(t, e);
  }, clear() {
    this.storage.delRoot(), this.painter.clear();
  }, dispose() {
    this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, (function (t) {
      delete Lo[t];
    }(this.id));
  } };const Oo = (Object.freeze || Object)({ version: '4.3.2', init: ko, dispose(t) {
    if (t)t.dispose();else {
      for (const e in Lo)Lo.hasOwnProperty(e) && Lo[e].dispose();Lo = {};
    } return this;
  }, getInstance(t) {
    return Lo[t];
  }, registerPainter: Po }); const Ro = R; const Eo = z; const zo = L; const Bo = 'series\0';function Vo(t) {
    return t instanceof Array ? t : null == t ? [] : [t];
  } function Go(t, e, i) {
    if (t) {
      t[e] = t[e] || {}, t.emphasis = t.emphasis || {}, t.emphasis[e] = t.emphasis[e] || {};for (let n = 0, o = i.length;n < o;n++) {
        const a = i[n];!t.emphasis[e].hasOwnProperty(a) && t[e].hasOwnProperty(a) && (t.emphasis[e][a] = t[e][a]);
      }
    }
  } const Fo = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding'];function Wo(t) {
    return !Eo(t) || zo(t) || t instanceof Date ? t : t.value;
  } function Ho(t, o) {
    o = (o || []).slice();const a = O(t || [], (t, e) => ({ exist: t }));return Ro(o, (t, e) => {
      if (Eo(t)) {
        for (var i = 0;i < a.length;i++) if (!a[i].option && null != t.id && a[i].exist.id === `${t.id}`) return a[i].option = t, void(o[e] = null);for (i = 0;i < a.length;i++) {
          const n = a[i].exist;if (!(a[i].option || null != n.id && null != t.id || null == t.name || Xo(t) || Xo(n) || n.name !== `${t.name}`)) return a[i].option = t, void(o[e] = null);
        }
      }
    }), Ro(o, (t, e) => {
      if (Eo(t)) {
        for (var i = 0;i < a.length;i++) {
          const n = a[i].exist;if (!a[i].option && !Xo(n) && null == t.id) {
            a[i].option = t;break;
          }
        }i >= a.length && a.push({ option: t });
      }
    }), a;
  } function Zo(t) {
    const r = Q();Ro(t, (t, e) => {
      const i = t.exist;i && r.set(i.id, t);
    }), Ro(t, (t, e) => {
      const i = t.option;Y(!i || null == i.id || !r.get(i.id) || r.get(i.id) === t, `id duplicates: ${i && i.id}`), i && null != i.id && r.set(i.id, t), t.keyInfo || (t.keyInfo = {});
    }), Ro(t, (t, e) => {
      const i = t.exist; const n = t.option; const o = t.keyInfo;if (Eo(n)) {
        if (o.name = null != n.name ? `${n.name}` : i ? i.name : Bo + e, i)o.id = i.id;else if (null != n.id)o.id = `${n.id}`;else for (let a = 0;o.id = `\0${o.name}\0${a++}`, r.get(o.id););r.set(o.id, t);
      }
    });
  } function Uo(t) {
    const e = t.name;return !(!e || !e.indexOf(Bo));
  } function Xo(t) {
    return Eo(t) && t.id && 0 === (`${t.id}`).indexOf('\0_ec_\0');
  } function Yo(e, t) {
    return null != t.dataIndexInside ? t.dataIndexInside : null != t.dataIndex ? L(t.dataIndex) ? O(t.dataIndex, t => e.indexOfRawIndex(t)) : e.indexOfRawIndex(t.dataIndex) : null != t.name ? L(t.name) ? O(t.name, t => e.indexOfName(t)) : e.indexOfName(t.name) : void 0;
  } function jo() {
    const e = `__\0ec_inner_${qo++}_${Math.random().toFixed(5)}`;return function (t) {
      return t[e] || (t[e] = {});
    };
  } var qo = 0;function Ko(s, l, u) {
    if (E(l)) {
      const t = {};t[`${l}Index`] = 0, l = t;
    } const e = u && u.defaultMainType;!e || $o(l, `${e}Index`) || $o(l, `${e}Id`) || $o(l, `${e}Name`) || (l[`${e}Index`] = 0);const h = {};return Ro(l, (t, e) => {
      t = l[e];if ('dataIndex' !== e && 'dataIndexInside' !== e) {
        const i = e.match(/^(\w+)(Index|Id|Name)$/) || []; const n = i[1]; const o = (i[2] || '').toLowerCase();if (!(!n || !o || null == t || 'index' === o && 'none' === t || u && u.includeMainTypes && _(u.includeMainTypes, n) < 0)) {
          const a = { mainType: n };'index' === o && 'all' === t || (a[o] = t);const r = s.queryComponents(a);h[`${n}Models`] = r, h[`${n}Model`] = r[0];
        }
      } else h[e] = t;
    }), h;
  } function $o(t, e) {
    return t && t.hasOwnProperty(e);
  } function Jo(t, e, i) {
    t.setAttribute ? t.setAttribute(e, i) : t[e] = i;
  } function Qo(t) {
    return 'auto' === t ? v.domSupported ? 'html' : 'richText' : t || 'html';
  } function ta(t, i) {
    const n = Q(); const o = [];return R(t, (t) => {
      const e = i(t);(n.get(e) || (o.push(e), n.set(e, []))).push(t);
    }), { keys: o, buckets: n };
  } const ea = '.'; const ia = '___EC__COMPONENT__CONTAINER___';function na(t) {
    const e = { main: '', sub: '' };return t && (t = t.split(ea), e.main = t[0] || '', e.sub = t[1] || ''), e;
  } function oa(t) {
    (t.$constructor = t).extend = function (t) {
      function e() {
        t.$constructor ? t.$constructor.apply(this, arguments) : i.apply(this, arguments);
      } var i = this;return P(e.prototype, t), e.extend = this.extend, e.superCall = sa, e.superApply = la, w(e, this), e.superClass = i, e;
    };
  } let aa = 0;function ra(t) {
    const e = ['__\0is_clz', aa++, Math.random().toFixed(3)].join('_');t.prototype[e] = !0, t.isInstance = function (t) {
      return !(!t || !t[e]);
    };
  } function sa(t, e) {
    const i = U(arguments, 2);return this.superClass.prototype[e].apply(t, i);
  } function la(t, e, i) {
    return this.superClass.prototype[e].apply(t, i);
  } function ua(i, t) {
    t = t || {};const o = {};if (i.registerClass = function (t, e) {
      if (e) if ((function (t) {
        Y(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), `componentType "${t}" illegal`);
      }(e)), (e = na(e)).sub) {
        if (e.sub !== ia) {
          (function (t) {
            let e = o[t.main];e && e[ia] || ((e = o[t.main] = {})[ia] = !0);return e;
          }(e))[e.sub] = t;
        }
      } else o[e.main] = t;return t;
    }, i.getClass = function (t, e, i) {
      let n = o[t];if (n && n[ia] && (n = e ? n[e] : null), i && !n) throw new Error(e ? `Component ${t}.${e || ''} not exists. Load it first.` : `${t}.type should be specified.`);return n;
    }, i.getClassesByMainType = function (t) {
      t = na(t);const i = []; const e = o[t.main];return e && e[ia] ? R(e, (t, e) => {
        e !== ia && i.push(t);
      }) : i.push(e), i;
    }, i.hasClass = function (t) {
      return t = na(t), !!o[t.main];
    }, i.getAllClassMainTypes = function () {
      const i = [];return R(o, (t, e) => {
        i.push(e);
      }), i;
    }, i.hasSubTypes = function (t) {
      t = na(t);const e = o[t.main];return e && e[ia];
    }, i.parseClassType = na, t.registerWhenExtend) {
      const n = i.extend;n && (i.extend = function (t) {
        const e = n.call(this, t);return i.registerClass(e, t.type);
      });
    } return i;
  } function ha(s) {
    for (let t = 0;t < s.length;t++)s[t][1] || (s[t][1] = s[t][0]);return function (t, e, i) {
      for (var n = {}, o = 0;o < s.length;o++) {
        const a = s[o][1];if (!(e && 0 <= _(e, a) || i && _(i, a) < 0)) {
          const r = t.getShallow(a);null != r && (n[s[o][0]] = r);
        }
      } return n;
    };
  } const ca = ha([['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]); const da = { getLineStyle(t) {
    const e = ca(this, t);return e.lineDash = this.getLineDash(e.lineWidth), e;
  }, getLineDash(t) {
    null == t && (t = 1);const e = this.get('type'); const i = Math.max(t, 2); const n = 4 * t;return 'solid' !== e && null != e && ('dashed' === e ? [n, n] : [i, i]);
  } }; const fa = ha([['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']]); const pa = { getAreaStyle(t, e) {
    return fa(this, t, e);
  } }; const ga = Math.pow; const ma = Math.sqrt; const va = 1e-8; const ya = 1e-4; const xa = ma(3); const _a = 1 / 3; const wa = ot(); const ba = ot(); const Sa = ot();function Ma(t) {
    return -va < t && t < va;
  } function Ia(t) {
    return va < t || t < -va;
  } function Ta(t, e, i, n, o) {
    const a = 1 - o;return a * a * (a * t + 3 * o * e) + o * o * (o * n + 3 * a * i);
  } function Aa(t, e, i, n, o) {
    const a = 1 - o;return 3 * (((e - t) * a + 2 * (i - e) * o) * a + (n - i) * o * o);
  } function Da(t, e, i, n, o) {
    const a = 6 * i - 12 * e + 6 * t; const r = 9 * e + 3 * n - 3 * t - 9 * i; const s = 3 * e - 3 * t; let l = 0;if (Ma(r)) {
      if (Ia(a))0 <= (h = -s / a) && h <= 1 && (o[l++] = h);
    } else {
      const u = a * a - 4 * r * s;if (Ma(u))o[0] = -a / (2 * r);else if (0 < u) {
        var h; const c = ma(u); const d = (-a - c) / (2 * r);0 <= (h = (-a + c) / (2 * r)) && h <= 1 && (o[l++] = h), 0 <= d && d <= 1 && (o[l++] = d);
      }
    } return l;
  } function Ca(t, e, i, n, o, a) {
    const r = (e - t) * o + t; const s = (i - e) * o + e; const l = (n - i) * o + i; const u = (s - r) * o + r; const h = (l - s) * o + s; const c = (h - u) * o + u;a[0] = t, a[1] = r, a[2] = u, a[3] = c, a[4] = c, a[5] = h, a[6] = l, a[7] = n;
  } function La(t, e, i, n) {
    const o = 1 - n;return o * (o * t + 2 * n * e) + n * n * i;
  } function ka(t, e, i, n) {
    return 2 * ((1 - n) * (e - t) + n * (i - e));
  } function Pa(t, e, i) {
    const n = t + i - 2 * e;return 0 == n ? .5 : (t - e) / n;
  } function Na(t, e, i, n, o) {
    const a = (e - t) * n + t; const r = (i - e) * n + e; const s = (r - a) * n + a;o[0] = t, o[1] = a, o[2] = s, o[3] = s, o[4] = r, o[5] = i;
  } const Oa = Math.min; const Ra = Math.max; const Ea = Math.sin; const za = Math.cos; const Ba = 2 * Math.PI; const Va = ot(); const Ga = ot(); const Fa = ot();function Wa(t, e, i) {
    if (0 !== t.length) {
      let n; let o = t[0]; let a = o[0]; let r = o[0]; let s = o[1]; let l = o[1];for (n = 1;n < t.length;n++)o = t[n], a = Oa(a, o[0]), r = Ra(r, o[0]), s = Oa(s, o[1]), l = Ra(l, o[1]);e[0] = a, e[1] = s, i[0] = r, i[1] = l;
    }
  } function Ha(t, e, i, n, o, a) {
    o[0] = Oa(t, i), o[1] = Oa(e, n), a[0] = Ra(t, i), a[1] = Ra(e, n);
  } const Za = []; const Ua = [];function Xa(t, e, i, n, o, a, r, s, l, u) {
    let h; const c = Da; const d = Ta; let f = c(t, i, o, r, Za);for (l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0, h = 0;h < f;h++) {
      const p = d(t, i, o, r, Za[h]);l[0] = Oa(p, l[0]), u[0] = Ra(p, u[0]);
    } for (f = c(e, n, a, s, Ua), h = 0;h < f;h++) {
      const g = d(e, n, a, s, Ua[h]);l[1] = Oa(g, l[1]), u[1] = Ra(g, u[1]);
    }l[0] = Oa(t, l[0]), u[0] = Ra(t, u[0]), l[0] = Oa(r, l[0]), u[0] = Ra(r, u[0]), l[1] = Oa(e, l[1]), u[1] = Ra(e, u[1]), l[1] = Oa(s, l[1]), u[1] = Ra(s, u[1]);
  } function Ya(t, e, i, n, o, a, r, s, l) {
    const u = St; const h = Mt; const c = Math.abs(o - a);if (c % Ba < 1e-4 && 1e-4 < c) return s[0] = t - i, s[1] = e - n, l[0] = t + i, void(l[1] = e + n);if (Va[0] = za(o) * i + t, Va[1] = Ea(o) * n + e, Ga[0] = za(a) * i + t, Ga[1] = Ea(a) * n + e, u(s, Va, Ga), h(l, Va, Ga), (o %= Ba) < 0 && (o += Ba), (a %= Ba) < 0 && (a += Ba), a < o && !r ? a += Ba : o < a && r && (o += Ba), r) {
      const d = a;a = o, o = d;
    } for (let f = 0;f < a;f += Math.PI / 2)o < f && (Fa[0] = za(f) * i + t, Fa[1] = Ea(f) * n + e, u(s, Fa, s), h(l, Fa, l));
  } const ja = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7 }; const qa = []; const Ka = []; const $a = []; const Ja = []; const Qa = Math.min; const tr = Math.max; const er = Math.cos; const ir = Math.sin; const nr = Math.sqrt; const or = Math.abs; const ar = 'undefined' !== typeof Float32Array; const rr = function (t) {
    this._saveData = !t, this._saveData && (this.data = []), this._ctx = null;
  };function sr(t, e, i, n, o, a, r) {
    if (0 === o) return !1;const s = o; let l = 0;if (e + s < r && n + s < r || r < e - s && r < n - s || t + s < a && i + s < a || a < t - s && a < i - s) return !1;if (t === i) return Math.abs(a - t) <= s / 2;const u = (l = (e - n) / (t - i)) * a - r + (t * n - i * e) / (t - i);return u * u / (l * l + 1) <= s / 2 * s / 2;
  } function lr(t, e, i, n, o, a, r, s, l, u, h) {
    if (0 === l) return !1;const c = l;return !(e + c < h && n + c < h && a + c < h && s + c < h || h < e - c && h < n - c && h < a - c && h < s - c || t + c < u && i + c < u && o + c < u && r + c < u || u < t - c && u < i - c && u < o - c && u < r - c) && (function (t, e, i, n, o, a, r, s, l, u, h) {
      let c; let d; let f; let p; let g; let m = .005; let v = 1 / 0;wa[0] = l, wa[1] = u;for (let y = 0;y < 1;y += .05)ba[0] = Ta(t, i, o, r, y), ba[1] = Ta(e, n, a, s, y), (p = _t(wa, ba)) < v && (c = y, v = p);v = 1 / 0;for (let x = 0;x < 32 && !(m < ya);x++)d = c - m, f = c + m, ba[0] = Ta(t, i, o, r, d), ba[1] = Ta(e, n, a, s, d), p = _t(ba, wa), 0 <= d && p < v ? (c = d, v = p) : (Sa[0] = Ta(t, i, o, r, f), Sa[1] = Ta(e, n, a, s, f), g = _t(Sa, wa), f <= 1 && g < v ? (c = f, v = g) : m *= .5);return h && (h[0] = Ta(t, i, o, r, c), h[1] = Ta(e, n, a, s, c)), ma(v);
    }(t, e, i, n, o, a, r, s, u, h, null)) <= c / 2;
  } function ur(t, e, i, n, o, a, r, s, l) {
    if (0 === r) return !1;const u = r;return !(e + u < l && n + u < l && a + u < l || l < e - u && l < n - u && l < a - u || t + u < s && i + u < s && o + u < s || s < t - u && s < i - u && s < o - u) && (function (t, e, i, n, o, a, r, s, l) {
      let u; let h = .005; let c = 1 / 0;wa[0] = r, wa[1] = s;for (let d = 0;d < 1;d += .05) {
        ba[0] = La(t, i, o, d), ba[1] = La(e, n, a, d), (m = _t(wa, ba)) < c && (u = d, c = m);
      }c = 1 / 0;for (let f = 0;f < 32 && !(h < ya);f++) {
        const p = u - h; const g = u + h;ba[0] = La(t, i, o, p), ba[1] = La(e, n, a, p);var m = _t(ba, wa);if (0 <= p && m < c)u = p, c = m;else {
          Sa[0] = La(t, i, o, g), Sa[1] = La(e, n, a, g);const v = _t(Sa, wa);g <= 1 && v < c ? (u = g, c = v) : h *= .5;
        }
      } return l && (l[0] = La(t, i, o, u), l[1] = La(e, n, a, u)), ma(c);
    }(t, e, i, n, o, a, s, l, null)) <= u / 2;
  }rr.prototype = { constructor: rr, _xi: 0, _yi: 0, _x0: 0, _y0: 0, _ux: 0, _uy: 0, _len: 0, _lineDash: null, _dashOffset: 0, _dashIdx: 0, _dashSum: 0, setScale(t, e, i) {
    i = i || 0, this._ux = or(i / pi / t) || 0, this._uy = or(i / pi / e) || 0;
  }, getContext() {
    return this._ctx;
  }, beginPath(t) {
    return (this._ctx = t) && t.beginPath(), t && (this.dpr = t.dpr), this._saveData && (this._len = 0), this._lineDash && (this._lineDash = null, this._dashOffset = 0), this;
  }, moveTo(t, e) {
    return this.addData(ja.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this;
  }, lineTo(t, e) {
    const i = or(t - this._xi) > this._ux || or(e - this._yi) > this._uy || this._len < 5;return this.addData(ja.L, t, e), this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), i && (this._xi = t, this._yi = e), this;
  }, bezierCurveTo(t, e, i, n, o, a) {
    return this.addData(ja.C, t, e, i, n, o, a), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, o, a) : this._ctx.bezierCurveTo(t, e, i, n, o, a)), this._xi = o, this._yi = a, this;
  }, quadraticCurveTo(t, e, i, n) {
    return this.addData(ja.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this;
  }, arc(t, e, i, n, o, a) {
    return this.addData(ja.A, t, e, i, i, n, o - n, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, o, a), this._xi = er(o) * i + t, this._yi = ir(o) * i + e, this;
  }, arcTo(t, e, i, n, o) {
    return this._ctx && this._ctx.arcTo(t, e, i, n, o), this;
  }, rect(t, e, i, n) {
    return this._ctx && this._ctx.rect(t, e, i, n), this.addData(ja.R, t, e, i, n), this;
  }, closePath() {
    this.addData(ja.Z);const t = this._ctx; const e = this._x0; const i = this._y0;return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, this._yi = i, this;
  }, fill(t) {
    t && t.fill(), this.toStatic();
  }, stroke(t) {
    t && t.stroke(), this.toStatic();
  }, setLineDash(t) {
    if (t instanceof Array) {
      this._lineDash = t;for (var e = this._dashIdx = 0, i = 0;i < t.length;i++)e += t[i];this._dashSum = e;
    } return this;
  }, setLineDashOffset(t) {
    return this._dashOffset = t, this;
  }, len() {
    return this._len;
  }, setData(t) {
    const e = t.length;this.data && this.data.length === e || !ar || (this.data = new Float32Array(e));for (let i = 0;i < e;i++) this.data[i] = t[i];this._len = e;
  }, appendPath(t) {
    t instanceof Array || (t = [t]);for (var e = t.length, i = 0, n = this._len, o = 0;o < e;o++)i += t[o].len();ar && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));for (o = 0;o < e;o++) for (let a = t[o].data, r = 0;r < a.length;r++) this.data[n++] = a[r];this._len = n;
  }, addData(t) {
    if (this._saveData) {
      let e = this.data;this._len + arguments.length > e.length && (this._expandData(), e = this.data);for (let i = 0;i < arguments.length;i++)e[this._len++] = arguments[i];this._prevCmd = t;
    }
  }, _expandData() {
    if (!(this.data instanceof Array)) {
      for (var t = [], e = 0;e < this._len;e++)t[e] = this.data[e];this.data = t;
    }
  }, _needsDash() {
    return this._lineDash;
  }, _dashedLineTo(t, e) {
    let i; let n; const o = this._dashSum; let a = this._dashOffset; const r = this._lineDash; const s = this._ctx; const l = this._xi; const u = this._yi; let h = t - l; let c = e - u; const d = nr(h * h + c * c); let f = l; let p = u; const g = r.length;for (a < 0 && (a = o + a), f -= (a %= o) * (h /= d), p -= a * (c /= d);0 < h && f <= t || h < 0 && t <= f || 0 === h && (0 < c && p <= e || c < 0 && e <= p);)f += h * (i = r[n = this._dashIdx]), p += c * i, this._dashIdx = (n + 1) % g, 0 < h && f < l || h < 0 && l < f || 0 < c && p < u || c < 0 && u < p || s[n % 2 ? 'moveTo' : 'lineTo'](0 <= h ? Qa(f, t) : tr(f, t), 0 <= c ? Qa(p, e) : tr(p, e));h = f - t, c = p - e, this._dashOffset = -nr(h * h + c * c);
  }, _dashedBezierTo(t, e, i, n, o, a) {
    let r; let s; let l; let u; let h; const c = this._dashSum; let d = this._dashOffset; const f = this._lineDash; const p = this._ctx; const g = this._xi; const m = this._yi; const v = Ta; let y = 0; let x = this._dashIdx; const _ = f.length; let w = 0;for (d < 0 && (d = c + d), d %= c, r = 0;r < 1;r += .1)s = v(g, t, i, o, r + .1) - v(g, t, i, o, r), l = v(m, e, n, a, r + .1) - v(m, e, n, a, r), y += nr(s * s + l * l);for (;x < _ && !(d < (w += f[x]));x++);for (r = (w - d) / y;r <= 1;)u = v(g, t, i, o, r), h = v(m, e, n, a, r), x % 2 ? p.moveTo(u, h) : p.lineTo(u, h), r += f[x] / y, x = (x + 1) % _;x % 2 != 0 && p.lineTo(o, a), s = o - u, l = a - h, this._dashOffset = -nr(s * s + l * l);
  }, _dashedQuadraticTo(t, e, i, n) {
    const o = i; const a = n;i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, o, a);
  }, toStatic() {
    const t = this.data;t instanceof Array && (t.length = this._len, ar && (this.data = new Float32Array(t)));
  }, getBoundingRect() {
    qa[0] = qa[1] = $a[0] = $a[1] = Number.MAX_VALUE, Ka[0] = Ka[1] = Ja[0] = Ja[1] = -Number.MAX_VALUE;for (var t, e, i, n, o, a, r, s, l, u, h, c, d, f, p = this.data, g = 0, m = 0, v = 0, y = 0, x = 0;x < p.length;) {
      const _ = p[x++];switch (1 === x && (v = g = p[x], y = m = p[x + 1]), _) {
        case ja.M:g = v = p[x++], m = y = p[x++], $a[0] = v, $a[1] = y, Ja[0] = v, Ja[1] = y;break;case ja.L:Ha(g, m, p[x], p[x + 1], $a, Ja), g = p[x++], m = p[x++];break;case ja.C:Xa(g, m, p[x++], p[x++], p[x++], p[x++], p[x], p[x + 1], $a, Ja), g = p[x++], m = p[x++];break;case ja.Q:t = g, e = m, i = p[x++], n = p[x++], o = p[x], a = p[x + 1], r = $a, s = Ja, u = l = void 0, u = La, h = Ra(Oa((l = Pa)(t, i, o), 1), 0), c = Ra(Oa(l(e, n, a), 1), 0), d = u(t, i, o, h), f = u(e, n, a, c), r[0] = Oa(t, o, d), r[1] = Oa(e, a, f), s[0] = Ra(t, o, d), s[1] = Ra(e, a, f), g = p[x++], m = p[x++];break;case ja.A:var w = p[x++]; var b = p[x++]; var S = p[x++]; var M = p[x++]; var I = p[x++]; var T = p[x++] + I;x += 1;var A = 1 - p[x++];1 === x && (v = er(I) * S + w, y = ir(I) * M + b), Ya(w, b, S, M, I, T, A, $a, Ja), g = er(T) * S + w, m = ir(T) * M + b;break;case ja.R:Ha(v = g = p[x++], y = m = p[x++], v + p[x++], y + p[x++], $a, Ja);break;case ja.Z:g = v, m = y;
      }St(qa, qa, $a), Mt(Ka, Ka, Ja);
    } return 0 === x && (qa[0] = qa[1] = Ka[0] = Ka[1] = 0), new Di(qa[0], qa[1], Ka[0] - qa[0], Ka[1] - qa[1]);
  }, rebuildPath(t) {
    for (var e, i, n, o, a, r, s = this.data, l = this._ux, u = this._uy, h = this._len, c = 0;c < h;) {
      const d = s[c++];switch (1 === c && (e = n = s[c], i = o = s[c + 1]), d) {
        case ja.M:e = n = s[c++], i = o = s[c++], t.moveTo(n, o);break;case ja.L:a = s[c++], r = s[c++], (or(a - n) > l || or(r - o) > u || c === h - 1) && (t.lineTo(a, r), n = a, o = r);break;case ja.C:t.bezierCurveTo(s[c++], s[c++], s[c++], s[c++], s[c++], s[c++]), n = s[c - 2], o = s[c - 1];break;case ja.Q:t.quadraticCurveTo(s[c++], s[c++], s[c++], s[c++]), n = s[c - 2], o = s[c - 1];break;case ja.A:var f = s[c++]; var p = s[c++]; var g = s[c++]; var m = s[c++]; var v = s[c++]; var y = s[c++]; var x = s[c++]; var _ = s[c++]; var w = m < g ? g : m; var b = m < g ? 1 : g / m; var S = m < g ? m / g : 1; var M = v + y;.001 < Math.abs(g - m) ? (t.translate(f, p), t.rotate(x), t.scale(b, S), t.arc(0, 0, w, v, M, 1 - _), t.scale(1 / b, 1 / S), t.rotate(-x), t.translate(-f, -p)) : t.arc(f, p, w, v, M, 1 - _), 1 === c && (e = er(v) * g + f, i = ir(v) * m + p), n = er(M) * g + f, o = ir(M) * m + p;break;case ja.R:e = n = s[c], i = o = s[c + 1], t.rect(s[c++], s[c++], s[c++], s[c++]);break;case ja.Z:t.closePath(), n = e, o = i;
      }
    }
  } }, rr.CMD = ja;const hr = 2 * Math.PI;function cr(t) {
    return (t %= hr) < 0 && (t += hr), t;
  } const dr = 2 * Math.PI;function fr(t, e, i, n, o, a, r, s, l) {
    if (0 === r) return !1;const u = r;s -= t, l -= e;const h = Math.sqrt(s * s + l * l);if (i < h - u || h + u < i) return !1;if (Math.abs(n - o) % dr < 1e-4) return !0;if (a) {
      const c = n;n = cr(o), o = cr(c);
    } else n = cr(n), o = cr(o);o < n && (o += dr);let d = Math.atan2(l, s);return d < 0 && (d += dr), n <= d && d <= o || n <= d + dr && d + dr <= o;
  } function pr(t, e, i, n, o, a) {
    if (e < a && n < a || a < e && a < n) return 0;if (n === e) return 0;let r = n < e ? 1 : -1; const s = (a - e) / (n - e);1 != s && 0 != s || (r = n < e ? .5 : -.5);const l = s * (i - t) + t;return l === o ? 1 / 0 : o < l ? r : 0;
  } const gr = rr.CMD; const mr = 2 * Math.PI; const vr = 1e-4;const yr = [-1, -1, -1]; const xr = [-1, -1];function _r(t, e, i, n, o, a, r, s, l, u) {
    if (e < u && n < u && a < u && s < u || u < e && u < n && u < a && u < s) return 0;let h; const c = (function (t, e, i, n, o, a) {
      const r = n + 3 * (e - i) - t; const s = 3 * (i - 2 * e + t); const l = 3 * (e - t); const u = t - o; const h = s * s - 3 * r * l; const c = s * l - 9 * r * u; const d = l * l - 3 * s * u; let f = 0;if (Ma(h) && Ma(c)) {
        if (Ma(s))a[0] = 0;else 0 <= (M = -l / s) && M <= 1 && (a[f++] = M);
      } else {
        const p = c * c - 4 * h * d;if (Ma(p)) {
          const g = c / h; var m = -g / 2;0 <= (M = -s / r + g) && M <= 1 && (a[f++] = M), 0 <= m && m <= 1 && (a[f++] = m);
        } else if (0 < p) {
          const v = ma(p); let y = h * s + 1.5 * r * (-c + v); let x = h * s + 1.5 * r * (-c - v);0 <= (M = (-s - ((y = y < 0 ? -ga(-y, _a) : ga(y, _a)) + (x = x < 0 ? -ga(-x, _a) : ga(x, _a)))) / (3 * r)) && M <= 1 && (a[f++] = M);
        } else {
          const _ = (2 * h * s - 3 * r * c) / (2 * ma(h * h * h)); const w = Math.acos(_) / 3; const b = ma(h); const S = Math.cos(w); var M = (-s - 2 * b * S) / (3 * r); const I = (m = (-s + b * (S + xa * Math.sin(w))) / (3 * r), (-s + b * (S - xa * Math.sin(w))) / (3 * r));0 <= M && M <= 1 && (a[f++] = M), 0 <= m && m <= 1 && (a[f++] = m), 0 <= I && I <= 1 && (a[f++] = I);
        }
      } return f;
    }(e, n, a, s, u, yr));if (0 === c) return 0;for (var d, f, p = 0, g = -1, m = 0;m < c;m++) {
      const v = yr[m]; const y = 0 === v || 1 === v ? .5 : 1;Ta(t, i, o, r, v) < l || (g < 0 && (g = Da(e, n, a, s, xr), xr[1] < xr[0] && 1 < g && (void 0, h = xr[0], xr[0] = xr[1], xr[1] = h), d = Ta(e, n, a, s, xr[0]), 1 < g && (f = Ta(e, n, a, s, xr[1]))), 2 === g ? v < xr[0] ? p += d < e ? y : -y : v < xr[1] ? p += f < d ? y : -y : p += s < f ? y : -y : v < xr[0] ? p += d < e ? y : -y : p += s < d ? y : -y);
    } return p;
  } function wr(t, e, i, n, o, a, r, s) {
    if (e < s && n < s && a < s || s < e && s < n && s < a) return 0;const l = (function (t, e, i, n, o) {
      const a = t - 2 * e + i; const r = 2 * (e - t); const s = t - n; let l = 0;if (Ma(a)) {
        if (Ia(r))0 <= (h = -s / r) && h <= 1 && (o[l++] = h);
      } else {
        const u = r * r - 4 * a * s;if (Ma(u))0 <= (h = -r / (2 * a)) && h <= 1 && (o[l++] = h);else if (0 < u) {
          var h; const c = ma(u); const d = (-r - c) / (2 * a);0 <= (h = (-r + c) / (2 * a)) && h <= 1 && (o[l++] = h), 0 <= d && d <= 1 && (o[l++] = d);
        }
      } return l;
    }(e, n, a, s, yr));if (0 === l) return 0;const u = Pa(e, n, a);if (0 <= u && u <= 1) {
      for (var h = 0, c = La(e, n, a, u), d = 0;d < l;d++) {
        var f = 0 === yr[d] || 1 === yr[d] ? .5 : 1;La(t, i, o, yr[d]) < r || (yr[d] < u ? h += c < e ? f : -f : h += a < c ? f : -f);
      } return h;
    }f = 0 === yr[0] || 1 === yr[0] ? .5 : 1;return La(t, i, o, yr[0]) < r ? 0 : a < e ? f : -f;
  } function br(t, e, i, n, o, a, r, s) {
    if (i < (s -= e) || s < -i) return 0;let l = Math.sqrt(i * i - s * s);yr[0] = -l, yr[1] = l;const u = Math.abs(n - o);if (u < 1e-4) return 0;if (u % mr < 1e-4) {
      o = mr;var h = a ? 1 : -1;return r >= yr[n = 0] + t && r <= yr[1] + t ? h : 0;
    } if (a) {
      l = n;n = cr(o), o = cr(l);
    } else n = cr(n), o = cr(o);o < n && (o += mr);for (var c = 0, d = 0;d < 2;d++) {
      const f = yr[d];if (r < f + t) {
        let p = Math.atan2(s, f);h = a ? 1 : -1;p < 0 && (p = mr + p), (n <= p && p <= o || n <= p + mr && p + mr <= o) && (p > Math.PI / 2 && p < 1.5 * Math.PI && (h = -h), c += h);
      }
    } return c;
  } function Sr(t, e, i, n, o) {
    for (var a = 0, r = 0, s = 0, l = 0, u = 0, h = 0;h < t.length;) {
      const c = t[h++];switch (c === gr.M && 1 < h && (i || (a += pr(r, s, l, u, n, o))), 1 === h && (l = r = t[h], u = s = t[h + 1]), c) {
        case gr.M:r = l = t[h++], s = u = t[h++];break;case gr.L:if (i) {
          if (sr(r, s, t[h], t[h + 1], e, n, o)) return !0;
        } else a += pr(r, s, t[h], t[h + 1], n, o) || 0;r = t[h++], s = t[h++];break;case gr.C:if (i) {
          if (lr(r, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], e, n, o)) return !0;
        } else a += _r(r, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], n, o) || 0;r = t[h++], s = t[h++];break;case gr.Q:if (i) {
          if (ur(r, s, t[h++], t[h++], t[h], t[h + 1], e, n, o)) return !0;
        } else a += wr(r, s, t[h++], t[h++], t[h], t[h + 1], n, o) || 0;r = t[h++], s = t[h++];break;case gr.A:var d = t[h++]; var f = t[h++]; var p = t[h++]; var g = t[h++]; var m = t[h++]; var v = t[h++];h += 1;var y = 1 - t[h++]; var x = Math.cos(m) * p + d; var _ = Math.sin(m) * g + f;1 < h ? a += pr(r, s, x, _, n, o) : (l = x, u = _);var w = (n - d) * g / p + d;if (i) {
          if (fr(d, f, g, m, m + v, y, e, w, o)) return !0;
        } else a += br(d, f, g, m, m + v, y, w, o);r = Math.cos(m + v) * p + d, s = Math.sin(m + v) * g + f;break;case gr.R:l = r = t[h++], u = s = t[h++];x = l + t[h++], _ = u + t[h++];if (i) {
          if (sr(l, u, x, u, e, n, o) || sr(x, u, x, _, e, n, o) || sr(x, _, l, _, e, n, o) || sr(l, _, l, u, e, n, o)) return !0;
        } else a += pr(x, u, x, _, n, o), a += pr(l, _, l, u, n, o);break;case gr.Z:if (i) {
          if (sr(r, s, l, u, e, n, o)) return !0;
        } else a += pr(r, s, l, u, n, o);r = l, s = u;
      }
    } return i || (function (t, e) {
      return Math.abs(t - e) < vr;
    }(s, u)) || (a += pr(r, s, l, u, n, o) || 0), 0 !== a;
  } const Mr = $i.prototype.getCanvasPattern; const Ir = Math.abs; const Tr = new rr(!0);function Ar(t) {
    Jn.call(this, t), this.path = null;
  }Ar.prototype = { constructor: Ar, type: 'path', __dirtyPath: !0, strokeContainThreshold: 5, segmentIgnoreThreshold: 0, subPixelOptimize: !1, brush(t, e) {
    let i; const n = this.style; const o = this.path || Tr; const a = n.hasStroke(); const r = n.hasFill(); const s = n.fill; const l = n.stroke; const u = r && !!s.colorStops; const h = a && !!l.colorStops; const c = r && !!s.image; const d = a && !!l.image;n.bind(t, this, e), this.setTransform(t), this.__dirty && (u && (i = i || this.getBoundingRect(), this._fillGradient = n.getGradient(t, s, i)), h && (i = i || this.getBoundingRect(), this._strokeGradient = n.getGradient(t, l, i)));u ? t.fillStyle = this._fillGradient : c && (t.fillStyle = Mr.call(s, t)), h ? t.strokeStyle = this._strokeGradient : d && (t.strokeStyle = Mr.call(l, t));const f = n.lineDash; const p = n.lineDashOffset; const g = !!t.setLineDash; const m = this.getGlobalScale();if (o.setScale(m[0], m[1], this.segmentIgnoreThreshold), this.__dirtyPath || f && !g && a ? (o.beginPath(t), f && !g && (o.setLineDash(f), o.setLineDashOffset(p)), this.buildPath(o, this.shape, !1), this.path && (this.__dirtyPath = !1)) : (t.beginPath(), this.path.rebuildPath(t)), r) if (null != n.fillOpacity) {
      var v = t.globalAlpha;t.globalAlpha = n.fillOpacity * n.opacity, o.fill(t), t.globalAlpha = v;
    } else o.fill(t);if (f && g && (t.setLineDash(f), t.lineDashOffset = p), a) if (null != n.strokeOpacity) {
      v = t.globalAlpha;t.globalAlpha = n.strokeOpacity * n.opacity, o.stroke(t), t.globalAlpha = v;
    } else o.stroke(t);f && g && t.setLineDash([]), null != n.text && (this.restoreTransform(t), this.drawRectText(t, this.getBoundingRect()));
  }, buildPath(t, e, i) {}, createPathProxy() {
    this.path = new rr;
  }, getBoundingRect() {
    let t = this._rect; const e = this.style; const i = !t;if (i) {
      let n = this.path;n = n || (this.path = new rr), this.__dirtyPath && (n.beginPath(), this.buildPath(n, this.shape, !1)), t = n.getBoundingRect();
    } if (this._rect = t, e.hasStroke()) {
      const o = this._rectWithStroke || (this._rectWithStroke = t.clone());if (this.__dirty || i) {
        o.copy(t);let a = e.lineWidth; const r = e.strokeNoScale ? this.getLineScale() : 1;e.hasFill() || (a = Math.max(a, this.strokeContainThreshold || 4)), 1e-10 < r && (o.width += a / r, o.height += a / r, o.x -= a / r / 2, o.y -= a / r / 2);
      } return o;
    } return t;
  }, contain(t, e) {
    const i = this.transformCoordToLocal(t, e); const n = this.getBoundingRect(); const o = this.style;if (t = i[0], e = i[1], n.contain(t, e)) {
      const a = this.path.data;if (o.hasStroke()) {
        let r = o.lineWidth; const s = o.strokeNoScale ? this.getLineScale() : 1;if (1e-10 < s && (o.hasFill() || (r = Math.max(r, this.strokeContainThreshold)), (function (t, e, i, n) {
          return Sr(t, e, !0, i, n);
        }(a, r / s, t, e)))) return !0;
      } if (o.hasFill()) return (function (t, e, i) {
        return Sr(t, 0, !1, e, i);
      }(a, t, e));
    } return !1;
  }, dirty(t) {
    null == t && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = this.__dirtyText = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty();
  }, animateShape(t) {
    return this.animate('shape', t);
  }, attrKV(t, e) {
    'shape' === t ? (this.setShape(e), this.__dirtyPath = !0, this._rect = null) : Jn.prototype.attrKV.call(this, t, e);
  }, setShape(t, e) {
    const i = this.shape;if (i) {
      if (z(t)) for (const n in t)t.hasOwnProperty(n) && (i[n] = t[n]);else i[t] = e;this.dirty(!0);
    } return this;
  }, getLineScale() {
    const t = this.transform;return t && 1e-10 < Ir(t[0] - 1) && 1e-10 < Ir(t[3] - 1) ? Math.sqrt(Ir(t[0] * t[3] - t[2] * t[1])) : 1;
  } }, Ar.extend = function (o) {
    function t(t) {
      Ar.call(this, t), o.style && this.style.extendFrom(o.style, !1);const e = o.shape;if (e) {
        this.shape = this.shape || {};const i = this.shape;for (const n in e)!i.hasOwnProperty(n) && e.hasOwnProperty(n) && (i[n] = e[n]);
      }o.init && o.init.call(this, t);
    } for (const e in w(t, Ar), o)'style' !== e && 'shape' !== e && (t.prototype[e] = o[e]);return t;
  }, w(Ar, Jn);function Dr(t) {
    return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
  } const Cr = rr.CMD; const Lr = [[], [], []]; const kr = Math.sqrt; const Pr = Math.atan2; const Nr = function (t, e) {
    let i; let n; let o; let a; let r; const s = t.data; const l = Cr.M; const u = Cr.C; const h = Cr.L; const c = Cr.R; const d = Cr.A; const f = Cr.Q;for (a = o = 0;o < s.length;) {
      switch (i = s[o++], a = o, n = 0, i) {
        case l:case h:n = 1;break;case u:n = 3;break;case f:n = 2;break;case d:var p = e[4]; var g = e[5]; var m = kr(e[0] * e[0] + e[1] * e[1]); var v = kr(e[2] * e[2] + e[3] * e[3]); var y = Pr(-e[1] / v, e[0] / m);s[o] *= m, s[o++] += p, s[o] *= v, s[o++] += g, s[o++] *= m, s[o++] *= v, s[o++] += y, s[o++] += y, a = o += 2;break;case c:x[0] = s[o++], x[1] = s[o++], bt(x, x, e), s[a++] = x[0], s[a++] = x[1], x[0] += s[o++], x[1] += s[o++], bt(x, x, e), s[a++] = x[0], s[a++] = x[1];
      } for (r = 0;r < n;r++) {
        var x;(x = Lr[r])[0] = s[o++], x[1] = s[o++], bt(x, x, e), s[a++] = x[0], s[a++] = x[1];
      }
    }
  }; const Or = Math.sqrt; const Rr = Math.sin; const Er = Math.cos; const zr = Math.PI; const Br = function (t, e) {
    return (t[0] * e[0] + t[1] * e[1]) / (Dr(t) * Dr(e));
  }; const Vr = function (t, e) {
    return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(Br(t, e));
  };function Gr(t, e, i, n, o, a, r, s, l, u, h) {
    const c = l * (zr / 180); const d = Er(c) * (t - i) / 2 + Rr(c) * (e - n) / 2; const f = -1 * Rr(c) * (t - i) / 2 + Er(c) * (e - n) / 2; const p = d * d / (r * r) + f * f / (s * s);1 < p && (r *= Or(p), s *= Or(p));const g = (o === a ? -1 : 1) * Or((r * r * (s * s) - r * r * (f * f) - s * s * (d * d)) / (r * r * (f * f) + s * s * (d * d))) || 0; const m = g * r * f / s; const v = g * -s * d / r; const y = (t + i) / 2 + Er(c) * m - Rr(c) * v; const x = (e + n) / 2 + Rr(c) * m + Er(c) * v; const _ = Vr([1, 0], [(d - m) / r, (f - v) / s]); const w = [(d - m) / r, (f - v) / s]; const b = [(-1 * d - m) / r, (-1 * f - v) / s]; let S = Vr(w, b);Br(w, b) <= -1 && (S = zr), 1 <= Br(w, b) && (S = 0), 0 === a && 0 < S && (S -= 2 * zr), 1 === a && S < 0 && (S += 2 * zr), h.addData(u, y, x, r, s, _, S, c, a);
  } const Fr = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi; const Wr = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;function Hr(t, e) {
    const i = (function (t) {
      if (!t) return new rr;for (var e, i = 0, n = 0, o = i, a = n, r = new rr, s = rr.CMD, l = t.match(Fr), u = 0;u < l.length;u++) {
        for (var h, c = l[u], d = c.charAt(0), f = c.match(Wr) || [], p = f.length, g = 0;g < p;g++)f[g] = parseFloat(f[g]);for (let m = 0;m < p;) {
          var v; var y; var x; var _; var w; var b; var S; let M = i; let I = n;switch (d) {
            case 'l':i += f[m++], n += f[m++], h = s.L, r.addData(h, i, n);break;case 'L':i = f[m++], n = f[m++], h = s.L, r.addData(h, i, n);break;case 'm':i += f[m++], n += f[m++], h = s.M, r.addData(h, i, n), o = i, a = n, d = 'l';break;case 'M':i = f[m++], n = f[m++], h = s.M, r.addData(h, i, n), o = i, a = n, d = 'L';break;case 'h':i += f[m++], h = s.L, r.addData(h, i, n);break;case 'H':i = f[m++], h = s.L, r.addData(h, i, n);break;case 'v':n += f[m++], h = s.L, r.addData(h, i, n);break;case 'V':n = f[m++], h = s.L, r.addData(h, i, n);break;case 'C':h = s.C, r.addData(h, f[m++], f[m++], f[m++], f[m++], f[m++], f[m++]), i = f[m - 2], n = f[m - 1];break;case 'c':h = s.C, r.addData(h, f[m++] + i, f[m++] + n, f[m++] + i, f[m++] + n, f[m++] + i, f[m++] + n), i += f[m - 2], n += f[m - 1];break;case 'S':v = i, y = n;var T = r.len(); var A = r.data;e === s.C && (v += i - A[T - 4], y += n - A[T - 3]), h = s.C, M = f[m++], I = f[m++], i = f[m++], n = f[m++], r.addData(h, v, y, M, I, i, n);break;case 's':v = i, y = n;T = r.len(), A = r.data;e === s.C && (v += i - A[T - 4], y += n - A[T - 3]), h = s.C, M = i + f[m++], I = n + f[m++], i += f[m++], n += f[m++], r.addData(h, v, y, M, I, i, n);break;case 'Q':M = f[m++], I = f[m++], i = f[m++], n = f[m++], h = s.Q, r.addData(h, M, I, i, n);break;case 'q':M = f[m++] + i, I = f[m++] + n, i += f[m++], n += f[m++], h = s.Q, r.addData(h, M, I, i, n);break;case 'T':v = i, y = n;T = r.len(), A = r.data;e === s.Q && (v += i - A[T - 4], y += n - A[T - 3]), i = f[m++], n = f[m++], h = s.Q, r.addData(h, v, y, i, n);break;case 't':v = i, y = n;T = r.len(), A = r.data;e === s.Q && (v += i - A[T - 4], y += n - A[T - 3]), i += f[m++], n += f[m++], h = s.Q, r.addData(h, v, y, i, n);break;case 'A':x = f[m++], _ = f[m++], w = f[m++], b = f[m++], S = f[m++], Gr(M = i, I = n, i = f[m++], n = f[m++], b, S, x, _, w, h = s.A, r);break;case 'a':x = f[m++], _ = f[m++], w = f[m++], b = f[m++], S = f[m++], Gr(M = i, I = n, i += f[m++], n += f[m++], b, S, x, _, w, h = s.A, r);
          }
        }'z' !== d && 'Z' !== d || (h = s.Z, r.addData(h), i = o, n = a), e = h;
      } return r.toStatic(), r;
    }(t));return (e = e || {}).buildPath = function (t) {
      if (t.setData) {
        t.setData(i.data), (e = t.getContext()) && t.rebuildPath(e);
      } else {
        var e = t;i.rebuildPath(e);
      }
    }, e.applyTransform = function (t) {
      Nr(i, t), this.dirty(!0);
    }, e;
  } function Zr(t, e) {
    return new Ar(Hr(t, e));
  } const Ur = function (t) {
    Jn.call(this, t);
  };Ur.prototype = { constructor: Ur, type: 'text', brush(t, e) {
    const i = this.style;this.__dirty && Rn(i), i.fill = i.stroke = i.shadowBlur = i.shadowColor = i.shadowOffsetX = i.shadowOffsetY = null;let n = i.text;null != n && (n += ''), qn(n, i) ? (this.setTransform(t), zn(this, t, n, i, null, e), this.restoreTransform(t)) : t.__attrCachedBy = Wi.NONE;
  }, getBoundingRect() {
    const t = this.style;if (this.__dirty && Rn(t), !this._rect) {
      let e = t.text;null != e ? e += '' : e = '';const i = gn(`${t.text}`, t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.textLineHeight, t.rich);if (i.x += t.x || 0, i.y += t.y || 0, Un(t.textStroke, t.textStrokeWidth)) {
        const n = t.textStrokeWidth;i.x -= n / 2, i.y -= n / 2, i.width += n, i.height += n;
      } this._rect = i;
    } return this._rect;
  } }, w(Ur, Jn);function Xr(l) {
    return v.browser.ie && 11 <= v.browser.version ? function () {
      let t; const e = this.__clipPaths; const i = this.style;if (e) for (let n = 0;n < e.length;n++) {
        const o = e[n]; const a = o && o.shape; const r = o && o.type;if (a && ('sector' === r && a.startAngle === a.endAngle || 'rect' === r && (!a.width || !a.height))) {
          for (var s = 0;s < jr.length;s++)jr[s][2] = i[jr[s][0]], i[jr[s][0]] = jr[s][1];t = !0;break;
        }
      } if (l.apply(this, arguments), t) for (s = 0;s < jr.length;s++)i[jr[s][0]] = jr[s][2];
    } : l;
  } const Yr = Ar.extend({ type: 'circle', shape: { cx: 0, cy: 0, r: 0 }, buildPath(t, e, i) {
    i && t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0);
  } }); var jr = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]]; const qr = Ar.extend({ type: 'sector', shape: { cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, brush: Xr(Ar.prototype.brush), buildPath(t, e) {
    const i = e.cx; const n = e.cy; const o = Math.max(e.r0 || 0, 0); const a = Math.max(e.r, 0); const r = e.startAngle; const s = e.endAngle; const l = e.clockwise; const u = Math.cos(r); const h = Math.sin(r);t.moveTo(u * o + i, h * o + n), t.lineTo(u * a + i, h * a + n), t.arc(i, n, a, r, s, !l), t.lineTo(Math.cos(s) * o + i, Math.sin(s) * o + n), 0 !== o && t.arc(i, n, o, s, r, l), t.closePath();
  } }); const Kr = Ar.extend({ type: 'ring', shape: { cx: 0, cy: 0, r: 0, r0: 0 }, buildPath(t, e) {
    const i = e.cx; const n = e.cy; const o = 2 * Math.PI;t.moveTo(i + e.r, n), t.arc(i, n, e.r, 0, o, !1), t.moveTo(i + e.r0, n), t.arc(i, n, e.r0, 0, o, !0);
  } });function $r(t, e, i, n, o, a, r) {
    const s = .5 * (i - t); const l = .5 * (n - e);return (2 * (e - i) + s + l) * r + (-3 * (e - i) - 2 * s - l) * a + s * o + e;
  } function Jr(t, e, i) {
    let n = e.points; const o = e.smooth;if (n && 2 <= n.length) {
      if (o && 'spline' !== o) {
        const a = (function (t, e, i, n) {
          let o; let a; let r; let s; const l = []; const u = []; const h = []; const c = [];if (n) {
            r = [1 / 0, 1 / 0], s = [-1 / 0, -1 / 0];for (var d = 0, f = t.length;d < f;d++)St(r, r, t[d]), Mt(s, s, t[d]);St(r, r, n[0]), Mt(s, s, n[1]);
          } for (d = 0, f = t.length;d < f;d++) {
            const p = t[d];if (i)o = t[d ? d - 1 : f - 1], a = t[(d + 1) % f];else {
              if (0 === d || d === f - 1) {
                l.push(rt(t[d]));continue;
              }o = t[d - 1], a = t[d + 1];
            }ht(u, a, o), gt(u, u, e);let g = vt(p, o); let m = vt(p, a); const v = g + m;0 !== v && (g /= v, m /= v), gt(h, u, -g), gt(c, u, m);const y = lt([], p, h); const x = lt([], p, c);n && (Mt(y, y, r), St(y, y, s), Mt(x, x, r), St(x, x, s)), l.push(y), l.push(x);
          } return i && l.push(l.shift()), l;
        }(n, o, i, e.smoothConstraint));t.moveTo(n[0][0], n[0][1]);for (var r = n.length, s = 0;s < (i ? r : r - 1);s++) {
          const l = a[2 * s]; const u = a[2 * s + 1]; const h = n[(s + 1) % r];t.bezierCurveTo(l[0], l[1], u[0], u[1], h[0], h[1]);
        }
      } else {
        'spline' === o && (n = (function (t, e) {
          for (var i = t.length, n = [], o = 0, a = 1;a < i;a++)o += vt(t[a - 1], t[a]);let r = o / 2;r = r < i ? i : r;for (a = 0;a < r;a++) {
            var s; var l; var u; const h = a / (r - 1) * (e ? i : i - 1); const c = Math.floor(h); const d = h - c; const f = t[c % i];u = e ? (s = t[(c - 1 + i) % i], l = t[(c + 1) % i], t[(c + 2) % i]) : (s = t[0 === c ? c : c - 1], l = t[i - 2 < c ? i - 1 : c + 1], t[i - 3 < c ? i - 1 : c + 2]);const p = d * d; const g = d * p;n.push([$r(s[0], f[0], l[0], u[0], d, p, g), $r(s[1], f[1], l[1], u[1], d, p, g)]);
          } return n;
        }(n, i))), t.moveTo(n[0][0], n[0][1]);s = 1;for (let c = n.length;s < c;s++)t.lineTo(n[s][0], n[s][1]);
      }i && t.closePath();
    }
  } const Qr = Ar.extend({ type: 'polygon', shape: { points: null, smooth: !1, smoothConstraint: null }, buildPath(t, e) {
    Jr(t, e, !0);
  } }); const ts = Ar.extend({ type: 'polyline', shape: { points: null, smooth: !1, smoothConstraint: null }, style: { stroke: '#000', fill: null }, buildPath(t, e) {
    Jr(t, e, !1);
  } }); const es = Math.round;function is(t, e, i) {
    if (e) {
      const n = e.x1; const o = e.x2; const a = e.y1; const r = e.y2;t.x1 = n, t.x2 = o, t.y1 = a, t.y2 = r;const s = i && i.lineWidth;s && (es(2 * n) === es(2 * o) && (t.x1 = t.x2 = os(n, s, !0)), es(2 * a) === es(2 * r) && (t.y1 = t.y2 = os(a, s, !0)));
    }
  } function ns(t, e, i) {
    if (e) {
      const n = e.x; const o = e.y; const a = e.width; const r = e.height;t.x = n, t.y = o, t.width = a, t.height = r;const s = i && i.lineWidth;s && (t.x = os(n, s, !0), t.y = os(o, s, !0), t.width = Math.max(os(n + a, s, !1) - t.x, 0 === a ? 0 : 1), t.height = Math.max(os(o + r, s, !1) - t.y, 0 === r ? 0 : 1));
    }
  } function os(t, e, i) {
    if (!e) return t;const n = es(2 * t);return (n + es(e)) % 2 == 0 ? n / 2 : (n + (i ? 1 : -1)) / 2;
  } const as = {}; const rs = Ar.extend({ type: 'rect', shape: { r: 0, x: 0, y: 0, width: 0, height: 0 }, buildPath(t, e) {
    let i; let n; let o; let a;this.subPixelOptimize ? (ns(as, e, this.style), i = as.x, n = as.y, o = as.width, a = as.height, as.r = e.r, e = as) : (i = e.x, n = e.y, o = e.width, a = e.height), e.r ? Dn(t, e) : t.rect(i, n, o, a), t.closePath();
  } }); const ss = {}; const ls = Ar.extend({ type: 'line', shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1 }, style: { stroke: '#000', fill: null }, buildPath(t, e) {
    let i; let n; let o; let a;a = this.subPixelOptimize ? (is(ss, e, this.style), i = ss.x1, n = ss.y1, o = ss.x2, ss.y2) : (i = e.x1, n = e.y1, o = e.x2, e.y2);const r = e.percent;0 !== r && (t.moveTo(i, n), r < 1 && (o = i * (1 - r) + o * r, a = n * (1 - r) + a * r), t.lineTo(o, a));
  }, pointAt(t) {
    const e = this.shape;return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t];
  } }); const us = [];function hs(t, e, i) {
    const n = t.cpx2; const o = t.cpy2;return null === n || null === o ? [(i ? Aa : Ta)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? Aa : Ta)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? ka : La)(t.x1, t.cpx1, t.x2, e), (i ? ka : La)(t.y1, t.cpy1, t.y2, e)];
  } function cs(t) {
    this.colorStops = t || [];
  } const ds = Ar.extend({ type: 'bezier-curve', shape: { x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1 }, style: { stroke: '#000', fill: null }, buildPath(t, e) {
    const i = e.x1; const n = e.y1; let o = e.x2; let a = e.y2; let r = e.cpx1; let s = e.cpy1; let l = e.cpx2; let u = e.cpy2; const h = e.percent;0 !== h && (t.moveTo(i, n), null == l || null == u ? (h < 1 && (Na(i, r, o, h, us), r = us[1], o = us[2], Na(n, s, a, h, us), s = us[1], a = us[2]), t.quadraticCurveTo(r, s, o, a)) : (h < 1 && (Ca(i, r, l, o, h, us), r = us[1], l = us[2], o = us[3], Ca(n, s, u, a, h, us), s = us[1], u = us[2], a = us[3]), t.bezierCurveTo(r, s, l, u, o, a)));
  }, pointAt(t) {
    return hs(this.shape, t, !1);
  }, tangentAt(t) {
    const e = hs(this.shape, t, !0);return mt(e, e);
  } }); const fs = Ar.extend({ type: 'arc', shape: { cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, style: { stroke: '#000', fill: null }, buildPath(t, e) {
    const i = e.cx; const n = e.cy; const o = Math.max(e.r, 0); const a = e.startAngle; const r = e.endAngle; const s = e.clockwise; const l = Math.cos(a); const u = Math.sin(a);t.moveTo(l * o + i, u * o + n), t.arc(i, n, o, a, r, !s);
  } }); const ps = Ar.extend({ type: 'compound', shape: { paths: null }, _updatePathDirty() {
    for (var t = this.__dirtyPath, e = this.shape.paths, i = 0;i < e.length;i++)t = t || e[i].__dirtyPath;this.__dirtyPath = t, this.__dirty = this.__dirty || t;
  }, beforeBrush() {
    this._updatePathDirty();for (let t = this.shape.paths || [], e = this.getGlobalScale(), i = 0;i < t.length;i++)t[i].path || t[i].createPathProxy(), t[i].path.setScale(e[0], e[1], t[i].segmentIgnoreThreshold);
  }, buildPath(t, e) {
    for (let i = e.paths || [], n = 0;n < i.length;n++)i[n].buildPath(t, i[n].shape, !0);
  }, afterBrush() {
    for (let t = this.shape.paths || [], e = 0;e < t.length;e++)t[e].__dirtyPath = !1;
  }, getBoundingRect() {
    return this._updatePathDirty(), Ar.prototype.getBoundingRect.call(this);
  } });cs.prototype = { constructor: cs, addColorStop(t, e) {
    this.colorStops.push({ offset: t, color: e });
  } };function gs(t, e, i, n, o, a) {
    this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == i ? 1 : i, this.y2 = null == n ? 0 : n, this.type = 'linear', this.global = a || !1, cs.call(this, o);
  }gs.prototype = { constructor: gs }, w(gs, cs);function ms(t, e, i, n, o) {
    this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == i ? .5 : i, this.type = 'radial', this.global = o || !1, cs.call(this, n);
  } function vs(t) {
    Jn.call(this, t), this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.notClear = !0;
  }ms.prototype = { constructor: ms }, w(ms, cs), vs.prototype.incremental = !0, vs.prototype.clearDisplaybles = function () {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.dirty(), this.notClear = !1;
  }, vs.prototype.addDisplayable = function (t, e) {
    e ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.dirty();
  }, vs.prototype.addDisplayables = function (t, e) {
    e = e || !1;for (let i = 0;i < t.length;i++) this.addDisplayable(t[i], e);
  }, vs.prototype.eachPendingDisplayable = function (t) {
    for (var e = this._cursor;e < this._displayables.length;e++)t && t(this._displayables[e]);for (e = 0;e < this._temporaryDisplayables.length;e++)t && t(this._temporaryDisplayables[e]);
  }, vs.prototype.update = function () {
    this.updateTransform();for (var t = this._cursor;t < this._displayables.length;t++) {
      (e = this._displayables[t]).parent = this, e.update(), e.parent = null;
    } for (t = 0;t < this._temporaryDisplayables.length;t++) {
      var e;(e = this._temporaryDisplayables[t]).parent = this, e.update(), e.parent = null;
    }
  }, vs.prototype.brush = function (t, e) {
    for (var i = this._cursor;i < this._displayables.length;i++) {
      (n = this._displayables[i]).beforeBrush && n.beforeBrush(t), n.brush(t, i === this._cursor ? null : this._displayables[i - 1]), n.afterBrush && n.afterBrush(t);
    } this._cursor = i;for (i = 0;i < this._temporaryDisplayables.length;i++) {
      var n;(n = this._temporaryDisplayables[i]).beforeBrush && n.beforeBrush(t), n.brush(t, 0 === i ? null : this._temporaryDisplayables[i - 1]), n.afterBrush && n.afterBrush(t);
    } this._temporaryDisplayables = [], this.notClear = !0;
  };const ys = [];vs.prototype.getBoundingRect = function () {
    if (!this._rect) {
      for (var t = new Di(1 / 0, 1 / 0, -1 / 0, -1 / 0), e = 0;e < this._displayables.length;e++) {
        const i = this._displayables[e]; const n = i.getBoundingRect().clone();i.needLocalTransform() && n.applyTransform(i.getLocalTransform(ys)), t.union(n);
      } this._rect = t;
    } return this._rect;
  }, vs.prototype.contain = function (t, e) {
    const i = this.transformCoordToLocal(t, e);if (this.getBoundingRect().contain(i[0], i[1])) for (let n = 0;n < this._displayables.length;n++) {
      if (this._displayables[n].contain(t, e)) return !0;
    } return !1;
  }, w(vs, Jn);const xs = Math.max; const _s = Math.min; const ws = {}; const bs = 1; const Ss = { color: 'textFill', textBorderColor: 'textStroke', textBorderWidth: 'textStrokeWidth' }; const Ms = 'emphasis'; const Is = 'normal'; let Ts = 1; const As = {}; const Ds = {};function Cs(t) {
    return Ar.extend(t);
  } function Ls(t, e) {
    Ds[t] = e;
  } function ks(t) {
    if (Ds.hasOwnProperty(t)) return Ds[t];
  } function Ps(t, e, i, n) {
    const o = Zr(t, e);return i && ('center' === n && (i = Os(i, o.getBoundingRect())), Es(o, i)), o;
  } function Ns(t, i, n) {
    var o = new Qn({ style: { image: t, x: i.x, y: i.y, width: i.width, height: i.height }, onload(t) {
      if ('center' === n) {
        const e = { width: t.width, height: t.height };o.setStyle(Os(i, e));
      }
    } });return o;
  } function Os(t, e) {
    let i; const n = e.width / e.height; let o = t.height * n;return i = o <= t.width ? t.height : (o = t.width) / n, { x: t.x + t.width / 2 - o / 2, y: t.y + t.height / 2 - i / 2, width: o, height: i };
  } const Rs = function (t, e) {
    for (var i = [], n = t.length, o = 0;o < n;o++) {
      const a = t[o];a.path || a.createPathProxy(), a.__dirtyPath && a.buildPath(a.path, a.shape, !0), i.push(a.path);
    } const r = new Ar(e);return r.createPathProxy(), r.buildPath = function (t) {
      t.appendPath(i);const e = t.getContext();e && t.rebuildPath(e);
    }, r;
  };function Es(t, e) {
    if (t.applyTransform) {
      const i = t.getBoundingRect().calculateTransform(e);t.applyTransform(i);
    }
  } const zs = os;function Bs(t) {
    return null != t && 'none' !== t;
  } const Vs = Q(); let Gs = 0;function Fs(t) {
    const e = t.__hoverStl;if (e && !t.__highlighted) {
      const i = t.__zr; const n = t.useHoverLayer && i && 'canvas' === i.painter.type;if (t.__highlighted = n ? 'layer' : 'plain', !(t.isGroup || !i && t.useHoverLayer)) {
        let o = t; let a = t.style;n && (a = (o = i.addHover(t)).style), ll(a), n || (function (t) {
          if (t.__hoverStlDirty) {
            t.__hoverStlDirty = !1;const e = t.__hoverStl;if (e) {
              const i = t.__cachedNormalStl = {};t.__cachedNormalZ2 = t.z2;const n = t.style;for (const o in e)null != e[o] && (i[o] = n[o]);i.fill = n.fill, i.stroke = n.stroke;
            } else t.__cachedNormalStl = t.__cachedNormalZ2 = null;
          }
        }(o)), a.extendFrom(e), Ws(a, e, 'fill'), Ws(a, e, 'stroke'), sl(a), n || (t.dirty(!1), t.z2 += bs);
      }
    }
  } function Ws(t, e, i) {
    !Bs(e[i]) && Bs(t[i]) && (t[i] = (function (t) {
      if ('string' !== typeof t) return t;let e = Vs.get(t);return e || (e = He(t, -.1), Gs < 1e4 && (Vs.set(t, e), Gs++)), e;
    }(t[i])));
  } function Hs(t) {
    const e = t.__highlighted;if (e && (t.__highlighted = !1, !t.isGroup)) if ('layer' === e)t.__zr && t.__zr.removeHover(t);else {
      const i = t.style; const n = t.__cachedNormalStl;n && (ll(i), t.setStyle(n), sl(i));const o = t.__cachedNormalZ2;null != o && t.z2 - o === bs && (t.z2 = o);
    }
  } function Zs(t, e, i) {
    let n; let o = Is; let a = Is;t.__highlighted && (o = Ms, n = !0), e(t, i), t.__highlighted && (a = Ms, n = !0), t.isGroup && t.traverse((t) => {
      t.isGroup || e(t, i);
    }), n && t.__highDownOnUpdate && t.__highDownOnUpdate(o, a);
  } function Us(t, e) {
    e = t.__hoverStl = !1 !== e && (t.hoverStyle || e || {}), t.__hoverStlDirty = !0, t.__highlighted && (t.__cachedNormalStl = null, Hs(t), Fs(t));
  } function Xs(t) {
    Ks(this, t) || this.__highByOuter || Zs(this, Fs);
  } function Ys(t) {
    Ks(this, t) || this.__highByOuter || Zs(this, Hs);
  } function js(t) {
    this.__highByOuter |= 1 << (t || 0), Zs(this, Fs);
  } function qs(t) {
    (this.__highByOuter &= ~(1 << (t || 0))) || Zs(this, Hs);
  } function Ks(t, e) {
    return t.__highDownSilentOnTouch && e.zrByTouch;
  } function $s(t, e) {
    Js(t, !0), Zs(t, Us, e);
  } function Js(t, e) {
    const i = !1 === e;if (t.__highDownSilentOnTouch = t.highDownSilentOnTouch, t.__highDownOnUpdate = t.highDownOnUpdate, !i || t.__highDownDispatcher) {
      const n = i ? 'off' : 'on';t[n]('mouseover', Xs)[n]('mouseout', Ys), t[n]('emphasis', js)[n]('normal', qs), t.__highByOuter = t.__highByOuter || 0, t.__highDownDispatcher = !i;
    }
  } function Qs(t) {
    return !(!t || !t.__highDownDispatcher);
  } function tl(t) {
    let e = As[t];return null == e && Ts <= 32 && (e = As[t] = Ts++), e;
  } function el(t, e, i, n, o, a, r) {
    let s; const l = (o = o || ws).labelFetcher; const u = o.labelDataIndex; const h = o.labelDimIndex; const c = o.labelProp; const d = i.getShallow('show'); const f = n.getShallow('show');(d || f) && (l && (s = l.getFormattedLabel(u, 'normal', null, h, c)), null == s && (s = C(o.defaultText) ? o.defaultText(u, o) : o.defaultText));const p = d ? s : null; const g = f ? H(l ? l.getFormattedLabel(u, 'emphasis', null, h, c) : null, s) : null;null == p && null == g || (nl(t, i, a, o), nl(e, n, r, o, !0)), t.text = p, e.text = g;
  } function il(t, e, i) {
    let n = t.style;e && (ll(n), t.setStyle(e), sl(n)), n = t.__hoverStl, i && n && (ll(n), P(n, i), sl(n));
  } function nl(t, e, i, n, o) {
    return ol(t, e, n, o), i && P(t, i), t;
  } function ol(t, e, i, n) {
    if ((i = i || ws).isRectText) {
      let o;i.getTextPosition ? o = i.getTextPosition(e, n) : 'outside' === (o = e.getShallow('position') || (n ? null : 'inside')) && (o = 'top'), t.textPosition = o, t.textOffset = e.getShallow('offset');let a = e.getShallow('rotate');null != a && (a *= Math.PI / 180), t.textRotation = a, t.textDistance = H(e.getShallow('distance'), n ? null : 5);
    } let r; const s = e.ecModel; const l = s && s.option.textStyle; const u = (function (t) {
      let e;for (;t && t !== t.ecModel;) {
        const i = (t.option || ws).rich;if (i) for (const n in e = e || {}, i)i.hasOwnProperty(n) && (e[n] = 1);t = t.parentModel;
      } return e;
    }(e));if (u) for (const h in r = {}, u) if (u.hasOwnProperty(h)) {
      const c = e.getModel(['rich', h]);al(r[h] = {}, c, l, i, n);
    } return t.rich = r, al(t, e, l, i, n, !0), i.forceRich && !i.textStyle && (i.textStyle = {}), t;
  } function al(t, e, i, n, o, a) {
    i = !o && i || ws, t.textFill = rl(e.getShallow('color'), n) || i.color, t.textStroke = rl(e.getShallow('textBorderColor'), n) || i.textBorderColor, t.textStrokeWidth = H(e.getShallow('textBorderWidth'), i.textBorderWidth), o || (a && (t.insideRollbackOpt = n, sl(t)), null == t.textFill && (t.textFill = n.autoColor)), t.fontStyle = e.getShallow('fontStyle') || i.fontStyle, t.fontWeight = e.getShallow('fontWeight') || i.fontWeight, t.fontSize = e.getShallow('fontSize') || i.fontSize, t.fontFamily = e.getShallow('fontFamily') || i.fontFamily, t.textAlign = e.getShallow('align'), t.textVerticalAlign = e.getShallow('verticalAlign') || e.getShallow('baseline'), t.textLineHeight = e.getShallow('lineHeight'), t.textWidth = e.getShallow('width'), t.textHeight = e.getShallow('height'), t.textTag = e.getShallow('tag'), a && n.disableBox || (t.textBackgroundColor = rl(e.getShallow('backgroundColor'), n), t.textPadding = e.getShallow('padding'), t.textBorderColor = rl(e.getShallow('borderColor'), n), t.textBorderWidth = e.getShallow('borderWidth'), t.textBorderRadius = e.getShallow('borderRadius'), t.textBoxShadowColor = e.getShallow('shadowColor'), t.textBoxShadowBlur = e.getShallow('shadowBlur'), t.textBoxShadowOffsetX = e.getShallow('shadowOffsetX'), t.textBoxShadowOffsetY = e.getShallow('shadowOffsetY')), t.textShadowColor = e.getShallow('textShadowColor') || i.textShadowColor, t.textShadowBlur = e.getShallow('textShadowBlur') || i.textShadowBlur, t.textShadowOffsetX = e.getShallow('textShadowOffsetX') || i.textShadowOffsetX, t.textShadowOffsetY = e.getShallow('textShadowOffsetY') || i.textShadowOffsetY;
  } function rl(t, e) {
    return 'auto' !== t ? t : e && e.autoColor ? e.autoColor : null;
  } function sl(t) {
    let e; const i = t.textPosition; const n = t.insideRollbackOpt;if (n && null == t.textFill) {
      const o = n.autoColor; const a = n.isRectText; const r = n.useInsideStyle; const s = !1 !== r && (!0 === r || a && i && 'string' === typeof i && 0 <= i.indexOf('inside')); const l = !s && null != o;(s || l) && (e = { textFill: t.textFill, textStroke: t.textStroke, textStrokeWidth: t.textStrokeWidth }), s && (t.textFill = '#fff', null == t.textStroke && (t.textStroke = o, null == t.textStrokeWidth && (t.textStrokeWidth = 2))), l && (t.textFill = o);
    }t.insideRollback = e;
  } function ll(t) {
    const e = t.insideRollback;e && (t.textFill = e.textFill, t.textStroke = e.textStroke, t.textStrokeWidth = e.textStrokeWidth, t.insideRollback = null);
  } function ul(t, e) {
    const i = e && e.getModel('textStyle');return j([t.fontStyle || i && i.getShallow('fontStyle') || '', t.fontWeight || i && i.getShallow('fontWeight') || '', `${t.fontSize || i && i.getShallow('fontSize') || 12}px`, t.fontFamily || i && i.getShallow('fontFamily') || 'sans-serif'].join(' '));
  } function hl(t, e, i, n, o, a) {
    if ('function' === typeof o && (a = o, o = null), n && n.isAnimationEnabled()) {
      const r = t ? 'Update' : ''; let s = n.getShallow(`animationDuration${r}`); const l = n.getShallow(`animationEasing${r}`); let u = n.getShallow(`animationDelay${r}`);'function' === typeof u && (u = u(o, n.getAnimationDelayParams ? n.getAnimationDelayParams(e, o) : null)), 'function' === typeof s && (s = s(o)), 0 < s ? e.animateTo(i, s, u || 0, l, a, !!a) : (e.stopAnimation(), e.attr(i), a && a());
    } else e.stopAnimation(), e.attr(i), a && a();
  } function cl(t, e, i, n, o) {
    hl(!0, t, e, i, n, o);
  } function dl(t, e, i, n, o) {
    hl(!1, t, e, i, n, o);
  } function fl(t, e) {
    for (var i = re([]);t && t !== e;)le(i, t.getLocalTransform(), i), t = t.parent;return i;
  } function pl(t, e, i) {
    return e && !N(e) && (e = ve.getLocalTransform(e)), i && (e = de([], e)), bt([], t, e);
  } function gl(t, e, i) {
    const n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]); const o = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]); let a = ['left' === t ? -n : 'right' === t ? n : 0, 'top' === t ? -o : 'bottom' === t ? o : 0];return a = pl(a, e, i), Math.abs(a[0]) > Math.abs(a[1]) ? 0 < a[0] ? 'right' : 'left' : 0 < a[1] ? 'bottom' : 'top';
  } function ml(t, e, n, i) {
    if (t && e) {
      let o; const a = (o = {}, t.traverse((t) => {
        !t.isGroup && t.anid && (o[t.anid] = t);
      }), o);e.traverse((t) => {
        if (!t.isGroup && t.anid) {
          const e = a[t.anid];if (e) {
            const i = r(t);t.attr(r(e)), cl(t, i, n, t.dataIndex);
          }
        }
      });
    } function r(t) {
      const e = { position: rt(t.position), rotation: t.rotation };return t.shape && (e.shape = P({}, t.shape)), e;
    }
  } function vl(t, n) {
    return O(t, (t) => {
      let e = t[0];e = xs(e, n.x), e = _s(e, n.x + n.width);let i = t[1];return i = xs(i, n.y), [e, i = _s(i, n.y + n.height)];
    });
  } function yl(t, e, i) {
    const n = (e = P({ rectHover: !0 }, e)).style = { strokeNoScale: !0 };if (i = i || { x: -1, y: -1, width: 2, height: 2 }, t) return 0 === t.indexOf('image://') ? (n.image = t.slice(8), D(n, i), new Qn(e)) : Ps(t.replace('path://', ''), e, i, 'center');
  } function xl(t, e, i, n, o) {
    for (let a = 0, r = o[o.length - 1];a < o.length;a++) {
      const s = o[a];if (_l(t, e, i, n, s[0], s[1], r[0], r[1])) return !0;r = s;
    }
  } function _l(t, e, i, n, o, a, r, s) {
    const l = i - t; const u = n - e; const h = r - o; const c = s - a; const d = wl(h, c, l, u);if (function (t) {
      return t <= 1e-6 && -1e-6 <= t;
    }(d)) return !1;const f = t - o; const p = e - a; const g = wl(f, p, l, u) / d;if (g < 0 || 1 < g) return !1;const m = wl(f, p, h, c) / d;return !(m < 0 || 1 < m);
  } function wl(t, e, i, n) {
    return t * n - i * e;
  }Ls('circle', Yr), Ls('sector', qr), Ls('ring', Kr), Ls('polygon', Qr), Ls('polyline', ts), Ls('rect', rs), Ls('line', ls), Ls('bezierCurve', ds), Ls('arc', fs);const bl = (Object.freeze || Object)({ Z2_EMPHASIS_LIFT: bs, CACHED_LABEL_STYLE_PROPERTIES: Ss, extendShape: Cs, extendPath(t, e) {
    return (function (t, e) {
      return Ar.extend(Hr(t, e));
    }(t, e));
  }, registerShape: Ls, getShapeClass: ks, makePath: Ps, makeImage: Ns, mergePath: Rs, resizePath: Es, subPixelOptimizeLine(t) {
    return is(t.shape, t.shape, t.style), t;
  }, subPixelOptimizeRect(t) {
    return ns(t.shape, t.shape, t.style), t;
  }, subPixelOptimize: zs, setElementHoverStyle: Us, setHoverStyle: $s, setAsHighDownDispatcher: Js, isHighDownDispatcher: Qs, getHighlightDigit: tl, setLabelStyle: el, modifyLabelStyle: il, setTextStyle: nl, setText(t, e, i) {
    let n; const o = { isRectText: !0 };!1 === i ? n = !0 : o.autoColor = i, ol(t, e, o, n);
  }, getFont: ul, updateProps: cl, initProps: dl, getTransform: fl, applyTransform: pl, transformDirection: gl, groupTransition: ml, clipPointsByRect: vl, clipRectByRect(t, e) {
    const i = xs(t.x, e.x); const n = _s(t.x + t.width, e.x + e.width); const o = xs(t.y, e.y); const a = _s(t.y + t.height, e.y + e.height);if (i <= n && o <= a) return { x: i, y: o, width: n - i, height: a - o };
  }, createIcon: yl, linePolygonIntersect: xl, lineLineIntersect: _l, Group: Ci, Image: Qn, Text: Ur, Circle: Yr, Sector: qr, Ring: Kr, Polygon: Qr, Polyline: ts, Rect: rs, Line: ls, BezierCurve: ds, Arc: fs, IncrementalDisplayable: vs, CompoundPath: ps, LinearGradient: gs, RadialGradient: ms, BoundingRect: Di }); const Sl = ['textStyle', 'color']; const Ml = { getTextColor(t) {
    const e = this.ecModel;return this.getShallow('color') || (!t && e ? e.get(Sl) : null);
  }, getFont() {
    return ul({ fontStyle: this.getShallow('fontStyle'), fontWeight: this.getShallow('fontWeight'), fontSize: this.getShallow('fontSize'), fontFamily: this.getShallow('fontFamily') }, this.ecModel);
  }, getTextRect(t) {
    return gn(t, this.getFont(), this.getShallow('align'), this.getShallow('verticalAlign') || this.getShallow('baseline'), this.getShallow('padding'), this.getShallow('lineHeight'), this.getShallow('rich'), this.getShallow('truncateText'));
  } }; const Il = ha([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['textPosition'], ['textAlign']]); const Tl = { getItemStyle(t, e) {
    const i = Il(this, t, e); const n = this.getBorderLineDash();return n && (i.lineDash = n), i;
  }, getBorderLineDash() {
    const t = this.get('borderType');return 'solid' === t || null == t ? null : 'dashed' === t ? [5, 5] : [1, 1];
  } }; const Al = b; const Dl = jo();function Cl(t, e, i) {
    this.parentModel = e, this.ecModel = i, this.option = t;
  } function Ll(t, e, i) {
    for (let n = 0;n < e.length && (!e[n] || null != (t = t && 'object' === typeof t ? t[e[n]] : null));n++);return null == t && i && (t = i.get(e)), t;
  } function kl(t, e) {
    const i = Dl(t).getParent;return i ? i.call(t, e) : t.parentModel;
  }Cl.prototype = { constructor: Cl, init: null, mergeOption(t) {
    m(this.option, t, !0);
  }, get(t, e) {
    return null == t ? this.option : Ll(this.option, this.parsePath(t), !e && kl(this, t));
  }, getShallow(t, e) {
    const i = this.option; let n = null == i ? i : i[t]; const o = !e && kl(this, t);return null == n && o && (n = o.getShallow(t)), n;
  }, getModel(t, e) {
    let i;return new Cl(null == t ? this.option : Ll(this.option, t = this.parsePath(t)), e = e || (i = kl(this, t)) && i.getModel(t), this.ecModel);
  }, isEmpty() {
    return null == this.option;
  }, restoreData() {}, clone() {
    return new this.constructor(k(this.option));
  }, setReadOnly(t) {}, parsePath(t) {
    return 'string' === typeof t && (t = t.split('.')), t;
  }, customizeGetParent(t) {
    Dl(this).getParent = t;
  }, isAnimationEnabled() {
    if (!v.node) {
      if (null != this.option.animation) return !!this.option.animation;if (this.parentModel) return this.parentModel.isAnimationEnabled();
    }
  } }, oa(Cl), ra(Cl), Al(Cl, da), Al(Cl, pa), Al(Cl, Ml), Al(Cl, Tl);let Pl = 0;function Nl(t) {
    return [t || '', Pl++, Math.random().toFixed(5)].join('_');
  } const Ol = 1e-4;function Rl(t, e, i, n) {
    const o = e[1] - e[0]; const a = i[1] - i[0];if (0 == o) return 0 == a ? i[0] : (i[0] + i[1]) / 2;if (n) if (0 < o) {
      if (t <= e[0]) return i[0];if (t >= e[1]) return i[1];
    } else {
      if (t >= e[0]) return i[0];if (t <= e[1]) return i[1];
    } else {
      if (t === e[0]) return i[0];if (t === e[1]) return i[1];
    } return (t - e[0]) / o * a + i[0];
  } function El(t, e) {
    switch (t) {
      case 'center':case 'middle':t = '50%';break;case 'left':case 'top':t = '0%';break;case 'right':case 'bottom':t = '100%';
    } return 'string' === typeof t ? (function (t) {
      return t.replace(/^\s+|\s+$/g, '');
    }(t)).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : null == t ? NaN : +t;
  } function zl(t, e, i) {
    return null == e && (e = 10), e = Math.min(Math.max(0, e), 20), t = (+t).toFixed(e), i ? t : +t;
  } function Bl(t) {
    return t.sort((t, e) => t - e), t;
  } function Vl(t) {
    if (t = +t, isNaN(t)) return 0;for (var e = 1, i = 0;Math.round(t * e) / e !== t;)e *= 10, i++;return i;
  } function Gl(t) {
    const e = t.toString(); const i = e.indexOf('e');if (0 < i) {
      const n = +e.slice(i + 1);return n < 0 ? -n : 0;
    } const o = e.indexOf('.');return o < 0 ? 0 : e.length - 1 - o;
  } function Fl(t, e) {
    const i = Math.log; const n = Math.LN10; const o = Math.floor(i(t[1] - t[0]) / n); const a = Math.round(i(Math.abs(e[1] - e[0])) / n); const r = Math.min(Math.max(-o + a, 0), 20);return isFinite(r) ? r : 20;
  } function Wl(t, e, i) {
    if (!t[e]) return 0;const n = S(t, (t, e) => t + (isNaN(e) ? 0 : e), 0);if (0 === n) return 0;for (var o = Math.pow(10, i), a = O(t, t => (isNaN(t) ? 0 : t) / n * o * 100), r = 100 * o, s = O(a, t => Math.floor(t)), l = S(s, (t, e) => t + e, 0), u = O(a, (t, e) => t - s[e]);l < r;) {
      for (var h = Number.NEGATIVE_INFINITY, c = null, d = 0, f = u.length;d < f;++d)u[d] > h && (h = u[d], c = d);++s[c], u[c] = 0, ++l;
    } return s[e] / o;
  } const Hl = 9007199254740991;function Zl(t) {
    const e = 2 * Math.PI;return (t % e + e) % e;
  } function Ul(t) {
    return -Ol < t && t < Ol;
  } const Xl = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;function Yl(t) {
    if (t instanceof Date) return t;if ('string' !== typeof t) return null == t ? new Date(NaN) : new Date(Math.round(t));const e = Xl.exec(t);if (!e) return new Date(NaN);if (e[8]) {
      let i = +e[4] || 0;return 'Z' !== e[8].toUpperCase() && (i -= e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, i, +(e[5] || 0), +e[6] || 0, +e[7] || 0));
    } return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, +e[7] || 0);
  } function jl(t) {
    return Math.pow(10, ql(t));
  } function ql(t) {
    if (0 === t) return 0;let e = Math.floor(Math.log(t) / Math.LN10);return 10 <= t / Math.pow(10, e) && e++, e;
  } function Kl(t, e) {
    const i = ql(t); const n = Math.pow(10, i); const o = t / n;return t = (e ? o < 1.5 ? 1 : o < 2.5 ? 2 : o < 4 ? 3 : o < 7 ? 5 : 10 : o < 1 ? 1 : o < 2 ? 2 : o < 3 ? 3 : o < 5 ? 5 : 10) * n, -20 <= i ? +t.toFixed(i < 0 ? -i : 0) : t;
  } function $l(t) {
    t.sort((t, e) => ((function t(e, i, n) {
      return e.interval[n] < i.interval[n] || e.interval[n] === i.interval[n] && (e.close[n] - i.close[n] == (n ? -1 : 1) || !n && t(e, i, 1));
    }(t, e, 0)) ? -1 : 1));for (let e = -1 / 0, i = 1, n = 0;n < t.length;) {
      for (var o = t[n].interval, a = t[n].close, r = 0;r < 2;r++)o[r] <= e && (o[r] = e, a[r] = r ? 1 : 1 - i), e = o[r], i = a[r];o[0] === o[1] && a[0] * a[1] != 1 ? t.splice(n, 1) : n++;
    } return t;
  } function Jl(t) {
    return 0 <= t - parseFloat(t);
  } const Ql = (Object.freeze || Object)({ linearMap: Rl, parsePercent: El, round: zl, asc: Bl, getPrecision: Vl, getPrecisionSafe: Gl, getPixelPrecision: Fl, getPercentWithPrecision: Wl, MAX_SAFE_INTEGER: Hl, remRadian: Zl, isRadianAroundZero: Ul, parseDate: Yl, quantity: jl, quantityExponent: ql, nice: Kl, quantile(t, e) {
    const i = (t.length - 1) * e + 1; const n = Math.floor(i); const o = +t[n - 1]; const a = i - n;return a ? o + a * (t[n] - o) : o;
  }, reformIntervals: $l, isNumeric: Jl });function tu(t) {
    return isNaN(t) ? '-' : (t = (`${t}`).split('.'))[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (1 < t.length ? `.${t[1]}` : '');
  } function eu(t, e) {
    return t = (t || '').toLowerCase().replace(/-(.)/g, (t, e) => e.toUpperCase()), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t;
  } const iu = X; const nu = /([&<>"'])/g; const ou = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;' };function au(t) {
    return null == t ? '' : (`${t}`).replace(nu, (t, e) => ou[e]);
  } function ru(t, e) {
    return `{${t}${null == e ? '' : e}}`;
  } const su = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];function lu(t, e, i) {
    L(e) || (e = [e]);const n = e.length;if (!n) return '';for (var o = e[0].$vars || [], a = 0;a < o.length;a++) {
      const r = su[a];t = t.replace(ru(r), ru(r, 0));
    } for (let s = 0;s < n;s++) for (let l = 0;l < o.length;l++) {
      const u = e[s][o[l]];t = t.replace(ru(su[l], s), i ? au(u) : u);
    } return t;
  } function uu(i, t, n) {
    return R(t, (t, e) => {
      i = i.replace(`{${e}}`, n ? au(t) : t);
    }), i;
  } function hu(t, e) {
    const i = (t = E(t) ? { color: t, extraCssText: e } : t || {}).color; const n = t.type; const o = (e = t.extraCssText, t.renderMode || 'html'); const a = t.markerId || 'X';return i ? 'html' === o ? 'subItem' === n ? `<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:${au(i)};${e || ''}"></span>` : `<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:${au(i)};${e || ''}"></span>` : { renderMode: o, content: `{marker${a}|}  `, style: { color: i } } : '';
  } function cu(t, e) {
    return '0000'.substr(0, e - (t += '').length) + t;
  } function du(t, e, i) {
    'week' !== t && 'month' !== t && 'quarter' !== t && 'half-year' !== t && 'year' !== t || (t = 'MM-dd\nyyyy');const n = Yl(e); const o = i ? 'UTC' : ''; const a = n[`get${o}FullYear`](); const r = n[`get${o}Month`]() + 1; const s = n[`get${o}Date`](); const l = n[`get${o}Hours`](); const u = n[`get${o}Minutes`](); const h = n[`get${o}Seconds`](); const c = n[`get${o}Milliseconds`]();return t = t.replace('MM', cu(r, 2)).replace('M', r)
      .replace('yyyy', a)
      .replace('yy', a % 100)
      .replace('dd', cu(s, 2))
      .replace('d', s)
      .replace('hh', cu(l, 2))
      .replace('h', l)
      .replace('mm', cu(u, 2))
      .replace('m', u)
      .replace('ss', cu(h, 2))
      .replace('s', h)
      .replace('SSS', cu(c, 3));
  } function fu(t) {
    return t ? t.charAt(0).toUpperCase() + t.substr(1) : t;
  } const pu = xn;function gu(t, e) {
    if ('_blank' === e || 'blank' === e) {
      const i = window.open();i.opener = null, i.location = t;
    } else window.open(t, e);
  } const mu = (Object.freeze || Object)({ addCommas: tu, toCamelCase: eu, normalizeCssArray: iu, encodeHTML: au, formatTpl: lu, formatTplSimple: uu, getTooltipMarker: hu, formatTime: du, capitalFirst: fu, truncateText: pu, getTextBoundingRect(t) {
    return gn(t.text, t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.textLineHeight, t.rich, t.truncate);
  }, getTextRect(t, e, i, n, o, a, r, s) {
    return gn(t, e, i, n, o, s, a, r);
  }, windowOpen: gu }); const vu = R; const yu = ['left', 'right', 'top', 'bottom', 'width', 'height']; const xu = [['width', 'left', 'right'], ['height', 'top', 'bottom']];function _u(h, c, d, f, p) {
    let g = 0; let m = 0;null == f && (f = 1 / 0), null == p && (p = 1 / 0);let v = 0;c.eachChild((t, e) => {
      let i; let n; const o = t.position; const a = t.getBoundingRect(); const r = c.childAt(e + 1); const s = r && r.getBoundingRect();if ('horizontal' === h) {
        const l = a.width + (s ? -s.x + a.x : 0);v = f < (i = g + l) || t.newline ? (g = 0, i = l, m += v + d, a.height) : Math.max(v, a.height);
      } else {
        const u = a.height + (s ? -s.y + a.y : 0);v = p < (n = m + u) || t.newline ? (g += v + d, m = 0, n = u, a.width) : Math.max(v, a.width);
      }t.newline || (o[0] = g, o[1] = m, 'horizontal' === h ? g = i + d : m = n + d);
    });
  } const wu = _u;T(_u, 'vertical'), T(_u, 'horizontal');function bu(t, e, i) {
    i = iu(i || 0);const n = e.width; const o = e.height; let a = El(t.left, n); let r = El(t.top, o); const s = El(t.right, n); const l = El(t.bottom, o); let u = El(t.width, n); let h = El(t.height, o); const c = i[2] + i[0]; const d = i[1] + i[3]; const f = t.aspect;switch (isNaN(u) && (u = n - s - d - a), isNaN(h) && (h = o - l - c - r), null != f && (isNaN(u) && isNaN(h) && (n / o < f ? u = .8 * n : h = .8 * o), isNaN(u) && (u = f * h), isNaN(h) && (h = u / f)), isNaN(a) && (a = n - s - u - d), isNaN(r) && (r = o - l - h - c), t.left || t.right) {
      case 'center':a = n / 2 - u / 2 - i[3];break;case 'right':a = n - u - d;
    } switch (t.top || t.bottom) {
      case 'middle':case 'center':r = o / 2 - h / 2 - i[0];break;case 'bottom':r = o - h - c;
    }a = a || 0, r = r || 0, isNaN(u) && (u = n - d - a - (s || 0)), isNaN(h) && (h = o - c - r - (l || 0));const p = new Di(a + i[3], r + i[0], u, h);return p.margin = i, p;
  } function Su(t, e, i, n, o) {
    const a = !o || !o.hv || o.hv[0]; const r = !o || !o.hv || o.hv[1]; const s = o && o.boundingMode || 'all';if (a || r) {
      let l;if ('raw' === s)l = 'group' === t.type ? new Di(0, 0, +e.width || 0, +e.height || 0) : t.getBoundingRect();else if (l = t.getBoundingRect(), t.needLocalTransform()) {
        const u = t.getLocalTransform();(l = l.clone()).applyTransform(u);
      }e = bu(D({ width: l.width, height: l.height }, e), i, n);const h = t.position; const c = a ? e.x - l.x : 0; const d = r ? e.y - l.y : 0;t.attr('position', 'raw' === s ? [c, d] : [h[0] + c, h[1] + d]);
    }
  } function Mu(l, u, t) {
    z(t) || (t = {});let h = t.ignoreSize;L(h) || (h = [h, h]);const e = n(xu[0], 0); const i = n(xu[1], 1);function n(t, e) {
      const i = {}; let n = 0; const o = {}; let a = 0;if (vu(t, (t) => {
        o[t] = l[t];
      }), vu(t, (t) => {
        c(u, t) && (i[t] = o[t] = u[t]), d(i, t) && n++, d(o, t) && a++;
      }), h[e]) return d(u, t[1]) ? o[t[2]] = null : d(u, t[2]) && (o[t[1]] = null), o;if (2 !== a && n) {
        if (2 <= n) return i;for (let r = 0;r < t.length;r++) {
          const s = t[r];if (!c(i, s) && c(l, s)) {
            i[s] = l[s];break;
          }
        } return i;
      } return o;
    } function c(t, e) {
      return t.hasOwnProperty(e);
    } function d(t, e) {
      return null != t[e] && 'auto' !== t[e];
    } function o(t, e, i) {
      vu(t, (t) => {
        e[t] = i[t];
      });
    }o(xu[0], l, e), o(xu[1], l, i);
  } function Iu(t) {
    return Tu({}, t);
  } function Tu(e, i) {
    return i && e && vu(yu, (t) => {
      i.hasOwnProperty(t) && (e[t] = i[t]);
    }), e;
  } let Au; let Du; let Cu; const Lu = jo(); const ku = Cl.extend({ type: 'component', id: '', name: '', mainType: '', subType: '', componentIndex: 0, defaultOption: null, ecModel: null, dependentModels: [], uid: null, layoutMode: null, $constructor(t, e, i, n) {
    Cl.call(this, t, e, i, n), this.uid = Nl('ec_cpt_model');
  }, init(t, e, i, n) {
    this.mergeDefaultAndTheme(t, i);
  }, mergeDefaultAndTheme(t, e) {
    const i = this.layoutMode; const n = i ? Iu(t) : {};m(t, e.getTheme().get(this.mainType)), m(t, this.getDefaultOption()), i && Mu(t, n, i);
  }, mergeOption(t, e) {
    m(this.option, t, !0);const i = this.layoutMode;i && Mu(this.option, t, i);
  }, optionUpdated(t, e) {}, getDefaultOption() {
    const t = Lu(this);if (!t.defaultOption) {
      for (var e = [], i = this.constructor;i;) {
        const n = i.prototype.defaultOption;n && e.push(n), i = i.superClass;
      } for (var o = {}, a = e.length - 1;0 <= a;a--)o = m(o, e[a], !0);t.defaultOption = o;
    } return t.defaultOption;
  }, getReferringComponents(t) {
    return this.ecModel.queryComponents({ mainType: t, index: this.get(`${t}Index`, !0), id: this.get(`${t}Id`, !0) });
  } });function Pu(t, e) {
    return t[e] || (t[e] = { predecessor: [], successor: [] }), t[e];
  }ua(ku, { registerWhenExtend: !0 }), Du = {}, (Au = ku).registerSubTypeDefaulter = function (t, e) {
    t = na(t), Du[t.main] = e;
  }, Au.determineSubType = function (t, e) {
    let i = e.type;if (!i) {
      const n = na(t).main;Au.hasSubTypes(t) && Du[n] && (i = Du[n](e));
    } return i;
  }, Cu = function (t) {
    let e = [];R(ku.getClassesByMainType(t), (t) => {
      e = e.concat(t.prototype.dependencies || []);
    }), e = O(e, t => na(t).main), 'dataset' !== t && _(e, 'dataset') <= 0 && e.unshift('dataset');return e;
  }, ku.topologicalTravel = function (t, e, i, n) {
    if (t.length) {
      const o = (function (e) {
        const o = {}; const a = [];return R(e, (i) => {
          const n = Pu(o, i); const t = (function (t, e) {
            const i = [];return R(t, (t) => {
              0 <= _(e, t) && i.push(t);
            }), i;
          }(n.originalDeps = Cu(i), e));n.entryCount = t.length, 0 === n.entryCount && a.push(i), R(t, (t) => {
            _(n.predecessor, t) < 0 && n.predecessor.push(t);const e = Pu(o, t);_(e.successor, t) < 0 && e.successor.push(i);
          });
        }), { graph: o, noEntryList: a };
      }(e)); var a = o.graph; var r = o.noEntryList; var s = {};for (R(t, (t) => {
        s[t] = !0;
      });r.length;) {
        const l = r.pop(); const u = a[l]; const h = !!s[l];h && (i.call(n, l, u.originalDeps.slice()), delete s[l]), R(u.successor, h ? d : c);
      }R(s, () => {
        throw new Error('Circle dependency may exists');
      });
    } function c(t) {
      a[t].entryCount--, 0 === a[t].entryCount && r.push(t);
    } function d(t) {
      s[t] = !0, c(t);
    }
  }, b(ku, { getBoxLayoutParams() {
    return { left: this.get('left'), top: this.get('top'), right: this.get('right'), bottom: this.get('bottom'), width: this.get('width'), height: this.get('height') };
  } });let Nu = '';'undefined' !== typeof navigator && (Nu = navigator.platform || '');const Ou = { color: ['#c23531', '#2f4554', '#61a0a8', '#d48265', '#91c7ae', '#749f83', '#ca8622', '#bda29a', '#6e7074', '#546570', '#c4ccd3'], gradientColor: ['#f6efa6', '#d88273', '#bf444c'], textStyle: { fontFamily: Nu.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif', fontSize: 12, fontStyle: 'normal', fontWeight: 'normal' }, blendMode: null, animation: 'auto', animationDuration: 1e3, animationDurationUpdate: 300, animationEasing: 'exponentialOut', animationEasingUpdate: 'cubicOut', animationThreshold: 2e3, progressiveThreshold: 3e3, progressive: 400, hoverLayerThreshold: 3e3, useUTC: !1 }; const Ru = jo();const Eu = { clearColorPalette() {
    Ru(this).colorIdx = 0, Ru(this).colorNameMap = {};
  }, getColorFromPalette(t, e, i) {
    const n = Ru(e = e || this); const o = n.colorIdx || 0; const a = n.colorNameMap = n.colorNameMap || {};if (a.hasOwnProperty(t)) return a[t];const r = Vo(this.get('color', !0)); const s = this.get('colorLayer', !0); let l = null != i && s ? (function (t, e) {
      for (var i = t.length, n = 0;n < i;n++) if (t[n].length > e) return t[n];return t[i - 1];
    }(s, i)) : r;if ((l = l || r) && l.length) {
      const u = l[o];return t && (a[t] = u), n.colorIdx = (o + 1) % l.length, u;
    }
  } }; const zu = 'original'; const Bu = 'arrayRows'; const Vu = 'objectRows'; const Gu = 'keyedColumns'; const Fu = 'unknown'; const Wu = 'typedArray'; const Hu = 'column'; const Zu = 'row';function Uu(t) {
    this.fromDataset = t.fromDataset, this.data = t.data || (t.sourceFormat === Gu ? {} : []), this.sourceFormat = t.sourceFormat || Fu, this.seriesLayoutBy = t.seriesLayoutBy || Hu, this.dimensionsDefine = t.dimensionsDefine, this.encodeDefine = t.encodeDefine && Q(t.encodeDefine), this.startIndex = t.startIndex || 0, this.dimensionsDetectCount = t.dimensionsDetectCount;
  }Uu.seriesDataToSource = function (t) {
    return new Uu({ data: t, sourceFormat: V(t) ? Wu : zu, fromDataset: !1 });
  }, ra(Uu);const Xu = { Must: 1, Might: 2, Not: 3 }; const Yu = jo();function ju(t) {
    const e = t.option; let i = e.data; let n = V(i) ? Wu : zu; let o = !1; let a = e.seriesLayoutBy; let r = e.sourceHeader; let s = e.dimensions; const l = Qu(t);if (l) {
      const u = l.option;i = u.source, n = Yu(l).sourceFormat, o = !0, a = a || u.seriesLayoutBy, null == r && (r = u.sourceHeader), s = s || u.dimensions;
    } const h = (function (t, e, i, n, o) {
      if (!t) return { dimensionsDefine: qu(o) };let a; let r;if (e === Bu)'auto' === n || null == n ? Ku((t) => {
        null != t && '-' !== t && (E(t) ? null == r && (r = 1) : r = 0);
      }, i, t, 10) : r = n ? 1 : 0, o || 1 !== r || (o = [], Ku((t, e) => {
        o[e] = null != t ? t : '';
      }, i, t)), a = o ? o.length : i === Zu ? t.length : t[0] ? t[0].length : null;else if (e === Vu)o = o || (function (t) {
        let e; let i = 0;for (;i < t.length && !(e = t[i++]););if (e) {
          const n = [];return R(e, (t, e) => {
            n.push(e);
          }), n;
        }
      }(t));else if (e === Gu)o || (o = [], R(t, (t, e) => {
        o.push(e);
      }));else if (e === zu) {
        const s = Wo(t[0]);a = L(s) && s.length || 1;
      } return { startIndex: r, dimensionsDefine: qu(o), dimensionsDetectCount: a };
    }(i, n, a, r, s));Yu(t).source = new Uu({ data: i, fromDataset: o, seriesLayoutBy: a, sourceFormat: n, dimensionsDefine: h.dimensionsDefine, startIndex: h.startIndex, dimensionsDetectCount: h.dimensionsDetectCount, encodeDefine: e.encode });
  } function qu(t) {
    if (t) {
      const n = Q();return O(t, (t, e) => {
        if (null == (t = P({}, z(t) ? t : { name: t })).name) return t;t.name += '', null == t.displayName && (t.displayName = t.name);const i = n.get(t.name);return i ? t.name += `-${i.count++}` : n.set(t.name, { count: 1 }), t;
      });
    }
  } function Ku(t, e, i, n) {
    if (null == n && (n = 1 / 0), e === Zu) for (var o = 0;o < i.length && o < n;o++)t(i[o] ? i[o][0] : null, o);else {
      const a = i[0] || [];for (o = 0;o < a.length && o < n;o++)t(a[o], o);
    }
  } function $u(i, t, e) {
    const a = {}; const n = Qu(t);if (!n || !i) return a;let r; let o; const s = []; const l = []; const u = t.ecModel; const h = Yu(u).datasetMap; const c = `${n.uid}_${e.seriesLayoutBy}`;R(i = i.slice(), (t, e) => {
      z(t) || (i[e] = { name: t }), 'ordinal' === t.type && null == r && (o = p(i[r = e])), a[t.name] = [];
    });const d = h.get(c) || h.set(c, { categoryWayDim: o, valueWayDim: 0 });function f(t, e, i) {
      for (let n = 0;n < i;n++)t.push(e + n);
    } function p(t) {
      const e = t.dimsDef;return e ? e.length : 1;
    } return R(i, (t, e) => {
      const i = t.name; const n = p(t);if (null == r) {
        var o = d.valueWayDim;f(a[i], o, n), f(l, o, n), d.valueWayDim += n;
      } else if (r === e)f(a[i], 0, n), f(s, 0, n);else {
        o = d.categoryWayDim;f(a[i], o, n), f(l, o, n), d.categoryWayDim += n;
      }
    }), s.length && (a.itemName = s), l.length && (a.seriesName = l), a;
  } function Ju(t, l, u) {
    const e = {};if (!Qu(t)) return e;let h; const c = l.sourceFormat; const d = l.dimensionsDefine;c !== Vu && c !== Gu || R(d, (t, e) => {
      'name' === (z(t) ? t.name : t) && (h = e);
    });const i = (function () {
      for (var t = {}, e = {}, i = [], n = 0, o = Math.min(5, u);n < o;n++) {
        const a = th(l.data, c, l.seriesLayoutBy, d, l.startIndex, n);i.push(a);const r = a === Xu.Not;if (r && null == t.v && n !== h && (t.v = n), null != t.n && t.n !== t.v && (r || i[t.n] !== Xu.Not) || (t.n = n), s(t) && i[t.n] !== Xu.Not) return t;r || (a === Xu.Might && null == e.v && n !== h && (e.v = n), null != e.n && e.n !== e.v || (e.n = n));
      } function s(t) {
        return null != t.v && null != t.n;
      } return s(t) ? t : s(e) ? e : null;
    }());if (i) {
      e.value = i.v;const n = null != h ? h : i.n;e.itemName = [n], e.seriesName = [n];
    } return e;
  } function Qu(t) {
    const e = t.option;if (!e.data) return t.ecModel.getComponent('dataset', e.datasetIndex || 0);
  } function th(t, e, i, n, o, a) {
    let r; let s; let l;if (V(t)) return Xu.Not;if (n) {
      const u = n[a];z(u) ? (s = u.name, l = u.type) : E(u) && (s = u);
    } if (null != l) return 'ordinal' === l ? Xu.Must : Xu.Not;if (e === Bu) if (i === Zu) {
      for (var h = t[a], c = 0;c < (h || []).length && c < 5;c++) if (null != (r = g(h[o + c]))) return r;
    } else for (c = 0;c < t.length && c < 5;c++) {
      const d = t[o + c];if (d && null != (r = g(d[a]))) return r;
    } else if (e === Vu) {
      if (!s) return Xu.Not;for (c = 0;c < t.length && c < 5;c++) {
        if ((f = t[c]) && null != (r = g(f[s]))) return r;
      }
    } else if (e === Gu) {
      if (!s) return Xu.Not;if (!(h = t[s]) || V(h)) return Xu.Not;for (c = 0;c < h.length && c < 5;c++) if (null != (r = g(h[c]))) return r;
    } else if (e === zu) for (c = 0;c < t.length && c < 5;c++) {
      var f; const p = Wo(f = t[c]);if (!L(p)) return Xu.Not;if (null != (r = g(p[a]))) return r;
    } function g(t) {
      const e = E(t);return null != t && isFinite(t) && '' !== t ? e ? Xu.Might : Xu.Not : e && '-' !== t ? Xu.Must : void 0;
    } return Xu.Not;
  } const eh = '\0_ec_inner'; const ih = Cl.extend({ init(t, e, i, n) {
    i = i || {}, this.option = null, this._theme = new Cl(i), this._optionManager = n;
  }, setOption(t, e) {
    Y(!(eh in t), 'please use chart.getOption()'), this._optionManager.setOption(t, e), this.resetOption(null);
  }, resetOption(t) {
    let e = !1; const i = this._optionManager;if (!t || 'recreate' === t) {
      const n = i.mountOption('recreate' === t);this.option && 'recreate' !== t ? (this.restoreData(), this.mergeOption(n)) : function (t) {
        t = t, this.option = {}, this.option[eh] = 1, this._componentsMap = Q({ series: [] }), this._seriesIndices, this._seriesIndicesMap, (function (i, t) {
          const n = i.color && !i.colorLayer;R(t, (t, e) => {
            'colorLayer' === e && n || ku.hasClass(e) || ('object' === typeof t ? i[e] = i[e] ? m(i[e], t, !1) : k(t) : null == i[e] && (i[e] = t));
          });
        }(t, this._theme.option)), m(t, Ou, !1), this.mergeOption(t);
      }.call(this, n), e = !0;
    } if ('timeline' !== t && 'media' !== t || this.restoreData(), !t || 'recreate' === t || 'timeline' === t) {
      const o = i.getTimelineOption(this);o && (this.mergeOption(o), e = !0);
    } if (!t || 'recreate' === t || 'media' === t) {
      const a = i.getMediaOption(this, this._api);a.length && R(a, function (t) {
        this.mergeOption(t, e = !0);
      }, this);
    } return e;
  }, mergeOption(n) {
    const l = this.option; const u = this._componentsMap; const i = [];!(function (t) {
      Yu(t).datasetMap = Q();
    }(this)), R(n, (t, e) => {
      null != t && (ku.hasClass(e) ? e && i.push(e) : l[e] = null == l[e] ? k(t) : m(l[e], t, !0));
    }), ku.topologicalTravel(i, ku.getAllClassMainTypes(), function (r, t) {
      const e = Vo(n[r]); const i = Ho(u.get(r), e);Zo(i), R(i, (t, e) => {
        const i = t.option;z(i) && (t.keyInfo.mainType = r, t.keyInfo.subType = (function (t, e, i) {
          return e.type ? e.type : i ? i.subType : ku.determineSubType(t, e);
        }(r, i, t.exist)));
      });const s = (function (e, t) {
        L(t) || (t = t ? [t] : []);const i = {};return R(t, (t) => {
          i[t] = (e.get(t) || []).slice();
        }), i;
      }(u, t));l[r] = [], u.set(r, []), R(i, function (t, e) {
        let i = t.exist; const n = t.option;if (Y(z(n) || i, 'Empty component definition'), n) {
          const o = ku.getClass(r, t.keyInfo.subType, !0);if (i && i.constructor === o)i.name = t.keyInfo.name, i.mergeOption(n, this), i.optionUpdated(n, !1);else {
            const a = P({ dependentModels: s, componentIndex: e }, t.keyInfo);P(i = new o(n, this, this, a), a), i.init(n, this, this, a), i.optionUpdated(null, !0);
          }
        } else i.mergeOption({}, this), i.optionUpdated({}, !1);u.get(r)[e] = i, l[r][e] = i.option;
      }, this), 'series' === r && nh(this, u.get('series'));
    }, this), this._seriesIndicesMap = Q(this._seriesIndices = this._seriesIndices || []);
  }, getOption() {
    const n = k(this.option);return R(n, (t, e) => {
      if (ku.hasClass(e)) {
        for (let i = (t = Vo(t)).length - 1;0 <= i;i--)Xo(t[i]) && t.splice(i, 1);n[e] = t;
      }
    }), delete n[eh], n;
  }, getTheme() {
    return this._theme;
  }, getComponent(t, e) {
    const i = this._componentsMap.get(t);if (i) return i[e || 0];
  }, queryComponents(t) {
    const e = t.mainType;if (!e) return [];let i; let n = t.index; const o = t.id; const a = t.name; const r = this._componentsMap.get(e);if (!r || !r.length) return [];if (null != n)L(n) || (n = [n]), i = M(O(n, t => r[t]), t => !!t);else if (null != o) {
      const s = L(o);i = M(r, t => s && 0 <= _(o, t.id) || !s && t.id === o);
    } else if (null != a) {
      const l = L(a);i = M(r, t => l && 0 <= _(a, t.name) || !l && t.name === a);
    } else i = r.slice();return oh(i, t);
  }, findComponents(t) {
    let e; let i; let n; let o; let a; const r = t.query; const s = t.mainType; const l = (i = `${s}Index`, n = `${s}Id`, o = `${s}Name`, !(e = r) || null == e[i] && null == e[n] && null == e[o] ? null : { mainType: s, index: e[i], id: e[n], name: e[o] }); const u = l ? this.queryComponents(l) : this._componentsMap.get(s);return a = oh(u, t), t.filter ? M(a, t.filter) : a;
  }, eachComponent(t, n, o) {
    const e = this._componentsMap;if ('function' === typeof t)o = n, n = t, e.each((t, i) => {
      R(t, (t, e) => {
        n.call(o, i, t, e);
      });
    });else if (E(t))R(e.get(t), n, o);else if (z(t)) {
      R(this.findComponents(t), n, o);
    }
  }, getSeriesByName(e) {
    return M(this._componentsMap.get('series'), t => t.name === e);
  }, getSeriesByIndex(t) {
    return this._componentsMap.get('series')[t];
  }, getSeriesByType(e) {
    return M(this._componentsMap.get('series'), t => t.subType === e);
  }, getSeries() {
    return this._componentsMap.get('series').slice();
  }, getSeriesCount() {
    return this._componentsMap.get('series').length;
  }, eachSeries(i, n) {
    R(this._seriesIndices, function (t) {
      const e = this._componentsMap.get('series')[t];i.call(n, e, t);
    }, this);
  }, eachRawSeries(t, e) {
    R(this._componentsMap.get('series'), t, e);
  }, eachSeriesByType(i, n, o) {
    R(this._seriesIndices, function (t) {
      const e = this._componentsMap.get('series')[t];e.subType === i && n.call(o, e, t);
    }, this);
  }, eachRawSeriesByType(t, e, i) {
    return R(this.getSeriesByType(t), e, i);
  }, isSeriesFiltered(t) {
    return null == this._seriesIndicesMap.get(t.componentIndex);
  }, getCurrentSeriesIndices() {
    return (this._seriesIndices || []).slice();
  }, filterSeries(t, e) {
    const i = M(this._componentsMap.get('series'), t, e);nh(this, i);
  }, restoreData(i) {
    const n = this._componentsMap;nh(this, n.get('series'));const o = [];n.each((t, e) => {
      o.push(e);
    }), ku.topologicalTravel(o, ku.getAllClassMainTypes(), (e, t) => {
      R(n.get(e), (t) => {
        'series' === e && (function (t, e) {
          if (e) {
            const i = e.seiresIndex; const n = e.seriesId; const o = e.seriesName;return null != i && t.componentIndex !== i || null != n && t.id !== n || null != o && t.name !== o;
          }
        }(t, i)) || t.restoreData();
      });
    });
  } });function nh(t, e) {
    t._seriesIndicesMap = Q(t._seriesIndices = O(e, t => t.componentIndex) || []);
  } function oh(t, e) {
    return e.hasOwnProperty('subType') ? M(t, t => t.subType === e.subType) : t;
  }b(ih, Eu);const ah = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getViewOfComponentModel', 'getViewOfSeriesModel'];function rh(e) {
    R(ah, function (t) {
      this[t] = A(e[t], e);
    }, this);
  } const sh = {};function lh() {
    this._coordinateSystems = [];
  }lh.prototype = { constructor: lh, create(n, o) {
    let a = [];R(sh, (t, e) => {
      const i = t.create(n, o);a = a.concat(i || []);
    }), this._coordinateSystems = a;
  }, update(e, i) {
    R(this._coordinateSystems, (t) => {
      t.update && t.update(e, i);
    });
  }, getCoordinateSystems() {
    return this._coordinateSystems.slice();
  } }, lh.register = function (t, e) {
    sh[t] = e;
  }, lh.get = function (t) {
    return sh[t];
  };const uh = R; const hh = k; const ch = O; const dh = m; const fh = /^(min|max)?(.+)$/;function ph(t) {
    this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newBaseOption;
  } function gh(t, e, i) {
    const a = { width: e, height: i, aspectratio: e / i }; let r = !0;return R(t, (t, e) => {
      const i = e.match(fh);if (i && i[1] && i[2]) {
        const n = i[1]; const o = i[2].toLowerCase();!(function (t, e, i) {
          return 'min' === i ? e <= t : 'max' === i ? t <= e : t === e;
        }(a[o], t, n)) && (r = !1);
      }
    }), r;
  }ph.prototype = { constructor: ph, setOption(t, e) {
    t && R(Vo(t.series), (t) => {
      t && t.data && V(t.data) && K(t.data);
    }), t = hh(t);const i = this._optionBackup; const n = function (t, i, n) {
      let e; let o; let a = []; const r = []; const s = t.timeline;t.baseOption && (o = t.baseOption);(s || t.options) && (o = o || {}, a = (t.options || []).slice());if (t.media) {
        o = o || {};const l = t.media;uh(l, (t) => {
          t && t.option && (t.query ? r.push(t) : e = e || t);
        });
      }o = o || t;o.timeline || (o.timeline = s);return uh([o].concat(a).concat(O(r, t => t.option)), (e) => {
        uh(i, (t) => {
          t(e, n);
        });
      }), { baseOption: o, timelineOptions: a, mediaDefault: e, mediaList: r };
    }.call(this, t, e, !i);this._newBaseOption = n.baseOption, i ? ((function (o, t) {
      uh(t = t || {}, (t, e) => {
        if (null != t) {
          let i = o[e];if (ku.hasClass(e)) {
            t = Vo(t);const n = Ho(i = Vo(i), t);o[e] = ch(n, t => (t.option && t.exist ? dh(t.exist, t.option, !0) : t.exist || t.option));
          } else o[e] = dh(i, t, !0);
        }
      });
    }(i.baseOption, n.baseOption)), n.timelineOptions.length && (i.timelineOptions = n.timelineOptions), n.mediaList.length && (i.mediaList = n.mediaList), n.mediaDefault && (i.mediaDefault = n.mediaDefault)) : this._optionBackup = n;
  }, mountOption(t) {
    const e = this._optionBackup;return this._timelineOptions = ch(e.timelineOptions, hh), this._mediaList = ch(e.mediaList, hh), this._mediaDefault = hh(e.mediaDefault), this._currentMediaIndices = [], hh(t ? e.baseOption : this._newBaseOption);
  }, getTimelineOption(t) {
    let e; const i = this._timelineOptions;if (i.length) {
      const n = t.getComponent('timeline');n && (e = hh(i[n.getCurrentIndex()], !0));
    } return e;
  }, getMediaOption(t) {
    const e = this._api.getWidth(); const i = this._api.getHeight(); const n = this._mediaList; const o = this._mediaDefault; let a = []; let r = [];if (!n.length && !o) return r;for (let s = 0, l = n.length;s < l;s++)gh(n[s].query, e, i) && a.push(s);return !a.length && o && (a = [-1]), a.length && !(function (t, e) {
      return t.join(',') === e.join(',');
    }(a, this._currentMediaIndices)) && (r = ch(a, t => hh(-1 === t ? o.option : n[t].option))), this._currentMediaIndices = a, r;
  } };const mh = R; const vh = z; const yh = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];function xh(t) {
    const e = t && t.itemStyle;if (e) for (let i = 0, n = yh.length;i < n;i++) {
      const o = yh[i]; const a = e.normal; const r = e.emphasis;a && a[o] && (t[o] = t[o] || {}, t[o].normal ? m(t[o].normal, a[o]) : t[o].normal = a[o], a[o] = null), r && r[o] && (t[o] = t[o] || {}, t[o].emphasis ? m(t[o].emphasis, r[o]) : t[o].emphasis = r[o], r[o] = null);
    }
  } function _h(t, e, i) {
    if (t && t[e] && (t[e].normal || t[e].emphasis)) {
      const n = t[e].normal; const o = t[e].emphasis;n && (i ? (t[e].normal = t[e].emphasis = null, D(t[e], n)) : t[e] = n), o && (t.emphasis = t.emphasis || {}, t.emphasis[e] = o);
    }
  } function wh(t) {
    _h(t, 'itemStyle'), _h(t, 'lineStyle'), _h(t, 'areaStyle'), _h(t, 'label'), _h(t, 'labelLine'), _h(t, 'upperLabel'), _h(t, 'edgeLabel');
  } function bh(t, e) {
    const i = vh(t) && t[e]; const n = vh(i) && i.textStyle;if (n) for (let o = 0, a = Fo.length;o < a;o++) {
      e = Fo[o];n.hasOwnProperty(e) && (i[e] = n[e]);
    }
  } function Sh(t) {
    t && (wh(t), bh(t, 'label'), t.emphasis && bh(t.emphasis, 'label'));
  } function Mh(t) {
    return L(t) ? t : t ? [t] : [];
  } function Ih(t) {
    return (L(t) ? t[0] : t) || {};
  } function Th(e, t) {
    mh(Mh(e.series), (t) => {
      vh(t) && (function (t) {
        if (vh(t)) {
          xh(t), wh(t), bh(t, 'label'), bh(t, 'upperLabel'), bh(t, 'edgeLabel'), t.emphasis && (bh(t.emphasis, 'label'), bh(t.emphasis, 'upperLabel'), bh(t.emphasis, 'edgeLabel')), (i = t.markPoint) && (xh(i), Sh(i)), (n = t.markLine) && (xh(n), Sh(n));const e = t.markArea;e && Sh(e);let i; let n; let o = t.data;if ('graph' === t.type) {
            o = o || t.nodes;const a = t.links || t.edges;if (a && !V(a)) for (var r = 0;r < a.length;r++)Sh(a[r]);R(t.categories, (t) => {
              wh(t);
            });
          } if (o && !V(o)) for (r = 0;r < o.length;r++)Sh(o[r]);if ((i = t.markPoint) && i.data) {
            const s = i.data;for (r = 0;r < s.length;r++)Sh(s[r]);
          } if ((n = t.markLine) && n.data) {
            const l = n.data;for (r = 0;r < l.length;r++)L(l[r]) ? (Sh(l[r][0]), Sh(l[r][1])) : Sh(l[r]);
          }'gauge' === t.type ? (bh(t, 'axisLabel'), bh(t, 'title'), bh(t, 'detail')) : 'treemap' === t.type ? (_h(t.breadcrumb, 'itemStyle'), R(t.levels, (t) => {
            wh(t);
          })) : 'tree' === t.type && wh(t.leaves);
        }
      }(t));
    });const i = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];t && i.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis'), mh(i, (t) => {
      mh(Mh(e[t]), (t) => {
        t && (bh(t, 'axisLabel'), bh(t.axisPointer, 'label'));
      });
    }), mh(Mh(e.parallel), (t) => {
      const e = t && t.parallelAxisDefault;bh(e, 'axisLabel'), bh(e && e.axisPointer, 'label');
    }), mh(Mh(e.calendar), (t) => {
      _h(t, 'itemStyle'), bh(t, 'dayLabel'), bh(t, 'monthLabel'), bh(t, 'yearLabel');
    }), mh(Mh(e.radar), (t) => {
      bh(t, 'name');
    }), mh(Mh(e.geo), (t) => {
      vh(t) && (Sh(t), mh(Mh(t.regions), (t) => {
        Sh(t);
      }));
    }), mh(Mh(e.timeline), (t) => {
      Sh(t), _h(t, 'label'), _h(t, 'itemStyle'), _h(t, 'controlStyle', !0);const e = t.data;L(e) && R(e, (t) => {
        z(t) && (_h(t, 'label'), _h(t, 'itemStyle'));
      });
    }), mh(Mh(e.toolbox), (t) => {
      _h(t, 'iconStyle'), mh(t.feature, (t) => {
        _h(t, 'iconStyle');
      });
    }), bh(Ih(e.axisPointer), 'label'), bh(Ih(e.tooltip).axisPointer, 'label');
  } function Ah(e) {
    R(Dh, (t) => {
      t[0] in e && !(t[1] in e) && (e[t[1]] = e[t[0]]);
    });
  } var Dh = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']]; const Ch = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline']; const Lh = function (i, t) {
    Th(i, t), i.series = Vo(i.series), R(i.series, (t) => {
      if (z(t)) {
        const e = t.type;if ('line' === e)null != t.clipOverflow && (t.clip = t.clipOverflow);else if ('pie' === e || 'gauge' === e)null != t.clockWise && (t.clockwise = t.clockWise);else if ('gauge' === e) {
          const i = (function (t, e) {
            e = e.split(',');for (var i = t, n = 0;n < e.length && null != (i = i && i[e[n]]);n++);return i;
          }(t, 'pointer.color'));null != i && (function (t, e, i, n) {
            e = e.split(',');for (var o, a = t, r = 0;r < e.length - 1;r++)null == a[o = e[r]] && (a[o] = {}), a = a[o];!n && null != a[e[r]] || (a[e[r]] = i);
          }(t, 'itemStyle.color', i));
        }Ah(t);
      }
    }), i.dataRange && (i.visualMap = i.dataRange), R(Ch, (t) => {
      let e = i[t];e && (L(e) || (e = [e]), R(e, (t) => {
        Ah(t);
      }));
    });
  };function kh(m) {
    R(m, (h, c) => {
      const d = []; const f = [NaN, NaN]; const t = [h.stackResultDimension, h.stackedOverDimension]; const p = h.data; const g = h.isStackedByIndex; const e = p.map(t, (t, e, i) => {
        let n; let o; let a = p.get(h.stackedDimension, i);if (isNaN(a)) return f;g ? o = p.getRawIndex(i) : n = p.get(h.stackedByDimension, i);for (var r = NaN, s = c - 1;0 <= s;s--) {
          const l = m[s];if (g || (o = l.data.rawIndexOf(l.stackedByDimension, n)), 0 <= o) {
            const u = l.data.getByRawIndex(l.stackResultDimension, o);if (0 <= a && 0 < u || a <= 0 && u < 0) {
              a += u, r = u;break;
            }
          }
        } return d[0] = a, d[1] = r, d;
      });p.hostModel.setData(e), h.data = e;
    });
  } function Ph(t, e) {
    Uu.isInstance(t) || (t = Uu.seriesDataToSource(t)), this._source = t;const i = this._data = t.data; const n = t.sourceFormat;n === Wu && (this._offset = 0, this._dimSize = e, this._data = i), P(this, Oh[n === Bu ? `${n}_${t.seriesLayoutBy}` : n]);
  } const Nh = Ph.prototype;Nh.pure = !1;var Oh = { arrayRows_column: { pure: Nh.persistent = !0, count() {
    return Math.max(0, this._data.length - this._source.startIndex);
  }, getItem(t) {
    return this._data[t + this._source.startIndex];
  }, appendData: zh }, arrayRows_row: { pure: !0, count() {
    const t = this._data[0];return t ? Math.max(0, t.length - this._source.startIndex) : 0;
  }, getItem(t) {
    t += this._source.startIndex;for (var e = [], i = this._data, n = 0;n < i.length;n++) {
      const o = i[n];e.push(o ? o[t] : null);
    } return e;
  }, appendData() {
    throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
  } }, objectRows: { pure: !0, count: Rh, getItem: Eh, appendData: zh }, keyedColumns: { pure: !0, count() {
    const t = this._source.dimensionsDefine[0].name; const e = this._data[t];return e ? e.length : 0;
  }, getItem(t) {
    for (var e = [], i = this._source.dimensionsDefine, n = 0;n < i.length;n++) {
      const o = this._data[i[n].name];e.push(o ? o[t] : null);
    } return e;
  }, appendData(t) {
    const o = this._data;R(t, (t, e) => {
      for (let i = o[e] || (o[e] = []), n = 0;n < (t || []).length;n++)i.push(t[n]);
    });
  } }, original: { count: Rh, getItem: Eh, appendData: zh }, typedArray: { persistent: !(Nh.getSource = function () {
    return this._source;
  }), pure: !0, count() {
    return this._data ? this._data.length / this._dimSize : 0;
  }, getItem(t, e) {
    t -= this._offset, e = e || [];for (let i = this._dimSize * t, n = 0;n < this._dimSize;n++)e[n] = this._data[i + n];return e;
  }, appendData(t) {
    this._data = t;
  }, clean() {
    this._offset += this.count(), this._data = null;
  } } };function Rh() {
    return this._data.length;
  } function Eh(t) {
    return this._data[t];
  } function zh(t) {
    for (let e = 0;e < t.length;e++) this._data.push(t[e]);
  } const Bh = { arrayRows: Vh, objectRows(t, e, i, n) {
    return null != i ? t[n] : t;
  }, keyedColumns: Vh, original(t, e, i, n) {
    const o = Wo(t);return null != i && o instanceof Array ? o[i] : o;
  }, typedArray: Vh };function Vh(t, e, i, n) {
    return null != i ? t[i] : t;
  } const Gh = { arrayRows: Fh, objectRows(t, e, i, n) {
    return Wh(t[e], this._dimensionInfos[e]);
  }, keyedColumns: Fh, original(t, e, i, n) {
    const o = t && (null == t.value ? t : t.value);return !this._rawData.pure && (function (t) {
      return Eo(t) && !(t instanceof Array);
    }(t)) && (this.hasItemOption = !0), Wh(o instanceof Array ? o[n] : o, this._dimensionInfos[e]);
  }, typedArray(t, e, i, n) {
    return t[n];
  } };function Fh(t, e, i, n) {
    return Wh(t[n], this._dimensionInfos[e]);
  } function Wh(t, e) {
    const i = e && e.type;if ('ordinal' !== i) return 'time' === i && 'number' !== typeof t && null != t && '-' !== t && (t = +Yl(t)), null == t || '' === t ? NaN : +t;const n = e && e.ordinalMeta;return n ? n.parseAndCollect(t) : t;
  } function Hh(t, e, i) {
    if (t) {
      const n = t.getRawDataItem(e);if (null != n) {
        let o; let a; const r = t.getProvider().getSource().sourceFormat; const s = t.getDimensionInfo(i);return s && (o = s.name, a = s.index), Bh[r](n, e, a, o);
      }
    }
  } function Zh(t, e, i) {
    if (t) {
      const n = t.getProvider().getSource().sourceFormat;if (n === zu || n === Vu) {
        let o = t.getRawDataItem(e);return n !== zu || z(o) || (o = null), o ? o[i] : void 0;
      }
    }
  } const Uh = /\{@(.+?)\}/g; const Xh = { getDataParams(t, e) {
    const i = this.getData(e); const n = this.getRawValue(t, e); const o = i.getRawIndex(t); const a = i.getName(t); const r = i.getRawDataItem(t); const s = i.getItemVisual(t, 'color'); const l = i.getItemVisual(t, 'borderColor'); const u = this.ecModel.getComponent('tooltip'); const h = Qo(u && u.get('renderMode')); const c = this.mainType; const d = 'series' === c; const f = i.userOutput;return { componentType: c, componentSubType: this.subType, componentIndex: this.componentIndex, seriesType: d ? this.subType : null, seriesIndex: this.seriesIndex, seriesId: d ? this.id : null, seriesName: d ? this.name : null, name: a, dataIndex: o, data: r, dataType: e, value: n, color: s, borderColor: l, dimensionNames: f ? f.dimensionNames : null, encode: f ? f.encode : null, marker: hu({ color: s, renderMode: h }), $vars: ['seriesName', 'name', 'value'] };
  }, getFormattedLabel(n, t, e, i, o) {
    t = t || 'normal';const a = this.getData(e); const r = a.getItemModel(n); const s = this.getDataParams(n, e);null != i && s.value instanceof Array && (s.value = s.value[i]);const l = r.get('normal' === t ? [o || 'label', 'formatter'] : [t, o || 'label', 'formatter']);return 'function' === typeof l ? (s.status = t, s.dimensionIndex = i, l(s)) : 'string' === typeof l ? lu(l, s).replace(Uh, (t, e) => {
      const i = e.length;return '[' === e.charAt(0) && ']' === e.charAt(i - 1) && (e = +e.slice(1, i - 1)), Hh(a, n, e);
    }) : void 0;
  }, getRawValue(t, e) {
    return Hh(this.getData(e), t);
  }, formatTooltip() {} };function Yh(t) {
    return new jh(t);
  } function jh(t) {
    t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0, this.context;
  } const qh = jh.prototype;qh.perform = function (t) {
    let e; const i = this._upstream; const n = t && t.skip;if (this._dirty && i) {
      const o = this.context;o.data = o.outputData = i.context.outputData;
    } this.__pipeline && (this.__pipeline.currentTask = this), this._plan && !n && (e = this._plan(this.context));let a; const r = h(this._modBy); const s = this._modDataCount || 0; const l = h(t && t.modBy); const u = t && t.modDataCount || 0;function h(t) {
      return 1 <= t || (t = 1), t;
    }r === l && s === u || (e = 'reset'), !this._dirty && 'reset' !== e || (this._dirty = !1, a = (function (t, e) {
      let i; let n;t._dueIndex = t._outputDueEnd = t._dueEnd = 0, t._settedOutputEnd = null, !e && t._reset && ((i = t._reset(t.context)) && i.progress && (n = i.forceFirstProgress, i = i.progress), L(i) && !i.length && (i = null));t._progress = i, t._modBy = t._modDataCount = null;const o = t._downstream;return o && o.dirty(), n;
    }(this, n))), this._modBy = l, this._modDataCount = u;const c = t && t.step;if (this._dueEnd = i ? i._outputDueEnd : this._count ? this._count(this.context) : 1 / 0, this._progress) {
      const d = this._dueIndex; const f = Math.min(null != c ? this._dueIndex + c : 1 / 0, this._dueEnd);if (!n && (a || d < f)) {
        const p = this._progress;if (L(p)) for (let g = 0;g < p.length;g++)ac(this, p[g], d, f, l, u);else ac(this, p, d, f, l, u);
      } this._dueIndex = f;const m = null != this._settedOutputEnd ? this._settedOutputEnd : f;this._outputDueEnd = m;
    } else this._dueIndex = this._outputDueEnd = null != this._settedOutputEnd ? this._settedOutputEnd : this._dueEnd;return this.unfinished();
  };let Kh; let $h; let Jh; let Qh; let tc; let ec; const ic = ec = { reset(t, e, i, n) {
    $h = t, Kh = e, Jh = i, Qh = n, tc = Math.ceil(Qh / Jh), ec.next = 1 < Jh && 0 < Qh ? oc : nc;
  } };function nc() {
    return $h < Kh ? $h++ : null;
  } function oc() {
    const t = $h % tc * Jh + Math.ceil($h / tc); const e = Kh <= $h ? null : t < Qh ? t : $h;return $h++, e;
  } function ac(t, e, i, n, o, a) {
    ic.reset(i, n, o, a), t._callingProgress = e, t._callingProgress({ start: i, end: n, count: n - i, next: ic.next }, t.context);
  }qh.dirty = function () {
    this._dirty = !0, this._onDirty && this._onDirty(this.context);
  }, qh.unfinished = function () {
    return this._progress && this._dueIndex < this._dueEnd;
  }, qh.pipe = function (t) {
    this._downstream === t && !this._dirty || ((this._downstream = t)._upstream = this, t.dirty());
  }, qh.dispose = function () {
    this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
  }, qh.getUpstream = function () {
    return this._upstream;
  }, qh.getDownstream = function () {
    return this._downstream;
  }, qh.setOutputEnd = function (t) {
    this._outputDueEnd = this._settedOutputEnd = t;
  };const rc = jo(); const sc = ku.extend({ type: 'series.__base__', seriesIndex: 0, coordinateSystem: null, defaultOption: null, legendVisualProvider: null, visualColorAccessPath: 'itemStyle.color', visualBorderColorAccessPath: 'itemStyle.borderColor', layoutMode: null, init(t, e, i, n) {
    this.seriesIndex = this.componentIndex, this.dataTask = Yh({ count: uc, reset: hc }), this.dataTask.context = { model: this }, this.mergeDefaultAndTheme(t, i), ju(this);const o = this.getInitialData(t, i);dc(o, this), this.dataTask.context.data = o, rc(this).dataBeforeProcessed = o, lc(this);
  }, mergeDefaultAndTheme(t, e) {
    const i = this.layoutMode; const n = i ? Iu(t) : {}; let o = this.subType;ku.hasClass(o) && (o += 'Series'), m(t, e.getTheme().get(this.subType)), m(t, this.getDefaultOption()), Go(t, 'label', ['show']), this.fillDataTextStyle(t.data), i && Mu(t, n, i);
  }, mergeOption(t, e) {
    t = m(this.option, t, !0), this.fillDataTextStyle(t.data);const i = this.layoutMode;i && Mu(this.option, t, i), ju(this);const n = this.getInitialData(t, e);dc(n, this), this.dataTask.dirty(), this.dataTask.context.data = n, rc(this).dataBeforeProcessed = n, lc(this);
  }, fillDataTextStyle(t) {
    if (t && !V(t)) for (let e = ['show'], i = 0;i < t.length;i++)t[i] && t[i].label && Go(t[i], 'label', e);
  }, getInitialData() {}, appendData(t) {
    this.getRawData().appendData(t.data);
  }, getData(t) {
    const e = pc(this);if (e) {
      const i = e.context.data;return null == t ? i : i.getLinkedData(t);
    } return rc(this).data;
  }, setData(t) {
    const e = pc(this);if (e) {
      const i = e.context;i.data !== t && e.modifyOutputEnd && e.setOutputEnd(t.count()), i.outputData = t, e !== this.dataTask && (i.data = t);
    }rc(this).data = t;
  }, getSource() {
    return (function (t) {
      return Yu(t).source;
    }(this));
  }, getRawData() {
    return rc(this).dataBeforeProcessed;
  }, getBaseAxis() {
    const t = this.coordinateSystem;return t && t.getBaseAxis && t.getBaseAxis();
  }, formatTooltip(o, h, t, c) {
    const d = this; const e = 'html' === (c = c || 'html') ? '<br/>' : '\n'; const f = 'richText' === c; const p = {}; let g = 0;function i(t) {
      return { renderMode: c, content: au(tu(t)), style: p };
    } const m = this.getData(); const a = m.mapDimension('defaultedTooltip', !0); const n = a.length; const r = this.getRawValue(o); const s = L(r); let v = m.getItemVisual(o, 'color');z(v) && v.colorStops && (v = (v.colorStops[0] || {}).color), v = v || 'transparent';const l = (1 < n || s && !n ? (function (t) {
      const l = S(t, (t, e, i) => {
        const n = m.getDimensionInfo(i);return t | (n && !1 !== n.tooltip && null != n.displayName);
      }, 0); const u = [];function e(t, e) {
        const i = m.getDimensionInfo(e);if (i && !1 !== i.otherDims.tooltip) {
          const n = i.type; const o = `sub${d.seriesIndex}at${g}`; const a = hu({ color: v, type: 'subItem', renderMode: c, markerId: o }); const r = 'string' === typeof a ? a : a.content; const s = (l ? `${r + au(i.displayName || '-')}: ` : '') + au('ordinal' === n ? `${t}` : 'time' === n ? h ? '' : du('yyyy/MM/dd hh:mm:ss', t) : tu(t));s && u.push(s), f && (p[o] = v, ++g);
        }
      }a.length ? R(a, (t) => {
        e(Hh(m, o, t), t);
      }) : R(t, e);const i = l ? f ? '\n' : '<br/>' : ''; const n = i + u.join(i || ', ');return { renderMode: c, content: n, style: p };
    }(r)) : i(n ? Hh(m, o, a[0]) : s ? r[0] : r)).content; const u = `${d.seriesIndex}at${g}`; const y = hu({ color: v, type: 'item', renderMode: c, markerId: u });p[u] = v, ++g;const x = m.getName(o); let _ = this.name;Uo(this) || (_ = ''), _ = _ ? au(_) + (h ? ': ' : e) : '';const w = 'string' === typeof y ? y : y.content;return { html: h ? w + _ + l : _ + w + (x ? `${au(x)}: ${l}` : l), markers: p };
  }, isAnimationEnabled() {
    if (v.node) return !1;let t = this.getShallow('animation');return t && this.getData().count() > this.getShallow('animationThreshold') && (t = !1), t;
  }, restoreData() {
    this.dataTask.dirty();
  }, getColorFromPalette(t, e, i) {
    const n = this.ecModel; let o = Eu.getColorFromPalette.call(this, t, e, i);return o = o || n.getColorFromPalette(t, e, i);
  }, coordDimToDataDim(t) {
    return this.getRawData().mapDimension(t, !0);
  }, getProgressive() {
    return this.get('progressive');
  }, getProgressiveThreshold() {
    return this.get('progressiveThreshold');
  }, getAxisTooltipData: null, getTooltipPosition: null, pipeTask: null, preventIncremental: null, pipelineContext: null });function lc(t) {
    const e = t.name;Uo(t) || (t.name = (function (t) {
      const i = t.getRawData(); const e = i.mapDimension('seriesName', !0); const n = [];return R(e, (t) => {
        const e = i.getDimensionInfo(t);e.displayName && n.push(e.displayName);
      }), n.join(' ');
    }(t)) || e);
  } function uc(t) {
    return t.model.getRawData().count();
  } function hc(t) {
    const e = t.model;return e.setData(e.getRawData().cloneShallow()), cc;
  } function cc(t, e) {
    e.outputData && t.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData);
  } function dc(e, i) {
    R(e.CHANGABLE_METHODS, (t) => {
      e.wrapMethod(t, T(fc, i));
    });
  } function fc(t) {
    const e = pc(t);e && e.setOutputEnd(this.count());
  } function pc(t) {
    const e = (t.ecModel || {}).scheduler; const i = e && e.getPipeline(t.uid);if (i) {
      let n = i.currentTask;if (n) {
        const o = n.agentStubMap;o && (n = o.get(t.uid));
      } return n;
    }
  }b(sc, Xh), b(sc, Eu);const gc = function () {
    this.group = new Ci, this.uid = Nl('viewComponent');
  };gc.prototype = { constructor: gc, init(t, e) {}, render(t, e, i, n) {}, dispose() {}, filterForExposedEvent: null };const mc = gc.prototype;mc.updateView = mc.updateLayout = mc.updateVisual = function (t, e, i, n) {}, oa(gc), ua(gc, { registerWhenExtend: !0 });function vc() {
    const s = jo();return function (t) {
      const e = s(t); const i = t.pipelineContext; const n = e.large; const o = e.progressiveRender; const a = e.large = i && i.large; const r = e.progressiveRender = i && i.progressiveRender;return !!(n ^ a || o ^ r) && 'reset';
    };
  } const yc = jo(); const xc = vc();function _c() {
    this.group = new Ci, this.uid = Nl('viewChart'), this.renderTask = Yh({ plan: Mc, reset: Ic }), this.renderTask.context = { view: this };
  } const wc = _c.prototype = { type: 'chart', init(t, e) {}, render(t, e, i, n) {}, highlight(t, e, i, n) {
    Sc(t.getData(), n, 'emphasis');
  }, downplay(t, e, i, n) {
    Sc(t.getData(), n, 'normal');
  }, remove(t, e) {
    this.group.removeAll();
  }, dispose() {}, incrementalPrepareRender: null, incrementalRender: null, updateTransform: null, filterForExposedEvent: null };function bc(t, e, i) {
    if (t && (t.trigger(e, i), t.isGroup && !Qs(t))) for (let n = 0, o = t.childCount();n < o;n++)bc(t.childAt(n), e, i);
  } function Sc(e, t, i) {
    const n = Yo(e, t); const o = t && null != t.highlightKey ? tl(t.highlightKey) : null;null != n ? R(Vo(n), (t) => {
      bc(e.getItemGraphicEl(t), i, o);
    }) : e.eachItemGraphicEl((t) => {
      bc(t, i, o);
    });
  } function Mc(t) {
    return xc(t.model);
  } function Ic(t) {
    const e = t.model; const i = t.ecModel; const n = t.api; const o = t.payload; const a = e.pipelineContext.progressiveRender; const r = t.view; const s = o && yc(o).updateMethod; const l = a ? 'incrementalPrepareRender' : s && r[s] ? s : 'render';return 'render' !== l && r[l](e, i, n, o), Tc[l];
  }wc.updateView = wc.updateLayout = wc.updateVisual = function (t, e, i, n) {
    this.render(t, e, i, n);
  }, oa(_c), ua(_c, { registerWhenExtend: !0 }), _c.markUpdateMethod = function (t, e) {
    yc(t).updateMethod = e;
  };var Tc = { incrementalPrepareRender: { progress(t, e) {
    e.view.incrementalRender(t, e.model, e.ecModel, e.api, e.payload);
  } }, render: { forceFirstProgress: !0, progress(t, e) {
    e.view.render(e.model, e.ecModel, e.api, e.payload);
  } } }; const Ac = '\0__throttleOriginMethod'; const Dc = '\0__throttleRate'; const Cc = '\0__throttleType';function Lc(t, i, n) {
    let o; let a; let r; let s; let l; let u = 0; let h = 0; let c = null;function d() {
      h = (new Date).getTime(), c = null, t.apply(r, s || []);
    }i = i || 0;function e() {
      o = (new Date).getTime(), r = this, s = arguments;const t = l || i; const e = l || n;l = null, a = o - (e ? u : h) - t, clearTimeout(c), e ? c = setTimeout(d, t) : 0 <= a ? d() : c = setTimeout(d, -a), u = o;
    } return e.clear = function () {
      c && (clearTimeout(c), c = null);
    }, e.debounceNextCall = function (t) {
      l = t;
    }, e;
  } function kc(t, e, i, n) {
    let o = t[e];if (o) {
      const a = o[Ac] || o; const r = o[Cc];if (o[Dc] !== i || r !== n) {
        if (null == i || !n) return t[e] = a;(o = t[e] = Lc(a, i, 'debounce' === n))[Ac] = a, o[Cc] = n, o[Dc] = i;
      } return o;
    }
  } function Pc(t, e) {
    const i = t[e];i && i[Ac] && (t[e] = i[Ac]);
  } const Nc = { createOnAllSeries: !0, performRawSeries: !0, reset(e, t) {
    const i = e.getData(); const a = (e.visualColorAccessPath || 'itemStyle.color').split('.'); let n = e.get(a); const o = !C(n) || n instanceof cs ? null : n;n && !o || (n = e.getColorFromPalette(e.name, null, t.getSeriesCount())), i.setVisual('color', n);const r = (e.visualBorderColorAccessPath || 'itemStyle.borderColor').split('.'); const s = e.get(r);if (i.setVisual('borderColor', s), !t.isSeriesFiltered(e)) {
      o && i.each((t) => {
        i.setItemVisual(t, 'color', o(e.getDataParams(t)));
      });return { dataEach: i.hasItemOption ? function (t, e) {
        const i = t.getItemModel(e); const n = i.get(a, !0); const o = i.get(r, !0);null != n && t.setItemVisual(e, 'color', n), null != o && t.setItemVisual(e, 'borderColor', o);
      } : null };
    }
  } }; const Oc = { legend: { selector: { all: '全选', inverse: '反选' } }, toolbox: { brush: { title: { rect: '矩形选择', polygon: '圈选', lineX: '横向选择', lineY: '纵向选择', keep: '保持选择', clear: '清除选择' } }, dataView: { title: '数据视图', lang: ['数据视图', '关闭', '刷新'] }, dataZoom: { title: { zoom: '区域缩放', back: '区域缩放还原' } }, magicType: { title: { line: '切换为折线图', bar: '切换为柱状图', stack: '切换为堆叠', tiled: '切换为平铺' } }, restore: { title: '还原' }, saveAsImage: { title: '保存为图片', lang: ['右键另存为图片'] } }, series: { typeNames: { pie: '饼图', bar: '柱状图', line: '折线图', scatter: '散点图', effectScatter: '涟漪散点图', radar: '雷达图', tree: '树图', treemap: '矩形树图', boxplot: '箱型图', candlestick: 'K线图', k: 'K线图', heatmap: '热力图', map: '地图', parallel: '平行坐标图', lines: '线图', graph: '关系图', sankey: '桑基图', funnel: '漏斗图', gauge: '仪表盘图', pictorialBar: '象形柱图', themeRiver: '主题河流图', sunburst: '旭日图' } }, aria: { general: { withTitle: '这是一个关于“{title}”的图表。', withoutTitle: '这是一个图表，' }, series: { single: { prefix: '', withName: '图表类型是{seriesType}，表示{seriesName}。', withoutName: '图表类型是{seriesType}。' }, multiple: { prefix: '它由{seriesCount}个图表系列组成。', withName: '第{seriesId}个系列是一个表示{seriesName}的{seriesType}，', withoutName: '第{seriesId}个系列是一个{seriesType}，', separator: { middle: '；', end: '。' } } }, data: { allData: '其数据是——', partialData: '其中，前{displayCnt}项是——', withName: '{name}的数据是{value}', withoutName: '{value}', separator: { middle: '，', end: '' } } } }; const Rc = function (t, e) {
    const a = e.getModel('aria');if (a.get('show')) if (a.get('description'))t.setAttribute('aria-label', a.get('description'));else {
      let h = 0;e.eachSeries((t, e) => {
        ++h;
      }, this);let i; const c = a.get('data.maxCount') || 10; const n = a.get('series.maxCount') || 10; const d = Math.min(h, n);if (!(h < 1)) {
        const o = (function () {
          let t = e.getModel('title').option;t && t.length && (t = t[0]);return t && t.text;
        }());i = o ? p(g('general.withTitle'), { title: o }) : g('general.withoutTitle');const f = [];i += p(g(1 < h ? 'series.multiple.prefix' : 'series.single.prefix'), { seriesCount: h }), e.eachSeries((t, e) => {
          if (e < d) {
            let i; const n = t.get('name'); const o = `series.${1 < h ? 'multiple' : 'single'}.`;i = p(i = g(n ? `${o}withName` : `${o}withoutName`), { seriesId: t.seriesIndex, seriesName: t.get('name'), seriesType: (function (t) {
              return Oc.series.typeNames[t] || '自定义图';
            }(t.subType)) });const a = t.getData();(window.data = a).count() > c ? i += p(g('data.partialData'), { displayCnt: c }) : i += g('data.allData');for (var r = [], s = 0;s < a.count();s++) if (s < c) {
              const l = a.getName(s); const u = Hh(a, s);r.push(p(g(l ? 'data.withName' : 'data.withoutName'), { name: l, value: u }));
            }i += r.join(g('data.separator.middle')) + g('data.separator.end'), f.push(i);
          }
        }), i += f.join(g('series.multiple.separator.middle')) + g('series.multiple.separator.end'), t.setAttribute('aria-label', i);
      }
    } function p(t, e) {
      if ('string' !== typeof t) return t;let i = t;return R(e, (t, e) => {
        i = i.replace(new RegExp(`\\{\\s*${e}\\s*\\}`, 'g'), t);
      }), i;
    } function g(t) {
      const e = a.get(t);if (null != e) return e;for (var i = t.split('.'), n = Oc.aria, o = 0;o < i.length;++o)n = n[i[o]];return n;
    }
  }; const Ec = Math.PI;function zc(t, e, i, n) {
    this.ecInstance = t, this.api = e, this.unfinished;i = this._dataProcessorHandlers = i.slice(), n = this._visualHandlers = n.slice();this._allHandlers = i.concat(n), this._stageTaskMap = Q();
  } const Bc = zc.prototype;function Vc(l, t, u, h, c) {
    let d;function f(t, e) {
      return t.setDirty && (!t.dirtyMap || t.dirtyMap.get(e.__pipeline.id));
    }c = c || {}, R(t, (n, t) => {
      if (!c.visualType || c.visualType === n.visualType) {
        const e = l._stageTaskMap.get(n.uid); const i = e.seriesTaskMap; const o = e.overallTask;if (o) {
          let a; const r = o.agentStubMap;r.each((t) => {
            f(c, t) && (t.dirty(), a = !0);
          }), a && o.dirty(), Gc(o, h);const s = l.getPerformArgs(o, c.block);r.each((t) => {
            t.perform(s);
          }), d |= o.perform(s);
        } else i && i.each((t, e) => {
          f(c, t) && t.dirty();const i = l.getPerformArgs(t, c.block);i.skip = !n.performRawSeries && u.isSeriesFiltered(t.context.model), Gc(t, h), d |= t.perform(i);
        });
      }
    }), l.unfinished |= d;
  }Bc.restoreData = function (t, e) {
    t.restoreData(e), this._stageTaskMap.each((t) => {
      const e = t.overallTask;e && e.dirty();
    });
  }, Bc.getPerformArgs = function (t, e) {
    if (t.__pipeline) {
      const i = this._pipelineMap.get(t.__pipeline.id); const n = i.context; const o = !e && i.progressiveEnabled && (!n || n.progressiveRender) && t.__idxInPipeline > i.blockIndex ? i.step : null; const a = n && n.modDataCount;return { step: o, modBy: null != a ? Math.ceil(a / o) : null, modDataCount: a };
    }
  }, Bc.getPipeline = function (t) {
    return this._pipelineMap.get(t);
  }, Bc.updateStreamModes = function (t, e) {
    const i = this._pipelineMap.get(t.uid); const n = t.getData().count(); const o = i.progressiveEnabled && e.incrementalPrepareRender && n >= i.threshold; const a = t.get('large') && n >= t.get('largeThreshold'); const r = 'mod' === t.get('progressiveChunkMode') ? n : null;t.pipelineContext = i.context = { progressiveRender: o, modDataCount: r, large: a };
  }, Bc.restorePipelines = function (t) {
    const n = this; const o = n._pipelineMap = Q();t.eachSeries((t) => {
      const e = t.getProgressive(); const i = t.uid;o.set(i, { id: i, head: null, tail: null, threshold: t.getProgressiveThreshold(), progressiveEnabled: e && !(t.preventIncremental && t.preventIncremental()), blockIndex: -1, step: Math.round(e || 700), count: 0 }), Kc(n, t, t.dataTask);
    });
  }, Bc.prepareStageTasks = function () {
    const i = this._stageTaskMap; const n = this.ecInstance.getModel(); const o = this.api;R(this._allHandlers, function (t) {
      const e = i.get(t.uid) || i.set(t.uid, []);t.reset && (function (n, o, t, a, r) {
        const s = t.seriesTaskMap || (t.seriesTaskMap = Q()); const e = o.seriesType; const i = o.getTargetSeries;o.createOnAllSeries ? a.eachRawSeries(l) : e ? a.eachRawSeriesByType(e, l) : i && i(a, r).each(l);function l(t) {
          const e = t.uid; const i = s.get(e) || s.set(e, Yh({ plan: Uc, reset: Xc, count: qc }));i.context = { model: t, ecModel: a, api: r, useClearVisual: o.isVisual && !o.isLayout, plan: o.plan, reset: o.reset, scheduler: n }, Kc(n, t, i);
        } const u = n._pipelineMap;s.each((t, e) => {
          u.get(e) || (t.dispose(), s.removeKey(e));
        });
      }(this, t, e, n, o)), t.overallReset && (function (n, t, e, i, o) {
        const a = e.overallTask = e.overallTask || Yh({ reset: Fc });a.context = { ecModel: i, api: o, overallReset: t.overallReset, scheduler: n };const r = a.agentStubMap = a.agentStubMap || Q(); const s = t.seriesType; const l = t.getTargetSeries; let u = !0; const h = t.modifyOutputEnd;s ? i.eachRawSeriesByType(s, c) : l ? l(i, o).each(c) : (u = !1, R(i.getSeries(), c));function c(t) {
          const e = t.uid; let i = r.get(e);i || (i = r.set(e, Yh({ reset: Wc, onDirty: Zc })), a.dirty()), i.context = { model: t, overallProgress: u, modifyOutputEnd: h }, i.agent = a, i.__block = u, Kc(n, t, i);
        } const d = n._pipelineMap;r.each((t, e) => {
          d.get(e) || (t.dispose(), a.dirty(), r.removeKey(e));
        });
      }(this, t, e, n, o));
    }, this);
  }, Bc.prepareView = function (t, e, i, n) {
    const o = t.renderTask; const a = o.context;a.model = e, a.ecModel = i, a.api = n, o.__block = !t.incrementalPrepareRender, Kc(this, e, o);
  }, Bc.performDataProcessorTasks = function (t, e) {
    Vc(this, this._dataProcessorHandlers, t, e, { block: !0 });
  }, Bc.performVisualTasks = function (t, e, i) {
    Vc(this, this._visualHandlers, t, e, i);
  }, Bc.performSeriesTasks = function (t) {
    let e;t.eachSeries((t) => {
      e |= t.dataTask.perform();
    }), this.unfinished |= e;
  }, Bc.plan = function () {
    this._pipelineMap.each((t) => {
      let e = t.tail;do {
        if (e.__block) {
          t.blockIndex = e.__idxInPipeline;break;
        }e = e.getUpstream();
      } while (e);
    });
  };var Gc = Bc.updatePayload = function (t, e) {
    'remain' !== e && (t.context.payload = e);
  };function Fc(t) {
    t.overallReset(t.ecModel, t.api, t.payload);
  } function Wc(t, e) {
    return t.overallProgress && Hc;
  } function Hc() {
    this.agent.dirty(), this.getDownstream().dirty();
  } function Zc() {
    this.agent && this.agent.dirty();
  } function Uc(t) {
    return t.plan && t.plan(t.model, t.ecModel, t.api, t.payload);
  } function Xc(t) {
    t.useClearVisual && t.data.clearAllVisual();const e = t.resetDefines = Vo(t.reset(t.model, t.ecModel, t.api, t.payload));return 1 < e.length ? O(e, (t, e) => jc(e)) : Yc;
  } var Yc = jc(0);function jc(a) {
    return function (t, e) {
      const i = e.data; const n = e.resetDefines[a];if (n && n.dataEach) for (let o = t.start;o < t.end;o++)n.dataEach(i, o);else n && n.progress && n.progress(t, i);
    };
  } function qc(t) {
    return t.data.count();
  } function Kc(t, e, i) {
    const n = e.uid; const o = t._pipelineMap.get(n);o.head || (o.head = i), o.tail && o.tail.pipe(i), (o.tail = i).__idxInPipeline = o.count++, i.__pipeline = o;
  }zc.wrapStageHandler = function (t, e) {
    return C(t) && (t = { overallReset: t, seriesType: (function (t) {
      $c = null;try {
        t(Jc, Qc);
      } catch (t) {} return $c;
    }(t)) }), t.uid = Nl('stageHandler'), e && (t.visualType = e), t;
  };let $c; var Jc = {}; var Qc = {};function td(t, e) {
    for (const i in e.prototype)t[i] = et;
  }td(Jc, ih), td(Qc, rh), Jc.eachSeriesByType = Jc.eachRawSeriesByType = function (t) {
    $c = t;
  }, Jc.eachComponent = function (t) {
    'series' === t.mainType && t.subType && ($c = t.subType);
  };function ed() {
    return { axisLine: { lineStyle: { color: od } }, axisTick: { lineStyle: { color: od } }, axisLabel: { textStyle: { color: od } }, splitLine: { lineStyle: { type: 'dashed', color: '#aaa' } }, splitArea: { areaStyle: { color: od } } };
  } const id = ['#37A2DA', '#32C5E9', '#67E0E3', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#E062AE', '#E690D1', '#e7bcf3', '#9d96f5', '#8378EA', '#96BFFF']; const nd = { color: id, colorLayer: [['#37A2DA', '#ffd85c', '#fd7b5f'], ['#37A2DA', '#67E0E3', '#FFDB5C', '#ff9f7f', '#E062AE', '#9d96f5'], ['#37A2DA', '#32C5E9', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#e7bcf3', '#8378EA', '#96BFFF'], id] }; var od = '#eee'; const ad = ['#dd6b66', '#759aa0', '#e69d87', '#8dc1a9', '#ea7e53', '#eedd78', '#73a373', '#73b9bc', '#7289ab', '#91ca8c', '#f49f42']; const rd = { color: ad, backgroundColor: '#333', tooltip: { axisPointer: { lineStyle: { color: od }, crossStyle: { color: od }, label: { color: '#000' } } }, legend: { textStyle: { color: od } }, textStyle: { color: od }, title: { textStyle: { color: od } }, toolbox: { iconStyle: { normal: { borderColor: od } } }, dataZoom: { textStyle: { color: od } }, visualMap: { textStyle: { color: od } }, timeline: { lineStyle: { color: od }, itemStyle: { normal: { color: ad[1] } }, label: { normal: { textStyle: { color: od } } }, controlStyle: { normal: { color: od, borderColor: od } } }, timeAxis: ed(), logAxis: ed(), valueAxis: ed(), categoryAxis: ed(), line: { symbol: 'circle' }, graph: { color: ad }, gauge: { title: { textStyle: { color: od } } }, candlestick: { itemStyle: { normal: { color: '#FD1050', color0: '#0CF49B', borderColor: '#FD1050', borderColor0: '#0CF49B' } } } };rd.categoryAxis.splitLine.show = !1, ku.extend({ type: 'dataset', defaultOption: { seriesLayoutBy: Hu, sourceHeader: null, dimensions: null, source: null }, optionUpdated() {
    !(function (t) {
      const e = t.option.source; let i = Fu;if (V(e))i = Wu;else if (L(e)) {
        0 === e.length && (i = Bu);for (let n = 0, o = e.length;n < o;n++) {
          const a = e[n];if (null != a) {
            if (L(a)) {
              i = Bu;break;
            } if (z(a)) {
              i = Vu;break;
            }
          }
        }
      } else if (z(e)) {
        for (const r in e) if (e.hasOwnProperty(r) && N(e[r])) {
          i = Gu;break;
        }
      } else if (null != e) throw new Error('Invalid data');Yu(t).sourceFormat = i;
    }(this));
  } }), gc.extend({ type: 'dataset' });const sd = Ar.extend({ type: 'ellipse', shape: { cx: 0, cy: 0, rx: 0, ry: 0 }, buildPath(t, e) {
    const i = e.cx; const n = e.cy; const o = e.rx; const a = e.ry; const r = .5522848 * o; const s = .5522848 * a;t.moveTo(i - o, n), t.bezierCurveTo(i - o, n - s, i - r, n - a, i, n - a), t.bezierCurveTo(i + r, n - a, i + o, n - s, i + o, n), t.bezierCurveTo(i + o, n + s, i + r, n + a, i, n + a), t.bezierCurveTo(i - r, n + a, i - o, n + s, i - o, n), t.closePath();
  } }); const ld = /[\s,]+/;function ud(t) {
    E(t) && (t = (new DOMParser).parseFromString(t, 'text/xml'));for (9 === t.nodeType && (t = t.firstChild);'svg' !== t.nodeName.toLowerCase() || 1 !== t.nodeType;)t = t.nextSibling;return t;
  } function hd() {
    this._defs = {}, this._root = null, this._isDefine = !1, this._isText = !1;
  }hd.prototype.parse = function (t, e) {
    e = e || {};const i = ud(t);if (!i) throw new Error('Illegal svg');let n = new Ci;this._root = n;const o = i.getAttribute('viewBox') || ''; let a = parseFloat(i.getAttribute('width') || e.width); let r = parseFloat(i.getAttribute('height') || e.height);isNaN(a) && (a = null), isNaN(r) && (r = null), md(i, n, null, !0);for (var s, l, u = i.firstChild;u;) this._parseNode(u, n), u = u.nextSibling;if (o) {
      const h = j(o).split(ld);4 <= h.length && (s = { x: parseFloat(h[0] || 0), y: parseFloat(h[1] || 0), width: parseFloat(h[2]), height: parseFloat(h[3]) });
    } if (s && null != a && null != r && (l = wd(s, a, r), !e.ignoreViewBox)) {
      const c = n;(n = new Ci).add(c), c.scale = l.scale.slice(), c.position = l.position.slice();
    } return e.ignoreRootClip || null == a || null == r || n.setClipPath(new rs({ shape: { x: 0, y: 0, width: a, height: r } })), { root: n, width: a, height: r, viewBoxRect: s, viewBoxTransform: l };
  }, hd.prototype._parseNode = function (t, e) {
    let i; let n; const o = t.nodeName.toLowerCase();if ('defs' === o ? this._isDefine = !0 : 'text' === o && (this._isText = !0), this._isDefine) {
      if (n = dd[o]) {
        const a = n.call(this, t); const r = t.getAttribute('id');r && (this._defs[r] = a);
      }
    } else (n = cd[o]) && (i = n.call(this, t, e), e.add(i));for (let s = t.firstChild;s;)1 === s.nodeType && this._parseNode(s, i), 3 === s.nodeType && this._isText && this._parseText(s, i), s = s.nextSibling;'defs' === o ? this._isDefine = !1 : 'text' === o && (this._isText = !1);
  }, hd.prototype._parseText = function (t, e) {
    if (1 === t.nodeType) {
      const i = t.getAttribute('dx') || 0; const n = t.getAttribute('dy') || 0;this._textX += parseFloat(i), this._textY += parseFloat(n);
    } const o = new Ur({ style: { text: t.textContent, transformText: !0 }, position: [this._textX || 0, this._textY || 0] });fd(e, o), md(t, o, this._defs);const a = o.style.fontSize;a && a < 9 && (o.style.fontSize = 9, o.scale = o.scale || [1, 1], o.scale[0] *= a / 9, o.scale[1] *= a / 9);const r = o.getBoundingRect();return this._textX += r.width, e.add(o), o;
  };var cd = { g(t, e) {
    const i = new Ci;return fd(e, i), md(t, i, this._defs), i;
  }, rect(t, e) {
    const i = new rs;return fd(e, i), md(t, i, this._defs), i.setShape({ x: parseFloat(t.getAttribute('x') || 0), y: parseFloat(t.getAttribute('y') || 0), width: parseFloat(t.getAttribute('width') || 0), height: parseFloat(t.getAttribute('height') || 0) }), i;
  }, circle(t, e) {
    const i = new Yr;return fd(e, i), md(t, i, this._defs), i.setShape({ cx: parseFloat(t.getAttribute('cx') || 0), cy: parseFloat(t.getAttribute('cy') || 0), r: parseFloat(t.getAttribute('r') || 0) }), i;
  }, line(t, e) {
    const i = new ls;return fd(e, i), md(t, i, this._defs), i.setShape({ x1: parseFloat(t.getAttribute('x1') || 0), y1: parseFloat(t.getAttribute('y1') || 0), x2: parseFloat(t.getAttribute('x2') || 0), y2: parseFloat(t.getAttribute('y2') || 0) }), i;
  }, ellipse(t, e) {
    const i = new sd;return fd(e, i), md(t, i, this._defs), i.setShape({ cx: parseFloat(t.getAttribute('cx') || 0), cy: parseFloat(t.getAttribute('cy') || 0), rx: parseFloat(t.getAttribute('rx') || 0), ry: parseFloat(t.getAttribute('ry') || 0) }), i;
  }, polygon(t, e) {
    let i = t.getAttribute('points');i = i && pd(i);const n = new Qr({ shape: { points: i || [] } });return fd(e, n), md(t, n, this._defs), n;
  }, polyline(t, e) {
    const i = new Ar;fd(e, i), md(t, i, this._defs);let n = t.getAttribute('points');return n = n && pd(n), new ts({ shape: { points: n || [] } });
  }, image(t, e) {
    const i = new Qn;return fd(e, i), md(t, i, this._defs), i.setStyle({ image: t.getAttribute('xlink:href'), x: t.getAttribute('x'), y: t.getAttribute('y'), width: t.getAttribute('width'), height: t.getAttribute('height') }), i;
  }, text(t, e) {
    const i = t.getAttribute('x') || 0; const n = t.getAttribute('y') || 0; const o = t.getAttribute('dx') || 0; const a = t.getAttribute('dy') || 0;this._textX = parseFloat(i) + parseFloat(o), this._textY = parseFloat(n) + parseFloat(a);const r = new Ci;return fd(e, r), md(t, r, this._defs), r;
  }, tspan(t, e) {
    const i = t.getAttribute('x'); const n = t.getAttribute('y');null != i && (this._textX = parseFloat(i)), null != n && (this._textY = parseFloat(n));const o = t.getAttribute('dx') || 0; const a = t.getAttribute('dy') || 0; const r = new Ci;return fd(e, r), md(t, r, this._defs), this._textX += o, this._textY += a, r;
  }, path(t, e) {
    const i = Zr(t.getAttribute('d') || '');return fd(e, i), md(t, i, this._defs), i;
  } }; var dd = { lineargradient(t) {
    const e = parseInt(t.getAttribute('x1') || 0, 10); const i = parseInt(t.getAttribute('y1') || 0, 10); const n = parseInt(t.getAttribute('x2') || 10, 10); const o = parseInt(t.getAttribute('y2') || 0, 10); const a = new gs(e, i, n, o);return (function (t, e) {
      let i = t.firstChild;for (;i;) {
        if (1 === i.nodeType) {
          let n = i.getAttribute('offset');n = 0 < n.indexOf('%') ? parseInt(n, 10) / 100 : n ? parseFloat(n) : 0;const o = i.getAttribute('stop-color') || '#000000';e.addColorStop(n, o);
        }i = i.nextSibling;
      }
    }(t, a)), a;
  }, radialgradient(t) {} };function fd(t, e) {
    t && t.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), D(e.__inheritedStyle, t.__inheritedStyle));
  } function pd(t) {
    for (var e = j(t).split(ld), i = [], n = 0;n < e.length;n += 2) {
      const o = parseFloat(e[n]); const a = parseFloat(e[n + 1]);i.push([o, a]);
    } return i;
  } const gd = { fill: 'fill', stroke: 'stroke', 'stroke-width': 'lineWidth', opacity: 'opacity', 'fill-opacity': 'fillOpacity', 'stroke-opacity': 'strokeOpacity', 'stroke-dasharray': 'lineDash', 'stroke-dashoffset': 'lineDashOffset', 'stroke-linecap': 'lineCap', 'stroke-linejoin': 'lineJoin', 'stroke-miterlimit': 'miterLimit', 'font-family': 'fontFamily', 'font-size': 'fontSize', 'font-style': 'fontStyle', 'font-weight': 'fontWeight', 'text-align': 'textAlign', 'alignment-baseline': 'textBaseline' };function md(t, e, i, n) {
    const o = e.__inheritedStyle || {}; const a = 'text' === e.type;if (1 === t.nodeType && ((function (t, e) {
      let i = t.getAttribute('transform');if (i) {
        i = i.replace(/,/g, ' ');let n = null; const o = [];i.replace(xd, (t, e, i) => {
          o.push(e, i);
        });for (let a = o.length - 1;0 < a;a -= 2) {
          let r = o[a]; const s = o[a - 1];switch (n = n || ae(), s) {
            case 'translate':r = j(r).split(ld), ue(n, n, [parseFloat(r[0]), parseFloat(r[1] || 0)]);break;case 'scale':r = j(r).split(ld), ce(n, n, [parseFloat(r[0]), parseFloat(r[1] || r[0])]);break;case 'rotate':r = j(r).split(ld), he(n, n, parseFloat(r[0]));break;case 'skew':r = j(r).split(ld), console.warn('Skew transform is not supported yet');break;case 'matrix':r = j(r).split(ld);n[0] = parseFloat(r[0]), n[1] = parseFloat(r[1]), n[2] = parseFloat(r[2]), n[3] = parseFloat(r[3]), n[4] = parseFloat(r[4]), n[5] = parseFloat(r[5]);
          }
        }e.setLocalTransform(n);
      }
    }(t, e)), P(o, (function (t) {
      const e = t.getAttribute('style'); const i = {};if (!e) return i;let n; const o = {};_d.lastIndex = 0;for (;null != (n = _d.exec(e));)o[n[1]] = n[2];for (const a in gd)gd.hasOwnProperty(a) && null != o[a] && (i[gd[a]] = o[a]);return i;
    }(t))), !n)) for (const r in gd) if (gd.hasOwnProperty(r)) {
      const s = t.getAttribute(r);null != s && (o[gd[r]] = s);
    } const l = a ? 'textFill' : 'fill'; const u = a ? 'textStroke' : 'stroke';e.style = e.style || new Ui;const h = e.style;null != o.fill && h.set(l, yd(o.fill, i)), null != o.stroke && h.set(u, yd(o.stroke, i)), R(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], (t) => {
      const e = 'lineWidth' === t && a ? 'textStrokeWidth' : t;null != o[t] && h.set(e, parseFloat(o[t]));
    }), o.textBaseline && 'auto' !== o.textBaseline || (o.textBaseline = 'alphabetic'), 'alphabetic' === o.textBaseline && (o.textBaseline = 'bottom'), 'start' === o.textAlign && (o.textAlign = 'left'), 'end' === o.textAlign && (o.textAlign = 'right'), R(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], (t) => {
      null != o[t] && h.set(t, o[t]);
    }), o.lineDash && (e.style.lineDash = j(o.lineDash).split(ld)), h[u] && 'none' !== h[u] && (e[u] = !0), e.__inheritedStyle = o;
  } const vd = /url\(\s*#(.*?)\)/;function yd(t, e) {
    const i = e && t && t.match(vd);return i ? e[j(i[1])] : t;
  } var xd = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g;var _d = /([^\s:;]+)\s*:\s*([^:;]+)/g;function wd(t, e, i) {
    const n = e / t.width; const o = i / t.height; const a = Math.min(n, o);return { scale: [a, a], position: [-(t.x + t.width / 2) * a + e / 2, -(t.y + t.height / 2) * a + i / 2] };
  } const bd = Q(); const Sd = { registerMap(t, e, i) {
    let n;return R(n = L(e) ? e : e.svg ? [{ type: 'svg', source: e.svg, specialAreas: e.specialAreas }] : (e.geoJson && !e.features && (i = e.specialAreas, e = e.geoJson), [{ type: 'geoJSON', source: e, specialAreas: i }]), (t) => {
      let e = t.type;'geoJson' === e && (e = t.type = 'geoJSON'), (0, Md[e])(t);
    }), bd.set(t, n);
  }, retrieveMap(t) {
    return bd.get(t);
  } }; var Md = { geoJSON(t) {
    const e = t.source;t.geoJSON = E(e) ? 'undefined' !== typeof JSON && JSON.parse ? JSON.parse(e) : new Function(`return (${e});`)() : e;
  }, svg(t) {
    t.svgXML = ud(t.source);
  } }; const Id = Y; const Td = R; const Ad = C; const Dd = z; const Cd = ku.parseClassType; const Ld = { PROCESSOR: { FILTER: 1e3, SERIES_FILTER: 800, STATISTIC: 5e3 }, VISUAL: { LAYOUT: 1e3, PROGRESSIVE_LAYOUT: 1100, GLOBAL: 2e3, CHART: 3e3, POST_CHART_LAYOUT: 3500, COMPONENT: 4e3, BRUSH: 5e3 } }; const kd = '__flagInMainProcess'; const Pd = '__optionUpdated'; const Nd = /^[a-zA-Z0-9_]+$/;function Od(n, o) {
    return function (t, e, i) {
      !o && this._disposed || (t = t && t.toLowerCase(), Ct.prototype[n].call(this, t, e, i));
    };
  } function Rd() {
    Ct.call(this);
  } function Ed(t, e, i) {
    i = i || {}, 'string' === typeof e && (e = sf[e]), this.id, this.group, this._dom = t;const n = this._zr = ko(t, { renderer: i.renderer || 'canvas', devicePixelRatio: i.devicePixelRatio, width: i.width, height: i.height });this._throttledZrFlush = Lc(A(n.flush, n), 17), (e = k(e)) && Lh(e, !0), this._theme = e, this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._coordSysMgr = new lh;const o = this._api = (function (i) {
      const t = i._coordSysMgr;return P(new rh(i), { getCoordinateSystems: A(t.getCoordinateSystems, t), getComponentByElement(t) {
        for (;t;) {
          const e = t.__ecComponentInfo;if (null != e) return i._model.getComponent(e.mainType, e.index);t = t.parent;
        }
      } });
    }(this));function a(t, e) {
      return t.__prio - e.__prio;
    }zi(rf, a), zi(nf, a), this._scheduler = new zc(this, o, nf, rf), Ct.call(this, this._ecEventProcessor = new Qd), this._messageCenter = new Rd, this._initEvents(), this.resize = A(this.resize, this), this._pendingActions = [], n.animation.on('frame', this._onframe, this), (function (t, e) {
      t.on('rendered', () => {
        e.trigger('rendered'), !t.animation.isFinished() || e[Pd] || e._scheduler.unfinished || e._pendingActions.length || e.trigger('finished');
      });
    }(n, this)), K(this);
  }Rd.prototype.on = Od('on', !0), Rd.prototype.off = Od('off', !0), Rd.prototype.one = Od('one', !0), b(Rd, Ct);const zd = Ed.prototype;function Bd(t, e, i) {
    if (!this._disposed) {
      let n; const o = this._model; const a = this._coordSysMgr.getCoordinateSystems();e = Ko(o, e);for (let r = 0;r < a.length;r++) {
        const s = a[r];if (s[t] && null != (n = s[t](o, e, i))) return n;
      }
    }
  }zd._onframe = function () {
    if (!this._disposed) {
      const t = this._scheduler;if (this[Pd]) {
        const e = this[Pd].silent;this[kd] = !0, Gd(this), Vd.update.call(this), this[kd] = !1, this[Pd] = !1, Zd.call(this, e), Ud.call(this, e);
      } else if (t.unfinished) {
        let i = 1; const n = this._model; const o = this._api;t.unfinished = !1;do {
          const a = +new Date;t.performSeriesTasks(n), t.performDataProcessorTasks(n), Wd(this, n), t.performVisualTasks(n), qd(this, this._model, o, 'remain'), i -= +new Date - a;
        } while (0 < i && t.unfinished);t.unfinished || this._zr.flush();
      }
    }
  }, zd.getDom = function () {
    return this._dom;
  }, zd.getZr = function () {
    return this._zr;
  }, zd.setOption = function (t, e, i) {
    if (!this._disposed) {
      let n;if (Dd(e) && (i = e.lazyUpdate, n = e.silent, e = e.notMerge), this[kd] = !0, !this._model || e) {
        const o = new ph(this._api); const a = this._theme; const r = this._model = new ih;r.scheduler = this._scheduler, r.init(null, null, a, o);
      } this._model.setOption(t, of), i ? (this[Pd] = { silent: n }, this[kd] = !1) : (Gd(this), Vd.update.call(this), this._zr.flush(), this[Pd] = !1, this[kd] = !1, Zd.call(this, n), Ud.call(this, n));
    }
  }, zd.setTheme = function () {
    console.error('ECharts#setTheme() is DEPRECATED in ECharts 3.0');
  }, zd.getModel = function () {
    return this._model;
  }, zd.getOption = function () {
    return this._model && this._model.getOption();
  }, zd.getWidth = function () {
    return this._zr.getWidth();
  }, zd.getHeight = function () {
    return this._zr.getHeight();
  }, zd.getDevicePixelRatio = function () {
    return this._zr.painter.dpr || window.devicePixelRatio || 1;
  }, zd.getRenderedCanvas = function (t) {
    if (v.canvasSupported) return (t = t || {}).pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get('backgroundColor'), this._zr.painter.getRenderedCanvas(t);
  }, zd.getSvgDataURL = function () {
    if (v.svgSupported) {
      const t = this._zr;return R(t.storage.getDisplayList(), (t) => {
        t.stopAnimation(!0);
      }), t.painter.toDataURL();
    }
  }, zd.getDataURL = function (t) {
    if (!this._disposed) {
      const e = (t = t || {}).excludeComponents; const i = this._model; const n = []; const o = this;Td(e, (t) => {
        i.eachComponent({ mainType: t }, (t) => {
          const e = o._componentsMap[t.__viewId];e.group.ignore || (n.push(e), e.group.ignore = !0);
        });
      });const a = 'svg' === this._zr.painter.getType() ? this.getSvgDataURL() : this.getRenderedCanvas(t).toDataURL(`image/${t && t.type || 'png'}`);return Td(n, (t) => {
        t.group.ignore = !1;
      }), a;
    }
  }, zd.getConnectedDataURL = function (o) {
    if (!this._disposed && v.canvasSupported) {
      const a = 'svg' === o.type; const r = this.group; const s = Math.min; const l = Math.max;if (hf[r]) {
        let u = 1 / 0; let h = 1 / 0; let c = -1 / 0; let d = -1 / 0; const f = []; const i = o && o.pixelRatio || 1;R(uf, (t, e) => {
          if (t.group === r) {
            const i = a ? t.getZr().painter.getSvgDom().innerHTML : t.getRenderedCanvas(k(o)); const n = t.getDom().getBoundingClientRect();u = s(n.left, u), h = s(n.top, h), c = l(n.right, c), d = l(n.bottom, d), f.push({ dom: i, left: n.left, top: n.top });
          }
        });const t = (c *= i) - (u *= i); const e = (d *= i) - (h *= i); const n = y(); const p = ko(n, { renderer: a ? 'svg' : 'canvas' });if (p.resize({ width: t, height: e }), a) {
          let g = '';return Td(f, (t) => {
            const e = t.left - u; const i = t.top - h;g += `<g transform="translate(${e},${i})">${t.dom}</g>`;
          }), p.painter.getSvgRoot().innerHTML = g, o.connectedBackgroundColor && p.painter.setBackgroundColor(o.connectedBackgroundColor), p.refreshImmediately(), p.painter.toDataURL();
        } return o.connectedBackgroundColor && p.add(new rs({ shape: { x: 0, y: 0, width: t, height: e }, style: { fill: o.connectedBackgroundColor } })), Td(f, (t) => {
          const e = new Qn({ style: { x: t.left * i - u, y: t.top * i - h, image: t.dom } });p.add(e);
        }), p.refreshImmediately(), n.toDataURL(`image/${o && o.type || 'png'}`);
      } return this.getDataURL(o);
    }
  }, zd.convertToPixel = T(Bd, 'convertToPixel'), zd.convertFromPixel = T(Bd, 'convertFromPixel'), zd.containPixel = function (t, o) {
    let a;if (!this._disposed) return R(t = Ko(this._model, t), function (t, n) {
      0 <= n.indexOf('Models') && R(t, function (t) {
        const e = t.coordinateSystem;if (e && e.containPoint)a |= !!e.containPoint(o);else if ('seriesModels' === n) {
          const i = this._chartsMap[t.__viewId];i && i.containPoint && (a |= i.containPoint(o, t));
        }
      }, this);
    }, this), !!a;
  }, zd.getVisual = function (t, e) {
    const i = (t = Ko(this._model, t, { defaultMainType: 'series' })).seriesModel.getData(); const n = t.hasOwnProperty('dataIndexInside') ? t.dataIndexInside : t.hasOwnProperty('dataIndex') ? i.indexOfRawIndex(t.dataIndex) : null;return null != n ? i.getItemVisual(n, e) : i.getVisual(e);
  }, zd.getViewOfComponentModel = function (t) {
    return this._componentsMap[t.__viewId];
  }, zd.getViewOfSeriesModel = function (t) {
    return this._chartsMap[t.__viewId];
  };var Vd = { prepareAndUpdate(t) {
    Gd(this), Vd.update.call(this, t);
  }, update(t) {
    const e = this._model; const i = this._api; const n = this._zr; const o = this._coordSysMgr; const a = this._scheduler;if (e) {
      a.restoreData(e, t), a.performSeriesTasks(e), o.create(e, i), a.performDataProcessorTasks(e, t), Wd(this, e), o.update(e, i), Yd(e), a.performVisualTasks(e, t), jd(this, e, i, t);let r = e.get('backgroundColor') || 'transparent';if (v.canvasSupported)n.setBackgroundColor(r);else {
        const s = Fe(r);r = $e(s, 'rgb'), 0 === s[3] && (r = 'transparent');
      }Kd(e, i);
    }
  }, updateTransform(o) {
    const a = this._model; const r = this; const s = this._api;if (a) {
      const l = [];a.eachComponent((t, e) => {
        const i = r.getViewOfComponentModel(e);if (i && i.__alive) if (i.updateTransform) {
          const n = i.updateTransform(e, a, s, o);n && n.update && l.push(i);
        } else l.push(i);
      });const n = Q();a.eachSeries((t) => {
        const e = r._chartsMap[t.__viewId];if (e.updateTransform) {
          const i = e.updateTransform(t, a, s, o);i && i.update && n.set(t.uid, 1);
        } else n.set(t.uid, 1);
      }), Yd(a), this._scheduler.performVisualTasks(a, o, { setDirty: !0, dirtyMap: n }), qd(r, a, s, o, n), Kd(a, this._api);
    }
  }, updateView(t) {
    const e = this._model;e && (_c.markUpdateMethod(t, 'updateView'), Yd(e), this._scheduler.performVisualTasks(e, t, { setDirty: !0 }), jd(this, this._model, this._api, t), Kd(e, this._api));
  }, updateVisual(t) {
    Vd.update.call(this, t);
  }, updateLayout(t) {
    Vd.update.call(this, t);
  } };function Gd(t) {
    const e = t._model; const i = t._scheduler;i.restorePipelines(e), i.prepareStageTasks(), Xd(t, 'component', e, i), Xd(t, 'chart', e, i), i.plan();
  } function Fd(e, i, n, o, t) {
    const a = e._model;if (o) {
      const r = {};r[`${o}Id`] = n[`${o}Id`], r[`${o}Index`] = n[`${o}Index`], r[`${o}Name`] = n[`${o}Name`];const s = { mainType: o, query: r };t && (s.subType = t);let l = n.excludeSeriesId;null != l && (l = Q(Vo(l))), a && a.eachComponent(s, (t) => {
        l && null != l.get(t.id) || u(e['series' === o ? '_chartsMap' : '_componentsMap'][t.__viewId]);
      }, e);
    } else Td(e._componentsViews.concat(e._chartsViews), u);function u(t) {
      t && t.__alive && t[i] && t[i](t.__model, a, e._api, n);
    }
  } function Wd(t, e) {
    const i = t._chartsMap; const n = t._scheduler;e.eachSeries((t) => {
      n.updateStreamModes(t, i[t.__viewId]);
    });
  } function Hd(e, t) {
    const i = e.type; const n = e.escapeConnect; const o = tf[i]; const a = o.actionInfo; let r = (a.update || 'update').split(':'); const s = r.pop();r = null != r[0] && Cd(r[0]), this[kd] = !0;let l = [e]; let u = !1;e.batch && (u = !0, l = O(e.batch, t => ((t = D(P({}, t), e)).batch = null, t)));let h; const c = []; const d = 'highlight' === i || 'downplay' === i;Td(l, function (t) {
      (h = (h = o.action(t, this._model, this._api)) || P({}, t)).type = a.event || h.type, c.push(h), d ? Fd(this, s, t, 'series') : r && Fd(this, s, t, r.main, r.sub);
    }, this), 'none' === s || d || r || (this[Pd] ? (Gd(this), Vd.update.call(this, e), this[Pd] = !1) : Vd[s].call(this, e)), h = u ? { type: a.event || i, escapeConnect: n, batch: c } : c[0], this[kd] = !1, t || this._messageCenter.trigger(h.type, h);
  } function Zd(t) {
    for (let e = this._pendingActions;e.length;) {
      const i = e.shift();Hd.call(this, i, t);
    }
  } function Ud(t) {
    t || this.trigger('updated');
  } function Xd(t, e, o, a) {
    for (var r = 'component' === e, s = r ? t._componentsViews : t._chartsViews, l = r ? t._componentsMap : t._chartsMap, u = t._zr, h = t._api, i = 0;i < s.length;i++)s[i].__alive = !1;function n(t) {
      const e = `_ec_${t.id}_${t.type}`; let i = l[e];if (!i) {
        const n = Cd(t.type);(i = new(r ? gc.getClass(n.main, n.sub) : _c.getClass(n.sub))).init(o, h), l[e] = i, s.push(i), u.add(i.group);
      }t.__viewId = i.__id = e, i.__alive = !0, i.__model = t, i.group.__ecComponentInfo = { mainType: t.mainType, index: t.componentIndex }, r || a.prepareView(i, t, o, h);
    }r ? o.eachComponent((t, e) => {
      'series' !== t && n(e);
    }) : o.eachSeries(n);for (i = 0;i < s.length;) {
      const c = s[i];c.__alive ? i++ : (r || c.renderTask.dispose(), u.remove(c.group), c.dispose(o, h), s.splice(i, 1), delete l[c.__id], c.__id = c.group.__ecComponentInfo = null);
    }
  } function Yd(t) {
    t.clearColorPalette(), t.eachSeries((t) => {
      t.clearColorPalette();
    });
  } function jd(t, e, i, n) {
    !(function (t, i, n, o, e) {
      Td(e || t._componentsViews, (t) => {
        const e = t.__model;t.render(e, i, n, o), Jd(e, t);
      });
    }(t, e, i, n)), Td(t._chartsViews, (t) => {
      t.__alive = !1;
    }), qd(t, e, i, n), Td(t._chartsViews, (t) => {
      t.__alive || t.remove(e, i);
    });
  } function qd(n, t, e, o, a) {
    let r; const s = n._scheduler;t.eachSeries((t) => {
      const e = n._chartsMap[t.__viewId];e.__alive = !0;const i = e.renderTask;s.updatePayload(i, o), a && a.get(t.uid) && i.dirty(), r |= i.perform(s.getPerformArgs(i)), e.group.silent = !!t.get('silent'), Jd(t, e), (function (t, e) {
        const i = t.get('blendMode') || null;e.group.traverse((t) => {
          t.isGroup || t.style.blend !== i && t.setStyle('blend', i), t.eachPendingDisplayable && t.eachPendingDisplayable((t) => {
            t.setStyle('blend', i);
          });
        });
      }(t, e));
    }), s.unfinished |= r, (function (i, t) {
      const e = i._zr.storage; let n = 0;e.traverse((t) => {
        n++;
      }), n > t.get('hoverLayerThreshold') && !v.node && t.eachSeries((t) => {
        if (!t.preventUsingHoverLayer) {
          const e = i._chartsMap[t.__viewId];e.__alive && e.group.traverse((t) => {
            t.useHoverLayer = !0;
          });
        }
      });
    }(n, t)), Rc(n._zr.dom, t);
  } function Kd(e, i) {
    Td(af, (t) => {
      t(e, i);
    });
  }zd.resize = function (t) {
    if (!this._disposed) {
      this._zr.resize(t);const e = this._model;if (this._loadingFX && this._loadingFX.resize(), e) {
        const i = e.resetOption('media'); const n = t && t.silent;this[kd] = !0, i && Gd(this), Vd.update.call(this), this[kd] = !1, Zd.call(this, n), Ud.call(this, n);
      }
    }
  }, zd.showLoading = function (t, e) {
    if (!this._disposed && (Dd(t) && (e = t, t = ''), t = t || 'default', this.hideLoading(), lf[t])) {
      const i = lf[t](this._api, e); const n = this._zr;this._loadingFX = i, n.add(i);
    }
  }, zd.hideLoading = function () {
    this._disposed || (this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null);
  }, zd.makeActionFromEvent = function (t) {
    const e = P({}, t);return e.type = ef[t.type], e;
  }, zd.dispatchAction = function (t, e) {
    this._disposed || (Dd(e) || (e = { silent: !!e }), tf[t.type] && this._model && (this[kd] ? this._pendingActions.push(t) : (Hd.call(this, t, e.silent), e.flush ? this._zr.flush(!0) : !1 !== e.flush && v.browser.weChat && this._throttledZrFlush(), Zd.call(this, e.silent), Ud.call(this, e.silent))));
  }, zd.appendData = function (t) {
    if (!this._disposed) {
      const e = t.seriesIndex;this.getModel().getSeriesByIndex(e)
        .appendData(t), this._scheduler.unfinished = !0;
    }
  }, zd.on = Od('on', !1), zd.off = Od('off', !1), zd.one = Od('one', !1);const $d = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];function Jd(t, e) {
    const i = t.get('z'); const n = t.get('zlevel');e.group.traverse((t) => {
      'group' !== t.type && (null != i && (t.z = i), null != n && (t.zlevel = n));
    });
  } function Qd() {
    this.eventInfo;
  }zd._initEvents = function () {
    Td($d, function (u) {
      function t(t) {
        let e; const i = this.getModel(); const n = t.target;if ('globalout' === u)e = {};else if (n && null != n.dataIndex) {
          const o = n.dataModel || i.getSeriesByIndex(n.seriesIndex);e = o && o.getDataParams(n.dataIndex, n.dataType, n) || {};
        } else n && n.eventData && (e = P({}, n.eventData));if (e) {
          let a = e.componentType; let r = e.componentIndex;'markLine' !== a && 'markPoint' !== a && 'markArea' !== a || (a = 'series', r = e.seriesIndex);const s = a && null != r && i.getComponent(a, r); const l = s && this['series' === s.mainType ? '_chartsMap' : '_componentsMap'][s.__viewId];e.event = t, e.type = u, this._ecEventProcessor.eventInfo = { targetEl: n, packedEvent: e, model: s, view: l }, this.trigger(u, e);
        }
      }t.zrEventfulCallAtLast = !0, this._zr.on(u, t, this);
    }, this), Td(ef, function (t, e) {
      this._messageCenter.on(e, function (t) {
        this.trigger(e, t);
      }, this);
    }, this);
  }, zd.isDisposed = function () {
    return this._disposed;
  }, zd.clear = function () {
    this._disposed || this.setOption({ series: [] }, !0);
  }, zd.dispose = function () {
    if (!this._disposed) {
      this._disposed = !0, Jo(this.getDom(), ff, '');const e = this._api; const i = this._model;Td(this._componentsViews, (t) => {
        t.dispose(i, e);
      }), Td(this._chartsViews, (t) => {
        t.dispose(i, e);
      }), this._zr.dispose(), delete uf[this.id];
    }
  }, b(Ed, Ct), Qd.prototype = { constructor: Qd, normalizeQuery(t) {
    const s = {}; const l = {}; const u = {};if (E(t)) {
      const e = Cd(t);s.mainType = e.main || null, s.subType = e.sub || null;
    } else {
      const h = ['Index', 'Name', 'Id']; const c = { name: 1, dataIndex: 1, dataType: 1 };R(t, (t, e) => {
        for (var i = !1, n = 0;n < h.length;n++) {
          const o = h[n]; const a = e.lastIndexOf(o);if (0 < a && a === e.length - o.length) {
            const r = e.slice(0, a);'data' !== r && (s.mainType = r, s[o.toLowerCase()] = t, i = !0);
          }
        }c.hasOwnProperty(e) && (l[e] = t, i = !0), i || (u[e] = t);
      });
    } return { cptQuery: s, dataQuery: l, otherQuery: u };
  }, filter(t, e, i) {
    const n = this.eventInfo;if (!n) return !0;const o = n.targetEl; const a = n.packedEvent; const r = n.model; const s = n.view;if (!r || !s) return !0;const l = e.cptQuery; const u = e.dataQuery;return h(l, r, 'mainType') && h(l, r, 'subType') && h(l, r, 'index', 'componentIndex') && h(l, r, 'name') && h(l, r, 'id') && h(u, a, 'name') && h(u, a, 'dataIndex') && h(u, a, 'dataType') && (!s.filterForExposedEvent || s.filterForExposedEvent(t, e.otherQuery, o, a));function h(t, e, i, n) {
      return null == t[i] || e[n || i] === t[i];
    }
  }, afterTrigger() {
    this.eventInfo = null;
  } };var tf = {}; var ef = {}; var nf = []; var of = []; var af = []; var rf = []; var sf = {}; var lf = {}; var uf = {}; var hf = {}; let cf = new Date - 0; let df = new Date - 0; var ff = '_echarts_instance_';function pf(t) {
    hf[t] = !1;
  } const gf = pf;function mf(t) {
    return uf[(function (t, e) {
      return t.getAttribute ? t.getAttribute(e) : t[e];
    }(t, ff))];
  } function vf(t, e) {
    sf[t] = e;
  } function yf(t) {
    of.push(t);
  } function xf(t, e) {
    Mf(nf, t, e, 1e3);
  } function _f(t, e, i) {
    'function' === typeof e && (i = e, e = '');const n = Dd(t) ? t.type : [t, t = { event: e }][0];t.event = (t.event || n).toLowerCase(), e = t.event, Id(Nd.test(n) && Nd.test(e)), tf[n] || (tf[n] = { action: i, actionInfo: t }), ef[e] = n;
  } function wf(t, e) {
    lh.register(t, e);
  } function bf(t, e) {
    Mf(rf, t, e, 1e3, 'layout');
  } function Sf(t, e) {
    Mf(rf, t, e, 3e3, 'visual');
  } function Mf(t, e, i, n, o) {
    (Ad(e) || Dd(e)) && (i = e, e = n);const a = zc.wrapStageHandler(i, o);return a.__prio = e, a.__raw = i, t.push(a), a;
  } function If(t, e) {
    lf[t] = e;
  } function Tf(t) {
    return ku.extend(t);
  } function Af(t) {
    return gc.extend(t);
  } function Df(t) {
    return sc.extend(t);
  } function Cf(t) {
    return _c.extend(t);
  }Sf(2e3, Nc), yf(Lh), xf(900, (t) => {
    const a = Q();t.eachSeries((t) => {
      const e = t.get('stack');if (e) {
        const i = a.get(e) || a.set(e, []); const n = t.getData(); const o = { stackResultDimension: n.getCalculationInfo('stackResultDimension'), stackedOverDimension: n.getCalculationInfo('stackedOverDimension'), stackedDimension: n.getCalculationInfo('stackedDimension'), stackedByDimension: n.getCalculationInfo('stackedByDimension'), isStackedByIndex: n.getCalculationInfo('isStackedByIndex'), data: n, seriesModel: t };if (!o.stackedDimension || !o.isStackedByIndex && !o.stackedByDimension) return;i.length && n.setCalculationInfo('stackedOnSeries', i[i.length - 1].seriesModel), i.push(o);
      }
    }), a.each(kh);
  }), If('default', (o, a) => {
    D(a = a || {}, { text: 'loading', textColor: '#000', fontSize: '12px', maskColor: 'rgba(255, 255, 255, 0.8)', showSpinner: !0, color: '#c23531', spinnerRadius: 10, lineWidth: 5, zlevel: 0 });const t = new Ci; const r = new rs({ style: { fill: a.maskColor }, zlevel: a.zlevel, z: 1e4 });t.add(r);const s = `${a.fontSize} sans-serif`; const l = new rs({ style: { fill: 'none', text: a.text, font: s, textPosition: 'right', textDistance: 10, textFill: a.textColor }, zlevel: a.zlevel, z: 10001 });if (t.add(l), a.showSpinner) {
      var u = new fs({ shape: { startAngle: -Ec / 2, endAngle: -Ec / 2 + .1, r: a.spinnerRadius }, style: { stroke: a.color, lineCap: 'round', lineWidth: a.lineWidth }, zlevel: a.zlevel, z: 10001 });u.animateShape(!0).when(1e3, { endAngle: 3 * Ec / 2 })
        .start('circularInOut'), u.animateShape(!0).when(1e3, { startAngle: 3 * Ec / 2 })
        .delay(300)
        .start('circularInOut'), t.add(u);
    } return t.resize = function () {
      const t = pn(a.text, s); const e = a.showSpinner ? a.spinnerRadius : 0; const i = (o.getWidth() - 2 * e - (a.showSpinner && t ? 10 : 0) - t) / 2 - (a.showSpinner ? 0 : t / 2); const n = o.getHeight() / 2;a.showSpinner && u.setShape({ cx: i, cy: n }), l.setShape({ x: i - e, y: n - e, width: 2 * e, height: 2 * e }), r.setShape({ x: 0, y: 0, width: o.getWidth(), height: o.getHeight() });
    }, t.resize(), t;
  }), _f({ type: 'highlight', event: 'highlight', update: 'highlight' }, et), _f({ type: 'downplay', event: 'downplay', update: 'downplay' }, et), vf('light', nd), vf('dark', rd);function Lf(t) {
    return t;
  } function kf(t, e, i, n, o) {
    this._old = t, this._new = e, this._oldKeyGetter = i || Lf, this._newKeyGetter = n || Lf, this.context = o;
  } function Pf(t, e, i, n, o) {
    for (let a = 0;a < t.length;a++) {
      const r = `_ec_${o[n](t[a], a)}`; let s = e[r];null == s ? (i.push(r), e[r] = a) : (s.length || (e[r] = s = [s]), s.push(a));
    }
  }kf.prototype = { constructor: kf, add(t) {
    return this._add = t, this;
  }, update(t) {
    return this._update = t, this;
  }, remove(t) {
    return this._remove = t, this;
  }, execute() {
    const t = this._old; const e = this._new; const i = {}; const n = []; const o = [];for (Pf(t, {}, n, '_oldKeyGetter', this), Pf(e, i, o, '_newKeyGetter', this), a = 0;a < t.length;a++) {
      if (null != (s = i[r = n[a]]))(u = s.length) ? (1 === u && (i[r] = null), s = s.shift()) : i[r] = null, this._update && this._update(s, a);else this._remove && this._remove(a);
    } for (var a = 0;a < o.length;a++) {
      var r = o[a];if (i.hasOwnProperty(r)) {
        var s;if (null == (s = i[r])) continue;if (s.length) for (var l = 0, u = s.length;l < u;l++) this._add && this._add(s[l]);else this._add && this._add(s);
      }
    }
  } };const Nf = Q(['tooltip', 'label', 'itemName', 'itemId', 'seriesName']);function Of(t, e) {
    return t.hasOwnProperty(e) || (t[e] = []), t[e];
  } function Rf(t) {
    return 'category' === t ? 'ordinal' : 'time' === t ? 'time' : 'float';
  } function Ef(t) {
    null != t && P(this, t), this.otherDims = {};
  } const zf = z; const Bf = 'undefined'; const Vf = { float: typeof Float64Array === Bf ? Array : Float64Array, int: typeof Int32Array === Bf ? Array : Int32Array, ordinal: Array, number: Array, time: Array }; const Gf = typeof Uint32Array === Bf ? Array : Uint32Array; const Ff = typeof Int32Array === Bf ? Array : Int32Array; const Wf = typeof Uint16Array === Bf ? Array : Uint16Array;function Hf(t) {
    return 65535 < t._rawCount ? Gf : Wf;
  } const Zf = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx']; const Uf = ['_extent', '_approximateExtent', '_rawExtent'];function Xf(e, i) {
    R(Zf.concat(i.__wrappedMethods || []), (t) => {
      i.hasOwnProperty(t) && (e[t] = i[t]);
    }), e.__wrappedMethods = i.__wrappedMethods, R(Uf, (t) => {
      e[t] = k(i[t]);
    }), e._calculationInfo = P(i._calculationInfo);
  } const Yf = function (t, e) {
    t = t || ['x', 'y'];for (var i = {}, n = [], o = {}, a = 0;a < t.length;a++) {
      let r = t[a];E(r) ? r = new Ef({ name: r }) : r instanceof Ef || (r = new Ef(r));const s = r.name;r.type = r.type || 'float', r.coordDim || (r.coordDim = s, r.coordDimIndex = 0), r.otherDims = r.otherDims || {}, n.push(s), (i[s] = r).index = a, r.createInvertedIndices && (o[s] = []);
    } this.dimensions = n, this._dimensionInfos = i, this.hostModel = e, this.dataType, this._indices = null, this._count = 0, this._rawCount = 0, this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this.hasItemVisual = {}, this._itemLayouts = [], this._graphicEls = [], this._chunkSize = 1e5, this._chunkCount = 0, this._rawData, this._rawExtent = {}, this._extent = {}, this._approximateExtent = {}, this._dimensionsSummary = (function (n) {
      const t = {}; const a = t.encode = {}; const r = Q(); let s = []; let l = []; const u = t.userOutput = { dimensionNames: n.dimensions.slice(), encode: {} };R(n.dimensions, (t) => {
        const o = n.getDimensionInfo(t); const e = o.coordDim;if (e) {
          const i = o.coordDimIndex;Of(a, e)[i] = t, o.isExtraCoord || (r.set(e, 1), (function (t) {
            return !('ordinal' === t || 'time' === t);
          }(o.type)) && (s[0] = t), Of(u.encode, e)[i] = o.index), o.defaultTooltip && l.push(t);
        }Nf.each((t, e) => {
          const i = Of(a, e); const n = o.otherDims[e];null != n && !1 !== n && (i[n] = o.name);
        });
      });let o = []; const h = {};r.each((t, e) => {
        const i = a[e];h[e] = i[0], o = o.concat(i);
      }), t.dataDimsOnCoord = o, t.encodeFirstDimNotExtra = h;const e = a.label;e && e.length && (s = e.slice());const i = a.tooltip;return i && i.length ? l = i.slice() : l.length || (l = s.slice()), a.defaultedLabel = s, a.defaultedTooltip = l, t;
    }(this)), this._invertedIndicesMap = o, this._calculationInfo = {}, this.userOutput = this._dimensionsSummary.userOutput;
  }; const jf = Yf.prototype;function qf(t, e, i, n, o) {
    const a = Vf[e.type]; const r = n - 1; const s = e.name; const l = t[s][r];if (l && l.length < i) {
      for (var u = new a(Math.min(o - r * i, i)), h = 0;h < l.length;h++)u[h] = l[h];t[s][r] = u;
    } for (let c = n * i;c < o;c += i)t[s].push(new a(Math.min(o - c, i)));
  } function Kf(o) {
    const a = o._invertedIndicesMap;R(a, (t, e) => {
      const i = o._dimensionInfos[e].ordinalMeta;if (i) {
        t = a[e] = new Ff(i.categories.length);for (var n = 0;n < t.length;n++)t[n] = -1;for (n = 0;n < o._count;n++)t[o.get(e, n)] = n;
      }
    });
  } function $f(t, e, i) {
    let n;if (null != e) {
      const o = t._chunkSize; const a = Math.floor(i / o); const r = i % o; const s = t.dimensions[e]; const l = t._storage[s][a];if (l) {
        n = l[r];const u = t._dimensionInfos[s].ordinalMeta;u && u.categories.length && (n = u.categories[n]);
      }
    } return n;
  } function Jf(t) {
    return t;
  } function Qf(t) {
    return t < this._count && 0 <= t ? this._indices[t] : -1;
  } function tp(t, e) {
    let i = t._idList[e];return null == i && (i = $f(t, t._idDimIdx, e)), null == i && (i = `e\0\0${e}`), i;
  } function ep(t) {
    return L(t) || (t = [t]), t;
  } function ip(t, e) {
    const i = t.dimensions; const n = new Yf(O(i, t.getDimensionInfo, t), t.hostModel);Xf(n, t);for (let o = n._storage = {}, a = t._storage, r = 0;r < i.length;r++) {
      const s = i[r];a[s] && (0 <= _(e, s) ? (o[s] = np(a[s]), n._rawExtent[s] = op(), n._extent[s] = null) : o[s] = a[s]);
    } return n;
  } function np(t) {
    for (var e, i, n = new Array(t.length), o = 0;o < t.length;o++)n[o] = (e = t[o], i = void 0, (i = e.constructor) === Array ? e.slice() : new i(e));return n;
  } function op() {
    return [1 / 0, -1 / 0];
  }jf.type = 'list', jf.hasItemOption = !0, jf.getDimension = function (t) {
    return 'number' !== typeof t && (isNaN(t) || this._dimensionInfos.hasOwnProperty(t)) || (t = this.dimensions[t]), t;
  }, jf.getDimensionInfo = function (t) {
    return this._dimensionInfos[this.getDimension(t)];
  }, jf.getDimensionsOnCoord = function () {
    return this._dimensionsSummary.dataDimsOnCoord.slice();
  }, jf.mapDimension = function (t, e) {
    const i = this._dimensionsSummary;if (null == e) return i.encodeFirstDimNotExtra[t];const n = i.encode[t];return !0 === e ? (n || []).slice() : n && n[e];
  }, jf.initData = function (t, e, i) {
    (Uu.isInstance(t) || N(t)) && (t = new Ph(t, this.dimensions.length)), this._rawData = t, this._storage = {}, this._indices = null, this._nameList = e || [], this._idList = [], this._nameRepeatCount = {}, i || (this.hasItemOption = !1), this.defaultDimValueGetter = Gh[this._rawData.getSource().sourceFormat], this._dimValueGetter = i = i || this.defaultDimValueGetter, this._dimValueGetterArrayRows = Gh.arrayRows, this._rawExtent = {}, this._initDataFromProvider(0, t.count()), t.pure && (this.hasItemOption = !1);
  }, jf.getProvider = function () {
    return this._rawData;
  }, jf.appendData = function (t) {
    const e = this._rawData; const i = this.count();e.appendData(t);let n = e.count();e.persistent || (n += i), this._initDataFromProvider(i, n);
  }, jf.appendValues = function (t, e) {
    for (var i = this._chunkSize, n = this._storage, o = this.dimensions, a = o.length, r = this._rawExtent, s = this.count(), l = s + Math.max(t.length, e ? e.length : 0), u = this._chunkCount, h = 0;h < a;h++) {
      r[v = o[h]] || (r[v] = op()), n[v] || (n[v] = []), qf(n, this._dimensionInfos[v], i, u, l), this._chunkCount = n[v].length;
    } for (let c = new Array(a), d = s;d < l;d++) {
      for (var f = d - s, p = Math.floor(d / i), g = d % i, m = 0;m < a;m++) {
        var v = o[m]; const y = this._dimValueGetterArrayRows(t[f] || c, v, f, m);n[v][p][g] = y;const x = r[v];y < x[0] && (x[0] = y), y > x[1] && (x[1] = y);
      }e && (this._nameList[d] = e[f]);
    } this._rawCount = this._count = l, this._extent = {}, Kf(this);
  }, jf._initDataFromProvider = function (t, e) {
    if (!(e <= t)) {
      for (var i, n = this._chunkSize, o = this._rawData, a = this._storage, r = this.dimensions, s = r.length, l = this._dimensionInfos, u = this._nameList, h = this._idList, c = this._rawExtent, d = this._nameRepeatCount = {}, f = this._chunkCount, p = 0;p < s;p++) {
        c[w = r[p]] || (c[w] = op());const g = l[w];0 === g.otherDims.itemName && (i = this._nameDimIdx = p), 0 === g.otherDims.itemId && (this._idDimIdx = p), a[w] || (a[w] = []), qf(a, g, n, f, e), this._chunkCount = a[w].length;
      } for (let m = new Array(s), v = t;v < e;v++) {
        m = o.getItem(v, m);for (var y = Math.floor(v / n), x = v % n, _ = 0;_ < s;_++) {
          var w; const b = a[w = r[_]][y]; const S = this._dimValueGetter(m, w, v, _);b[x] = S;const M = c[w];S < M[0] && (M[0] = S), S > M[1] && (M[1] = S);
        } if (!o.pure) {
          let I = u[v];if (m && null == I) if (null != m.name)u[v] = I = m.name;else if (null != i) {
            const T = r[i]; const A = a[T][y];if (A) {
              I = A[x];const D = l[T].ordinalMeta;D && D.categories.length && (I = D.categories[I]);
            }
          } let C = null == m ? null : m.id;null == C && null != I && (d[I] = d[I] || 0, 0 < d[C = I] && (C += `__ec__${d[I]}`), d[I]++), null != C && (h[v] = C);
        }
      }!o.persistent && o.clean && o.clean(), this._rawCount = this._count = e, this._extent = {}, Kf(this);
    }
  }, jf.count = function () {
    return this._count;
  }, jf.getIndices = function () {
    const t = this._indices;if (t) {
      var e = t.constructor; const i = this._count;if (e === Array) {
        o = new e(i);for (var n = 0;n < i;n++)o[n] = t[n];
      } else o = new e(t.buffer, 0, i);
    } else {
      var o = new(e = Hf(this))(this.count());for (n = 0;n < o.length;n++)o[n] = n;
    } return o;
  }, jf.get = function (t, e) {
    if (!(0 <= e && e < this._count)) return NaN;const i = this._storage;if (!i[t]) return NaN;e = this.getRawIndex(e);const n = Math.floor(e / this._chunkSize); const o = e % this._chunkSize;return i[t][n][o];
  }, jf.getByRawIndex = function (t, e) {
    if (!(0 <= e && e < this._rawCount)) return NaN;const i = this._storage[t];if (!i) return NaN;const n = Math.floor(e / this._chunkSize); const o = e % this._chunkSize;return i[n][o];
  }, jf._getFast = function (t, e) {
    const i = Math.floor(e / this._chunkSize); const n = e % this._chunkSize;return this._storage[t][i][n];
  }, jf.getValues = function (t, e) {
    const i = [];L(t) || (e = t, t = this.dimensions);for (let n = 0, o = t.length;n < o;n++)i.push(this.get(t[n], e));return i;
  }, jf.hasValue = function (t) {
    for (let e = this._dimensionsSummary.dataDimsOnCoord, i = 0, n = e.length;i < n;i++) if (isNaN(this.get(e[i], t))) return !1;return !0;
  }, jf.getDataExtent = function (t) {
    t = this.getDimension(t);const e = this._storage[t]; const i = op();if (!e) return i;let n; const o = this.count();if (!this._indices) return this._rawExtent[t].slice();if (n = this._extent[t]) return n.slice();for (var a = (n = i)[0], r = n[1], s = 0;s < o;s++) {
      const l = this._getFast(t, this.getRawIndex(s));l < a && (a = l), r < l && (r = l);
    } return n = [a, r], this._extent[t] = n;
  }, jf.getApproximateExtent = function (t) {
    return t = this.getDimension(t), this._approximateExtent[t] || this.getDataExtent(t);
  }, jf.setApproximateExtent = function (t, e) {
    e = this.getDimension(e), this._approximateExtent[e] = t.slice();
  }, jf.getCalculationInfo = function (t) {
    return this._calculationInfo[t];
  }, jf.setCalculationInfo = function (t, e) {
    zf(t) ? P(this._calculationInfo, t) : this._calculationInfo[t] = e;
  }, jf.getSum = function (t) {
    let e = 0;if (this._storage[t]) for (let i = 0, n = this.count();i < n;i++) {
      const o = this.get(t, i);isNaN(o) || (e += o);
    } return e;
  }, jf.getMedian = function (t) {
    const i = [];this.each(t, (t, e) => {
      isNaN(t) || i.push(t);
    });const e = [].concat(i).sort((t, e) => t - e); const n = this.count();return 0 === n ? 0 : n % 2 == 1 ? e[(n - 1) / 2] : (e[n / 2] + e[n / 2 - 1]) / 2;
  }, jf.rawIndexOf = function (t, e) {
    const i = (t && this._invertedIndicesMap[t])[e];return null == i || isNaN(i) ? -1 : i;
  }, jf.indexOfName = function (t) {
    for (let e = 0, i = this.count();e < i;e++) if (this.getName(e) === t) return e;return -1;
  }, jf.indexOfRawIndex = function (t) {
    if (t >= this._rawCount || t < 0) return -1;if (!this._indices) return t;const e = this._indices; const i = e[t];if (null != i && i < this._count && i === t) return t;for (let n = 0, o = this._count - 1;n <= o;) {
      const a = (n + o) / 2 | 0;if (e[a] < t)n = 1 + a;else {
        if (!(e[a] > t)) return a;o = a - 1;
      }
    } return -1;
  }, jf.indicesOfNearest = function (t, e, i) {
    const n = [];if (!this._storage[t]) return n;null == i && (i = 1 / 0);for (var o = 1 / 0, a = -1, r = 0, s = 0, l = this.count();s < l;s++) {
      const u = e - this.get(t, s); const h = Math.abs(u);h <= i && ((h < o || h === o && 0 <= u && a < 0) && (o = h, a = u, r = 0), u === a && (n[r++] = s));
    } return n.length = r, n;
  }, jf.getRawIndex = Jf, jf.getRawDataItem = function (t) {
    if (this._rawData.persistent) return this._rawData.getItem(this.getRawIndex(t));for (var e = [], i = 0;i < this.dimensions.length;i++) {
      const n = this.dimensions[i];e.push(this.get(n, t));
    } return e;
  }, jf.getName = function (t) {
    const e = this.getRawIndex(t);return this._nameList[e] || $f(this, this._nameDimIdx, e) || '';
  }, jf.getId = function (t) {
    return tp(this, this.getRawIndex(t));
  }, jf.each = function (t, e, i, n) {
    if (this._count) {
      'function' === typeof t && (n = i, i = e, e = t, t = []), i = i || n || this;for (let o = (t = O(ep(t), this.getDimension, this)).length, a = 0;a < this.count();a++) switch (o) {
        case 0:e.call(i, a);break;case 1:e.call(i, this.get(t[0], a), a);break;case 2:e.call(i, this.get(t[0], a), this.get(t[1], a), a);break;default:for (var r = 0, s = [];r < o;r++)s[r] = this.get(t[r], a);s[r] = a, e.apply(i, s);
      }
    }
  }, jf.filterSelf = function (t, e, i, n) {
    if (this._count) {
      'function' === typeof t && (n = i, i = e, e = t, t = []), i = i || n || this, t = O(ep(t), this.getDimension, this);for (var o = this.count(), a = new(Hf(this))(o), r = [], s = t.length, l = 0, u = t[0], h = 0;h < o;h++) {
        var c; const d = this.getRawIndex(h);if (0 === s)c = e.call(i, h);else if (1 === s) {
          const f = this._getFast(u, d);c = e.call(i, f, h);
        } else {
          for (var p = 0;p < s;p++)r[p] = this._getFast(u, d);r[p] = h, c = e.apply(i, r);
        }c && (a[l++] = d);
      } return l < o && (this._indices = a), this._count = l, this._extent = {}, this.getRawIndex = this._indices ? Qf : Jf, this;
    }
  }, jf.selectRange = function (t) {
    if (this._count) {
      const e = [];for (var i in t)t.hasOwnProperty(i) && e.push(i);const n = e.length;if (n) {
        const o = this.count(); const a = new(Hf(this))(o); let r = 0; const s = e[0]; const l = t[s][0]; const u = t[s][1]; let h = !1;if (!this._indices) {
          let c = 0;if (1 === n) {
            for (var d = this._storage[e[0]], f = 0;f < this._chunkCount;f++) for (var p = d[f], g = Math.min(this._count - f * this._chunkSize, this._chunkSize), m = 0;m < g;m++) {
              (l <= (w = p[m]) && w <= u || isNaN(w)) && (a[r++] = c), c++;
            }h = !0;
          } else if (2 === n) {
            d = this._storage[s];const v = this._storage[e[1]]; const y = t[e[1]][0]; const x = t[e[1]][1];for (f = 0;f < this._chunkCount;f++) {
              p = d[f];const _ = v[f];for (g = Math.min(this._count - f * this._chunkSize, this._chunkSize), m = 0;m < g;m++) {
                var w = p[m]; const b = _[m];(l <= w && w <= u || isNaN(w)) && (y <= b && b <= x || isNaN(b)) && (a[r++] = c), c++;
              }
            }h = !0;
          }
        } if (!h) if (1 === n) for (m = 0;m < o;m++) {
          var S = this.getRawIndex(m);(l <= (w = this._getFast(s, S)) && w <= u || isNaN(w)) && (a[r++] = S);
        } else for (m = 0;m < o;m++) {
          let M = !0;for (S = this.getRawIndex(m), f = 0;f < n;f++) {
            const I = e[f];((w = this._getFast(i, S)) < t[I][0] || w > t[I][1]) && (M = !1);
          }M && (a[r++] = this.getRawIndex(m));
        } return r < o && (this._indices = a), this._count = r, this._extent = {}, this.getRawIndex = this._indices ? Qf : Jf, this;
      }
    }
  }, jf.mapArray = function (t, e, i, n) {
    'function' === typeof t && (n = i, i = e, e = t, t = []), i = i || n || this;const o = [];return this.each(t, function () {
      o.push(e && e.apply(this, arguments));
    }, i), o;
  }, jf.map = function (t, e, i, n) {
    i = i || n || this;const o = ip(this, t = O(ep(t), this.getDimension, this));o._indices = this._indices, o.getRawIndex = o._indices ? Qf : Jf;for (let a = o._storage, r = [], s = this._chunkSize, l = t.length, u = this.count(), h = [], c = o._rawExtent, d = 0;d < u;d++) {
      for (let f = 0;f < l;f++)h[f] = this.get(t[f], d);h[l] = d;let p = e && e.apply(i, h);if (null != p) {
        'object' !== typeof p && (r[0] = p, p = r);for (let g = this.getRawIndex(d), m = Math.floor(g / s), v = g % s, y = 0;y < p.length;y++) {
          const x = t[y]; const _ = p[y]; const w = c[x]; const b = a[x];b && (b[m][v] = _), _ < w[0] && (w[0] = _), _ > w[1] && (w[1] = _);
        }
      }
    } return o;
  }, jf.downSample = function (t, e, i, n) {
    for (var o = ip(this, [t]), a = o._storage, r = [], s = Math.floor(1 / e), l = a[t], u = this.count(), h = this._chunkSize, c = o._rawExtent[t], d = new(Hf(this))(u), f = 0, p = 0;p < u;p += s) {
      u - p < s && (s = u - p, r.length = s);for (let g = 0;g < s;g++) {
        const m = this.getRawIndex(p + g); const v = Math.floor(m / h); const y = m % h;r[g] = l[v][y];
      } const x = i(r); const _ = this.getRawIndex(Math.min(p + n(r, x) || 0, u - 1)); const w = _ % h;(l[Math.floor(_ / h)][w] = x) < c[0] && (c[0] = x), x > c[1] && (c[1] = x), d[f++] = _;
    } return o._count = f, o._indices = d, o.getRawIndex = Qf, o;
  }, jf.getItemModel = function (t) {
    const e = this.hostModel;return new Cl(this.getRawDataItem(t), e, e && e.ecModel);
  }, jf.diff = function (e) {
    const i = this;return new kf(e ? e.getIndices() : [], this.getIndices(), (t => tp(e, t)), (t => tp(i, t)));
  }, jf.getVisual = function (t) {
    const e = this._visual;return e && e[t];
  }, jf.setVisual = function (t, e) {
    if (zf(t)) for (const i in t)t.hasOwnProperty(i) && this.setVisual(i, t[i]);else this._visual = this._visual || {}, this._visual[t] = e;
  }, jf.setLayout = function (t, e) {
    if (zf(t)) for (const i in t)t.hasOwnProperty(i) && this.setLayout(i, t[i]);else this._layout[t] = e;
  }, jf.getLayout = function (t) {
    return this._layout[t];
  }, jf.getItemLayout = function (t) {
    return this._itemLayouts[t];
  }, jf.setItemLayout = function (t, e, i) {
    this._itemLayouts[t] = i ? P(this._itemLayouts[t] || {}, e) : e;
  }, jf.clearItemLayouts = function () {
    this._itemLayouts.length = 0;
  }, jf.getItemVisual = function (t, e, i) {
    const n = this._itemVisuals[t]; const o = n && n[e];return null != o || i ? o : this.getVisual(e);
  }, jf.setItemVisual = function (t, e, i) {
    const n = this._itemVisuals[t] || {}; const o = this.hasItemVisual;if (this._itemVisuals[t] = n, zf(e)) for (const a in e)e.hasOwnProperty(a) && (n[a] = e[a], o[a] = !0);else n[e] = i, o[e] = !0;
  }, jf.clearAllVisual = function () {
    this._visual = {}, this._itemVisuals = [], this.hasItemVisual = {};
  };function ap(t) {
    t.seriesIndex = this.seriesIndex, t.dataIndex = this.dataIndex, t.dataType = this.dataType;
  } function rp(t, e, i) {
    Uu.isInstance(e) || (e = Uu.seriesDataToSource(e)), i = i || {}, t = (t || []).slice();for (var n = (i.dimsDef || []).slice(), o = Q(), a = Q(), l = [], r = (function (t, e, i, n) {
        let o = Math.max(t.dimensionsDetectCount || 1, e.length, i.length, n || 0);return R(e, (t) => {
          const e = t.dimsDef;e && (o = Math.max(o, e.length));
        }), o;
      }(e, t, n, i.dimCount)), s = 0;s < r;s++) {
      const u = n[s] = P({}, z(n[s]) ? n[s] : { name: n[s] }); const h = u.name; var c = l[s] = new Ef;null != h && null == o.get(h) && (c.name = c.displayName = h, o.set(h, s)), null != u.type && (c.type = u.type), null != u.displayName && (c.displayName = u.displayName);
    } let d = i.encodeDef;!d && i.encodeDefaulter && (d = i.encodeDefaulter(e, r)), (d = Q(d)).each((t, i) => {
      if (1 === (t = Vo(t).slice()).length && !E(t[0]) && t[0] < 0)d.set(i, !1);else {
        const n = d.set(i, []);R(t, (t, e) => {
          E(t) && (t = o.get(t)), null != t && t < r && (n[e] = t, p(l[t], i, e));
        });
      }
    });let f = 0;function p(t, e, i) {
      null != Nf.get(e) ? t.otherDims[e] = i : (t.coordDim = e, t.coordDimIndex = i, a.set(e, !0));
    }R(t, (o, t) => {
      let a; let r; let s;if (E(o))a = o, o = {};else {
        a = o.name;const e = o.ordinalMeta;o.ordinalMeta = null, (o = k(o)).ordinalMeta = e, r = o.dimsDef, s = o.otherDims, o.name = o.coordDim = o.coordDimIndex = o.dimsDef = o.otherDims = null;
      } if (!1 !== (i = d.get(a))) {
        var i;if (!(i = Vo(i)).length) for (let n = 0;n < (r && r.length || 1);n++) {
          for (;f < l.length && null != l[f].coordDim;)f++;f < l.length && i.push(f++);
        }R(i, (t, e) => {
          const i = l[t];if (p(D(i, o), a, e), null == i.name && r) {
            let n = r[e];z(n) || (n = { name: n }), i.name = i.displayName = n.name, i.defaultTooltip = n.defaultTooltip;
          }s && D(i.otherDims, s);
        });
      }
    });const g = i.generateCoord; let m = i.generateCoordCount; const v = null != m;m = g ? m || 1 : 0;for (var y, x, _ = g || 'value', w = 0;w < r;w++) {
      null == (c = l[w] = l[w] || new Ef).coordDim && (c.coordDim = sp(_, a, v), c.coordDimIndex = 0, (!g || m <= 0) && (c.isExtraCoord = !0), m--), null == c.name && (c.name = sp(c.coordDim, o)), null == c.type && (y = e, x = w, c.name, th(y.data, y.sourceFormat, y.seriesLayoutBy, y.dimensionsDefine, y.startIndex, x) === Xu.Must || c.isExtraCoord && (null != c.otherDims.itemName || null != c.otherDims.seriesName)) && (c.type = 'ordinal');
    } return l;
  } function sp(t, e, i) {
    if (i || null != e.get(t)) {
      for (var n = 0;null != e.get(t + n);)n++;t += n;
    } return e.set(t, !0), t;
  }jf.setItemGraphicEl = function (t, e) {
    const i = this.hostModel;e && (e.dataIndex = t, e.dataType = this.dataType, e.seriesIndex = i && i.seriesIndex, 'group' === e.type && e.traverse(ap, e)), this._graphicEls[t] = e;
  }, jf.getItemGraphicEl = function (t) {
    return this._graphicEls[t];
  }, jf.eachItemGraphicEl = function (i, n) {
    R(this._graphicEls, (t, e) => {
      t && i && i.call(n, t, e);
    });
  }, jf.cloneShallow = function (t) {
    if (!t) {
      const e = O(this.dimensions, this.getDimensionInfo, this);t = new Yf(e, this.hostModel);
    } if (t._storage = this._storage, Xf(t, this), this._indices) {
      const i = this._indices.constructor;t._indices = new i(this._indices);
    } else t._indices = null;return t.getRawIndex = t._indices ? Qf : Jf, t;
  }, jf.wrapMethod = function (t, e) {
    const i = this[t];'function' === typeof i && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function () {
      const t = i.apply(this, arguments);return e.apply(this, [t].concat(U(arguments)));
    });
  }, jf.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'], jf.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];const lp = function (t, e) {
    return rp((e = e || {}).coordDimensions || [], t, { dimsDef: e.dimensionsDefine || t.dimensionsDefine, encodeDef: e.encodeDefine || t.encodeDefine, dimCount: e.dimensionsCount, encodeDefaulter: e.encodeDefaulter, generateCoord: e.generateCoord, generateCoordCount: e.generateCoordCount });
  };function up(t) {
    this.coordSysName = t, this.coordSysDims = [], this.axisMap = Q(), this.categoryAxisMap = Q(), this.firstCategoryDimIndex = null;
  } const hp = { cartesian2d(t, e, i, n) {
    const o = t.getReferringComponents('xAxis')[0]; const a = t.getReferringComponents('yAxis')[0];e.coordSysDims = ['x', 'y'], i.set('x', o), i.set('y', a), cp(o) && (n.set('x', o), e.firstCategoryDimIndex = 0), cp(a) && (n.set('y', a), e.firstCategoryDimIndex, e.firstCategoryDimIndex = 1);
  }, singleAxis(t, e, i, n) {
    const o = t.getReferringComponents('singleAxis')[0];e.coordSysDims = ['single'], i.set('single', o), cp(o) && (n.set('single', o), e.firstCategoryDimIndex = 0);
  }, polar(t, e, i, n) {
    const o = t.getReferringComponents('polar')[0]; const a = o.findAxisModel('radiusAxis'); const r = o.findAxisModel('angleAxis');e.coordSysDims = ['radius', 'angle'], i.set('radius', a), i.set('angle', r), cp(a) && (n.set('radius', a), e.firstCategoryDimIndex = 0), cp(r) && (n.set('angle', r), null == e.firstCategoryDimIndex && (e.firstCategoryDimIndex = 1));
  }, geo(t, e, i, n) {
    e.coordSysDims = ['lng', 'lat'];
  }, parallel(t, o, a, r) {
    const s = t.ecModel; const e = s.getComponent('parallel', t.get('parallelIndex')); const l = o.coordSysDims = e.dimensions.slice();R(e.parallelAxisIndex, (t, e) => {
      const i = s.getComponent('parallelAxis', t); const n = l[e];a.set(n, i), cp(i) && null == o.firstCategoryDimIndex && (r.set(n, i), o.firstCategoryDimIndex = e);
    });
  } };function cp(t) {
    return 'category' === t.get('type');
  } function dp(t, i, e) {
    let n; let o; let a; let r; let s = (e = e || {}).byIndex; const l = e.stackedCoordDimension; const u = !(!t || !t.get('stack'));if (R(i, (t, e) => {
      E(t) && (i[e] = t = { name: t }), u && !t.isExtraCoord && (s || n || !t.ordinalMeta || (n = t), o || 'ordinal' === t.type || 'time' === t.type || l && l !== t.coordDim || (o = t));
    }), !o || s || n || (s = !0), o) {
      a = '__\0ecstackresult', r = '__\0ecstackedover', n && (n.createInvertedIndices = !0);const h = o.coordDim; const c = o.type; let d = 0;R(i, (t) => {
        t.coordDim === h && d++;
      }), i.push({ name: a, coordDim: h, coordDimIndex: d, type: c, isExtraCoord: !0, isCalculationCoord: !0 }), d++, i.push({ name: r, coordDim: r, coordDimIndex: d, type: c, isExtraCoord: !0, isCalculationCoord: !0 });
    } return { stackedDimension: o && o.name, stackedByDimension: n && n.name, isStackedByIndex: s, stackedOverDimension: r, stackResultDimension: a };
  } function fp(t, e) {
    return !!e && e === t.getCalculationInfo('stackedDimension');
  } function pp(t, e) {
    return fp(t, e) ? t.getCalculationInfo('stackResultDimension') : e;
  } function gp(t, e, i) {
    i = i || {}, Uu.isInstance(t) || (t = Uu.seriesDataToSource(t));let n; const o = e.get('coordinateSystem'); const a = lh.get(o); const r = (function (t) {
      const e = t.get('coordinateSystem'); const i = new up(e); const n = hp[e];if (n) return n(t, i, i.axisMap, i.categoryAxisMap), i;
    }(e));r && (n = O(r.coordSysDims, (t) => {
      const e = { name: t }; const i = r.axisMap.get(t);if (i) {
        const n = i.get('type');e.type = Rf(n);
      } return e;
    })), n = n || (a && (a.getDimensionsInfo ? a.getDimensionsInfo() : a.dimensions.slice()) || ['x', 'y']);let s; let l; const u = lp(t, { coordDimensions: n, generateCoord: i.generateCoord, encodeDefaulter: i.useEncodeDefaulter ? T($u, n, e) : null });r && R(u, (t, e) => {
      const i = t.coordDim; const n = r.categoryAxisMap.get(i);n && (null == s && (s = e), t.ordinalMeta = n.getOrdinalMeta()), null != t.otherDims.itemName && (l = !0);
    }), l || null == s || (u[s].otherDims.itemName = 0);const h = dp(e, u); const c = new Yf(u, e);c.setCalculationInfo(h);const d = null != s && (function (t) {
      if (t.sourceFormat === zu) {
        const e = (function (t) {
          let e = 0;for (;e < t.length && null == t[e];)e++;return t[e];
        }(t.data || []));return null != e && !L(Wo(e));
      }
    }(t)) ? function (t, e, i, n) {
        return n === s ? i : this.defaultDimValueGetter(t, e, i, n);
      } : null;return c.hasItemOption = !1, c.initData(t, null, d), c;
  } function mp(t) {
    this._setting = t || {}, this._extent = [1 / 0, -1 / 0], this._interval = 0, this.init && this.init.apply(this, arguments);
  } function vp(t) {
    this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this._map;
  }mp.prototype.parse = function (t) {
    return t;
  }, mp.prototype.getSetting = function (t) {
    return this._setting[t];
  }, mp.prototype.contain = function (t) {
    const e = this._extent;return t >= e[0] && t <= e[1];
  }, mp.prototype.normalize = function (t) {
    const e = this._extent;return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0]);
  }, mp.prototype.scale = function (t) {
    const e = this._extent;return t * (e[1] - e[0]) + e[0];
  }, mp.prototype.unionExtent = function (t) {
    const e = this._extent;t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]);
  }, mp.prototype.unionExtentFromData = function (t, e) {
    this.unionExtent(t.getApproximateExtent(e));
  }, mp.prototype.getExtent = function () {
    return this._extent.slice();
  }, mp.prototype.setExtent = function (t, e) {
    const i = this._extent;isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e);
  }, mp.prototype.isBlank = function () {
    return this._isBlank;
  }, mp.prototype.setBlank = function (t) {
    this._isBlank = t;
  }, mp.prototype.getLabel = null, oa(mp), ua(mp, { registerWhenExtend: !0 }), vp.createByAxisModel = function (t) {
    const e = t.option; const i = e.data; const n = i && O(i, _p);return new vp({ categories: n, needCollect: !n, deduplication: !1 !== e.dedplication });
  };const yp = vp.prototype;function xp(t) {
    return t._map || (t._map = Q(t.categories));
  } function _p(t) {
    return z(t) && null != t.value ? t.value : `${t}`;
  }yp.getOrdinal = function (t) {
    return xp(this).get(t);
  }, yp.parseAndCollect = function (t) {
    let e; const i = this._needCollect;if ('string' !== typeof t && !i) return t;if (i && !this._deduplication) return e = this.categories.length, this.categories[e] = t, e;const n = xp(this);return null == (e = n.get(t)) && (i ? (e = this.categories.length, this.categories[e] = t, n.set(t, e)) : e = NaN), e;
  };const wp = mp.prototype; const bp = mp.extend({ type: 'ordinal', init(t, e) {
    t && !L(t) || (t = new vp({ categories: t })), this._ordinalMeta = t, this._extent = e || [0, t.categories.length - 1];
  }, parse(t) {
    return 'string' === typeof t ? this._ordinalMeta.getOrdinal(t) : Math.round(t);
  }, contain(t) {
    return t = this.parse(t), wp.contain.call(this, t) && null != this._ordinalMeta.categories[t];
  }, normalize(t) {
    return wp.normalize.call(this, this.parse(t));
  }, scale(t) {
    return Math.round(wp.scale.call(this, t));
  }, getTicks() {
    for (var t = [], e = this._extent, i = e[0];i <= e[1];)t.push(i), i++;return t;
  }, getLabel(t) {
    if (!this.isBlank()) return this._ordinalMeta.categories[t];
  }, count() {
    return this._extent[1] - this._extent[0] + 1;
  }, unionExtentFromData(t, e) {
    this.unionExtent(t.getApproximateExtent(e));
  }, getOrdinalMeta() {
    return this._ordinalMeta;
  }, niceTicks: et, niceExtent: et });bp.create = function () {
    return new bp;
  };const Sp = zl;function Mp(t) {
    return Gl(t) + 2;
  } function Ip(t, e, i) {
    t[e] = Math.max(Math.min(t[e], i[1]), i[0]);
  } function Tp(t, e) {
    isFinite(t[0]) || (t[0] = e[0]), isFinite(t[1]) || (t[1] = e[1]), Ip(t, 0, e), Ip(t, 1, e), t[0] > t[1] && (t[0] = t[1]);
  } const Ap = zl; var Dp = mp.extend({ type: 'interval', _interval: 0, _intervalPrecision: 2, setExtent(t, e) {
    const i = this._extent;isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e));
  }, unionExtent(t) {
    const e = this._extent;t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), Dp.prototype.setExtent.call(this, e[0], e[1]);
  }, getInterval() {
    return this._interval;
  }, setInterval(t) {
    this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = Mp(t);
  }, getTicks(t) {
    const e = this._interval; const i = this._extent; const n = this._niceExtent; const o = this._intervalPrecision; const a = [];if (!e) return a;i[0] < n[0] && (t ? a.push(Ap(n[0] - e, o)) : a.push(i[0]));for (let r = n[0];r <= n[1] && (a.push(r), (r = Ap(r + e, o)) !== a[a.length - 1]);) if (1e4 < a.length) return [];const s = a.length ? a[a.length - 1] : n[1];return i[1] > s && (t ? a.push(Ap(s + e, o)) : a.push(i[1])), a;
  }, getMinorTicks(t) {
    for (var e = this.getTicks(!0), i = [], n = this.getExtent(), o = 1;o < e.length;o++) {
      for (var a = e[o], r = e[o - 1], s = 0, l = [], u = (a - r) / t;s < t - 1;) {
        const h = zl(r + (s + 1) * u);h > n[0] && h < n[1] && l.push(h), s++;
      }i.push(l);
    } return i;
  }, getLabel(t, e) {
    if (null == t) return '';let i = e && e.precision;return null == i ? i = Gl(t) || 0 : 'auto' === i && (i = this._intervalPrecision), tu(t = Ap(t, i, !0));
  }, niceTicks(t, e, i) {
    t = t || 5;const n = this._extent; let o = n[1] - n[0];if (isFinite(o)) {
      o < 0 && (o = -o, n.reverse());const a = (function (t, e, i, n) {
        const o = {}; const a = t[1] - t[0]; let r = o.interval = Kl(a / e, !0);null != i && r < i && (r = o.interval = i), null != n && n < r && (r = o.interval = n);const s = o.intervalPrecision = Mp(r);return Tp(o.niceTickExtent = [Sp(Math.ceil(t[0] / r) * r, s), Sp(Math.floor(t[1] / r) * r, s)], t), o;
      }(n, t, e, i));this._intervalPrecision = a.intervalPrecision, this._interval = a.interval, this._niceExtent = a.niceTickExtent;
    }
  }, niceExtent(t) {
    const e = this._extent;if (e[0] === e[1]) if (0 !== e[0]) {
      const i = e[0];t.fixMax || (e[1] += i / 2), e[0] -= i / 2;
    } else e[1] = 1;const n = e[1] - e[0];isFinite(n) || (e[0] = 0, e[1] = 1), this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval);const o = this._interval;t.fixMin || (e[0] = Ap(Math.floor(e[0] / o) * o)), t.fixMax || (e[1] = Ap(Math.ceil(e[1] / o) * o));
  } });Dp.create = function () {
    return new Dp;
  };const Cp = '__ec_stack_'; const Lp = 'undefined' !== typeof Float32Array ? Float32Array : Array;function kp(t) {
    return t.get('stack') || Cp + t.seriesIndex;
  } function Pp(t) {
    return t.dim + t.index;
  } function Np(t, e) {
    const i = [];return e.eachSeriesByType(t, (t) => {
      Vp(t) && !Gp(t) && i.push(t);
    }), i;
  } function Op(t) {
    const g = (function (t) {
      const l = {};R(t, (t) => {
        const e = t.coordinateSystem.getBaseAxis();if ('time' === e.type || 'value' === e.type) for (let i = t.getData(), n = `${e.dim}_${e.index}`, o = i.mapDimension(e.dim), a = 0, r = i.count();a < r;++a) {
          const s = i.get(o, a);l[n] ? l[n].push(s) : l[n] = [s];
        }
      });const e = [];for (const i in l) if (l.hasOwnProperty(i)) {
        const n = l[i];if (n) {
          n.sort((t, e) => t - e);for (var o = null, a = 1;a < n.length;++a) {
            const r = n[a] - n[a - 1];0 < r && (o = null === o ? r : Math.min(o, r));
          }e[i] = o;
        }
      } return e;
    }(t)); const m = [];return R(t, (t) => {
      let e; const i = t.coordinateSystem.getBaseAxis(); const n = i.getExtent();if ('category' === i.type)e = i.getBandWidth();else if ('value' === i.type || 'time' === i.type) {
        const o = `${i.dim}_${i.index}`; const a = g[o]; const r = Math.abs(n[1] - n[0]); const s = i.scale.getExtent(); const l = Math.abs(s[1] - s[0]);e = a ? r / l * a : r;
      } else {
        const u = t.getData();e = Math.abs(n[1] - n[0]) / u.count();
      } const h = El(t.get('barWidth'), e); const c = El(t.get('barMaxWidth'), e); const d = El(t.get('barMinWidth') || 1, e); const f = t.get('barGap'); const p = t.get('barCategoryGap');m.push({ bandWidth: e, barWidth: h, barMaxWidth: c, barMinWidth: d, barGap: f, barCategoryGap: p, axisKey: Pp(i), stackId: kp(t) });
    }), Rp(m);
  } function Rp(t) {
    const d = {};R(t, (t, e) => {
      const i = t.axisKey; const n = t.bandWidth; const o = d[i] || { bandWidth: n, remainedWidth: n, autoWidthCount: 0, categoryGap: '20%', gap: '30%', stacks: {} }; const a = o.stacks;d[i] = o;const r = t.stackId;a[r] || o.autoWidthCount++, a[r] = a[r] || { width: 0, maxWidth: 0 };let s = t.barWidth;s && !a[r].width && (a[r].width = s, s = Math.min(o.remainedWidth, s), o.remainedWidth -= s);const l = t.barMaxWidth;l && (a[r].maxWidth = l);const u = t.barMinWidth;u && (a[r].minWidth = u);const h = t.barGap;null != h && (o.gap = h);const c = t.barCategoryGap;null != c && (o.categoryGap = c);
    });const f = {};return R(d, (t, i) => {
      f[i] = {};const e = t.stacks; const n = t.bandWidth; const o = El(t.categoryGap, n); const a = El(t.gap, 1); let r = t.remainedWidth; let s = t.autoWidthCount; let l = (r - o) / (s + (s - 1) * a);l = Math.max(l, 0), R(e, (t) => {
        const e = t.maxWidth; const i = t.minWidth;if (t.width) {
          n = t.width;e && (n = Math.min(n, e)), i && (n = Math.max(n, i)), t.width = n, r -= n + a * n, s--;
        } else {
          var n = l;e && e < n && (n = Math.min(e, r)), i && n < i && (n = i), n !== l && (t.width = n, r -= n + a * n, s--);
        }
      }), l = (r - o) / (s + (s - 1) * a), l = Math.max(l, 0);let u; let h = 0;R(e, (t, e) => {
        t.width || (t.width = l), h += (u = t).width * (1 + a);
      }), u && (h -= u.width * a);let c = -h / 2;R(e, (t, e) => {
        f[i][e] = f[i][e] || { bandWidth: n, offset: c, width: t.width }, c += t.width * (1 + a);
      });
    }), f;
  } function Ep(t, e, i) {
    if (t && e) {
      let n = t[Pp(e)];return null != n && null != i && (n = n[kp(i)]), n;
    }
  } function zp(t, e) {
    const i = Np(t, e); const T = Op(i); const A = {};R(i, (t) => {
      const e = t.getData(); const i = t.coordinateSystem; const n = i.getBaseAxis(); const o = kp(t); const a = T[Pp(n)][o]; const r = a.offset; const s = a.width; const l = i.getOtherAxis(n); const u = t.get('barMinHeight') || 0;A[o] = A[o] || [], e.setLayout({ bandWidth: a.bandWidth, offset: r, size: s });for (let h = e.mapDimension(l.dim), c = e.mapDimension(n.dim), d = fp(e, h), f = l.isHorizontal(), p = Fp(n, l, d), g = 0, m = e.count();g < m;g++) {
        var v; var y; var x; var _; var w; const b = e.get(h, g); const S = e.get(c, g); const M = 0 <= b ? 'p' : 'n'; let I = p;if (d && (A[o][S] || (A[o][S] = { p, n: p }), I = A[o][S][M]), f)v = I, y = (w = i.dataToPoint([b, S]))[1] + r, x = w[0] - p, _ = s, Math.abs(x) < u && (x = (x < 0 ? -1 : 1) * u), isNaN(x) || d && (A[o][S][M] += x);else v = (w = i.dataToPoint([S, b]))[0] + r, y = I, x = s, _ = w[1] - p, Math.abs(_) < u && (_ = (_ <= 0 ? -1 : 1) * u), isNaN(_) || d && (A[o][S][M] += _);e.setItemLayout(g, { x: v, y, width: x, height: _ });
      }
    }, this);
  } const Bp = { seriesType: 'bar', plan: vc(), reset(t) {
    if (Vp(t) && Gp(t)) {
      const e = t.getData(); const c = t.coordinateSystem; const d = c.grid.getRect(); const f = c.getBaseAxis(); const p = c.getOtherAxis(f); const g = e.mapDimension(p.dim); const m = e.mapDimension(f.dim); const v = p.isHorizontal(); const y = v ? 0 : 1; let x = Ep(Op([t]), f, t).width;return.5 < x || (x = .5), { progress(t, e) {
        let i; const n = t.count; const o = new Lp(2 * n); const a = new Lp(2 * n); const r = new Lp(n); let s = []; const l = []; let u = 0; let h = 0;for (;null != (i = t.next());)l[y] = e.get(g, i), l[1 - y] = e.get(m, i), s = c.dataToPoint(l, null, s), a[u] = v ? d.x + d.width : s[0], o[u++] = s[0], a[u] = v ? s[1] : d.y + d.height, o[u++] = s[1], r[h++] = i;e.setLayout({ largePoints: o, largeDataIndices: r, largeBackgroundPoints: a, barWidth: x, valueAxisStart: Fp(f, p, !1), backgroundStart: v ? d.x : d.y, valueAxisHorizontal: v });
      } };
    }
  } };function Vp(t) {
    return t.coordinateSystem && 'cartesian2d' === t.coordinateSystem.type;
  } function Gp(t) {
    return t.pipelineContext && t.pipelineContext.large;
  } function Fp(t, e) {
    return e.toGlobalCoord(e.dataToCoord('log' === e.type ? 1 : 0));
  } const Wp = Dp.prototype; const Hp = Math.ceil; const Zp = Math.floor; const Up = 36e5; const Xp = 864e5; const Yp = Dp.extend({ type: 'time', getLabel(t) {
    const e = this._stepLvl; const i = new Date(t);return du(e[0], i, this.getSetting('useUTC'));
  }, niceExtent(t) {
    const e = this._extent;if (e[0] === e[1] && (e[0] -= Xp, e[1] += Xp), e[1] === -1 / 0 && e[0] === 1 / 0) {
      const i = new Date;e[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), e[0] = e[1] - Xp;
    } this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval);const n = this._interval;t.fixMin || (e[0] = zl(Zp(e[0] / n) * n)), t.fixMax || (e[1] = zl(Hp(e[1] / n) * n));
  }, niceTicks(t, e, i) {
    t = t || 10;const n = this._extent; const o = n[1] - n[0]; let a = o / t;null != e && a < e && (a = e), null != i && i < a && (a = i);const r = jp.length; const s = (function (t, e, i, n) {
      for (;i < n;) {
        const o = i + n >>> 1;t[o][1] < e ? i = 1 + o : n = o;
      } return i;
    }(jp, a, 0, r)); const l = jp[Math.min(s, r - 1)]; let u = l[1];'year' === l[0] && (u *= Kl(o / u / t, !0));const h = this.getSetting('useUTC') ? 0 : 60 * new Date(+n[0] || +n[1]).getTimezoneOffset() * 1e3; const c = [Math.round(Hp((n[0] - h) / u) * u + h), Math.round(Zp((n[1] - h) / u) * u + h)];Tp(c, n), this._stepLvl = l, this._interval = u, this._niceExtent = c;
  }, parse(t) {
    return +Yl(t);
  } });R(['contain', 'normalize'], (e) => {
    Yp.prototype[e] = function (t) {
      return Wp[e].call(this, this.parse(t));
    };
  });var jp = [['hh:mm:ss', 1e3], ['hh:mm:ss', 5e3], ['hh:mm:ss', 1e4], ['hh:mm:ss', 15e3], ['hh:mm:ss', 3e4], ['hh:mm\nMM-dd', 6e4], ['hh:mm\nMM-dd', 3e5], ['hh:mm\nMM-dd', 6e5], ['hh:mm\nMM-dd', 9e5], ['hh:mm\nMM-dd', 18e5], ['hh:mm\nMM-dd', Up], ['hh:mm\nMM-dd', 72e5], ['hh:mm\nMM-dd', 6 * Up], ['hh:mm\nMM-dd', 432e5], ['MM-dd\nyyyy', Xp], ['MM-dd\nyyyy', 2 * Xp], ['MM-dd\nyyyy', 3 * Xp], ['MM-dd\nyyyy', 4 * Xp], ['MM-dd\nyyyy', 5 * Xp], ['MM-dd\nyyyy', 6 * Xp], ['week', 7 * Xp], ['MM-dd\nyyyy', 864e6], ['week', 14 * Xp], ['week', 21 * Xp], ['month', 31 * Xp], ['week', 42 * Xp], ['month', 62 * Xp], ['week', 70 * Xp], ['quarter', 95 * Xp], ['month', 31 * Xp * 4], ['month', 13392e6], ['half-year', 16416e6], ['month', 31 * Xp * 8], ['month', 26784e6], ['year', 380 * Xp]];Yp.create = function (t) {
    return new Yp({ useUTC: t.ecModel.get('useUTC') });
  };const qp = mp.prototype; const Kp = Dp.prototype; const $p = Gl; const Jp = zl; const Qp = Math.floor; const tg = Math.ceil; const eg = Math.pow; const ig = Math.log; const ng = mp.extend({ type: 'log', base: 10, $constructor() {
    mp.apply(this, arguments), this._originalScale = new Dp;
  }, getTicks(t) {
    const i = this._originalScale; const n = this._extent; const o = i.getExtent();return O(Kp.getTicks.call(this, t), function (t) {
      let e = zl(eg(this.base, t));return e = t === n[0] && i.__fixMin ? og(e, o[0]) : e, e = t === n[1] && i.__fixMax ? og(e, o[1]) : e;
    }, this);
  }, getMinorTicks: Kp.getMinorTicks, getLabel: Kp.getLabel, scale(t) {
    return t = qp.scale.call(this, t), eg(this.base, t);
  }, setExtent(t, e) {
    const i = this.base;t = ig(t) / ig(i), e = ig(e) / ig(i), Kp.setExtent.call(this, t, e);
  }, getExtent() {
    const t = this.base; const e = qp.getExtent.call(this);e[0] = eg(t, e[0]), e[1] = eg(t, e[1]);const i = this._originalScale; const n = i.getExtent();return i.__fixMin && (e[0] = og(e[0], n[0])), i.__fixMax && (e[1] = og(e[1], n[1])), e;
  }, unionExtent(t) {
    this._originalScale.unionExtent(t);const e = this.base;t[0] = ig(t[0]) / ig(e), t[1] = ig(t[1]) / ig(e), qp.unionExtent.call(this, t);
  }, unionExtentFromData(t, e) {
    this.unionExtent(t.getApproximateExtent(e));
  }, niceTicks(t) {
    t = t || 10;const e = this._extent; const i = e[1] - e[0];if (!(i == 1 / 0 || i <= 0)) {
      let n = jl(i);for (t / i * n <= .5 && (n *= 10);!isNaN(n) && Math.abs(n) < 1 && 0 < Math.abs(n);)n *= 10;const o = [zl(tg(e[0] / n) * n), zl(Qp(e[1] / n) * n)];this._interval = n, this._niceExtent = o;
    }
  }, niceExtent(t) {
    Kp.niceExtent.call(this, t);const e = this._originalScale;e.__fixMin = t.fixMin, e.__fixMax = t.fixMax;
  } });function og(t, e) {
    return Jp(t, $p(e));
  } function ag(t, e) {
    let i; let n; let o; const a = t.type; let r = e.getMin(); let s = e.getMax(); const l = t.getExtent();'ordinal' === a ? i = e.getCategories().length : (L(n = e.get('boundaryGap')) || (n = [n || 0, n || 0]), 'boolean' === typeof n[0] && (n = [0, 0]), n[0] = El(n[0], 1), n[1] = El(n[1], 1), o = l[1] - l[0] || Math.abs(l[0])), 'dataMin' === r ? r = l[0] : 'function' === typeof r && (r = r({ min: l[0], max: l[1] })), 'dataMax' === s ? s = l[1] : 'function' === typeof s && (s = s({ min: l[0], max: l[1] }));const u = null != r; const h = null != s;null == r && (r = 'ordinal' === a ? i ? 0 : NaN : l[0] - n[0] * o), null == s && (s = 'ordinal' === a ? i ? i - 1 : NaN : l[1] + n[1] * o), null != r && isFinite(r) || (r = NaN), null != s && isFinite(s) || (s = NaN), t.setBlank(F(r) || F(s) || 'ordinal' === a && !t.getOrdinalMeta().categories.length), e.getNeedCrossZero() && (0 < r && 0 < s && !u && (r = 0), r < 0 && s < 0 && !h && (s = 0));const c = e.ecModel;if (c && 'time' === a) {
      let d; const f = Np('bar', c);if (R(f, (t) => {
        d |= t.getBaseAxis() === e.axis;
      }), d) {
        const p = Op(f); const g = (function (t, e, i, n) {
          const o = i.axis.getExtent(); const a = o[1] - o[0]; const r = Ep(n, i.axis);if (void 0 === r) return { min: t, max: e };let s = 1 / 0;R(r, (t) => {
            s = Math.min(t.offset, s);
          });let l = -1 / 0;R(r, (t) => {
            l = Math.max(t.offset + t.width, l);
          }), s = Math.abs(s), l = Math.abs(l);const u = s + l; const h = e - t; const c = h / (1 - (s + l) / a) - h;return { min: t -= s / u * c, max: e += l / u * c };
        }(r, s, e, p));r = g.min, s = g.max;
      }
    } return { extent: [r, s], fixMin: u, fixMax: h };
  } function rg(t, e) {
    const i = ag(t, e); const n = i.extent; const o = e.get('splitNumber');'log' === t.type && (t.base = e.get('logBase'));const a = t.type;t.setExtent(n[0], n[1]), t.niceExtent({ splitNumber: o, fixMin: i.fixMin, fixMax: i.fixMax, minInterval: 'interval' === a || 'time' === a ? e.get('minInterval') : null, maxInterval: 'interval' === a || 'time' === a ? e.get('maxInterval') : null });const r = e.get('interval');null != r && t.setInterval && t.setInterval(r);
  } function sg(t, e) {
    if (e = e || t.get('type')) switch (e) {
      case 'category':return new bp(t.getOrdinalMeta ? t.getOrdinalMeta() : t.getCategories(), [1 / 0, -1 / 0]);case 'value':return new Dp;default:return (mp.getClass(e) || Dp).create(t);
    }
  } function lg(i) {
    let e; let n = i.getLabelModel().get('formatter'); const o = 'category' === i.type ? i.scale.getExtent()[0] : null;return 'string' === typeof n ? (e = n, n = function (t) {
      return t = i.scale.getLabel(t), e.replace('{value}', null != t ? t : '');
    }) : 'function' === typeof n ? function (t, e) {
      return null != o && (e = t - o), n(ug(i, t), e);
    } : function (t) {
      return i.scale.getLabel(t);
    };
  } function ug(t, e) {
    return 'category' === t.type ? t.scale.getLabel(e) : e;
  } function hg(t) {
    const e = t.get('interval');return null == e ? 'auto' : e;
  } function cg(t) {
    return 'category' === t.type && 0 === hg(t.getLabelModel());
  }R(['contain', 'normalize'], (e) => {
    ng.prototype[e] = function (t) {
      return t = ig(t) / ig(this.base), qp[e].call(this, t);
    };
  }), ng.create = function () {
    return new ng;
  };const dg = { getMin(t) {
    const e = this.option; let i = t || null == e.rangeStart ? e.min : e.rangeStart;return this.axis && null != i && 'dataMin' !== i && 'function' !== typeof i && !F(i) && (i = this.axis.scale.parse(i)), i;
  }, getMax(t) {
    const e = this.option; let i = t || null == e.rangeEnd ? e.max : e.rangeEnd;return this.axis && null != i && 'dataMax' !== i && 'function' !== typeof i && !F(i) && (i = this.axis.scale.parse(i)), i;
  }, getNeedCrossZero() {
    const t = this.option;return null == t.rangeStart && null == t.rangeEnd && !t.scale;
  }, getCoordSysModel: et, setRange(t, e) {
    this.option.rangeStart = t, this.option.rangeEnd = e;
  }, resetRange() {
    this.option.rangeStart = this.option.rangeEnd = null;
  } }; const fg = Cs({ type: 'triangle', shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath(t, e) {
    const i = e.cx; const n = e.cy; const o = e.width / 2; const a = e.height / 2;t.moveTo(i, n - a), t.lineTo(i + o, n + a), t.lineTo(i - o, n + a), t.closePath();
  } }); const pg = Cs({ type: 'diamond', shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath(t, e) {
    const i = e.cx; const n = e.cy; const o = e.width / 2; const a = e.height / 2;t.moveTo(i, n - a), t.lineTo(i + o, n), t.lineTo(i, n + a), t.lineTo(i - o, n), t.closePath();
  } }); const gg = Cs({ type: 'pin', shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath(t, e) {
    const i = e.x; const n = e.y; const o = e.width / 5 * 3; const a = Math.max(o, e.height); const r = o / 2; const s = r * r / (a - r); const l = n - a + r + s; const u = Math.asin(s / r); const h = Math.cos(u) * r; const c = Math.sin(u); const d = Math.cos(u); const f = .6 * r; const p = .7 * r;t.moveTo(i - h, l + s), t.arc(i, l, r, Math.PI - u, 2 * Math.PI + u), t.bezierCurveTo(i + h - c * f, l + s + d * f, i, n - p, i, n), t.bezierCurveTo(i, n - p, i - h + c * f, l + s + d * f, i - h, l + s), t.closePath();
  } }); const mg = Cs({ type: 'arrow', shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath(t, e) {
    const i = e.height; const n = e.width; const o = e.x; const a = e.y; const r = n / 3 * 2;t.moveTo(o, a), t.lineTo(o + r, a + i), t.lineTo(o, a + i / 4 * 3), t.lineTo(o - r, a + i), t.lineTo(o, a), t.closePath();
  } }); const vg = { line(t, e, i, n, o) {
    o.x1 = t, o.y1 = e + n / 2, o.x2 = t + i, o.y2 = e + n / 2;
  }, rect(t, e, i, n, o) {
    o.x = t, o.y = e, o.width = i, o.height = n;
  }, roundRect(t, e, i, n, o) {
    o.x = t, o.y = e, o.width = i, o.height = n, o.r = Math.min(i, n) / 4;
  }, square(t, e, i, n, o) {
    const a = Math.min(i, n);o.x = t, o.y = e, o.width = a, o.height = a;
  }, circle(t, e, i, n, o) {
    o.cx = t + i / 2, o.cy = e + n / 2, o.r = Math.min(i, n) / 2;
  }, diamond(t, e, i, n, o) {
    o.cx = t + i / 2, o.cy = e + n / 2, o.width = i, o.height = n;
  }, pin(t, e, i, n, o) {
    o.x = t + i / 2, o.y = e + n / 2, o.width = i, o.height = n;
  }, arrow(t, e, i, n, o) {
    o.x = t + i / 2, o.y = e + n / 2, o.width = i, o.height = n;
  }, triangle(t, e, i, n, o) {
    o.cx = t + i / 2, o.cy = e + n / 2, o.width = i, o.height = n;
  } }; const yg = {};R({ line: ls, rect: rs, roundRect: rs, square: rs, circle: Yr, diamond: pg, pin: gg, arrow: mg, triangle: fg }, (t, e) => {
    yg[e] = new t;
  });const xg = Cs({ type: 'symbol', shape: { symbolType: '', x: 0, y: 0, width: 0, height: 0 }, calculateTextPosition(t, e, i) {
    const n = yn(t, e, i); const o = this.shape;return o && 'pin' === o.symbolType && 'inside' === e.textPosition && (n.y = i.y + .4 * i.height), n;
  }, buildPath(t, e, i) {
    let n = e.symbolType;if ('none' !== n) {
      let o = yg[n];o = o || yg[n = 'rect'], vg[n](e.x, e.y, e.width, e.height, o.shape), o.buildPath(t, o.shape, i);
    }
  } });function _g(t, e) {
    if ('image' !== this.type) {
      const i = this.style; const n = this.shape;n && 'line' === n.symbolType ? i.stroke = t : this.__isEmptyBrush ? (i.stroke = t, i.fill = e || '#fff') : (i.fill && (i.fill = t), i.stroke && (i.stroke = t)), this.dirty(!1);
    }
  } function wg(t, e, i, n, o, a, r) {
    let s; const l = 0 === t.indexOf('empty');return l && (t = t.substr(5, 1).toLowerCase() + t.substr(6)), (s = 0 === t.indexOf('image://') ? Ns(t.slice(8), new Di(e, i, n, o), r ? 'center' : 'cover') : 0 === t.indexOf('path://') ? Ps(t.slice(7), {}, new Di(e, i, n, o), r ? 'center' : 'cover') : new xg({ shape: { symbolType: t, x: e, y: i, width: n, height: o } })).__isEmptyBrush = l, s.setColor = _g, s.setColor(a), s;
  } const bg = { isDimensionStacked: fp, enableDataStack: dp, getStackedDimension: pp };const Sg = (Object.freeze || Object)({ createList(t) {
    return gp(t.getSource(), t);
  }, getLayoutRect: bu, dataStack: bg, createScale(t, e) {
    let i = e;Cl.isInstance(e) || b(i = new Cl(e), dg);const n = sg(i);return n.setExtent(t[0], t[1]), rg(n, i), n;
  }, mixinAxisModelCommonMethods(t) {
    b(t, dg);
  }, completeDimensions: rp, createDimensions: lp, createSymbol: wg }); const Mg = 1e-8;function Ig(t, e) {
    return Math.abs(t - e) < Mg;
  } function Tg(t, e, i) {
    let n = 0; let o = t[0];if (!o) return !1;for (let a = 1;a < t.length;a++) {
      const r = t[a];n += pr(o[0], o[1], r[0], r[1], e, i), o = r;
    } const s = t[0];return Ig(o[0], s[0]) && Ig(o[1], s[1]) || (n += pr(o[0], o[1], s[0], s[1], e, i)), 0 !== n;
  } function Ag(t, e, i) {
    if (this.name = t, this.geometries = e, i)i = [i[0], i[1]];else {
      const n = this.getBoundingRect();i = [n.x + n.width / 2, n.y + n.height / 2];
    } this.center = i;
  } function Dg(t, e, i) {
    for (var n = [], o = e[0], a = e[1], r = 0;r < t.length;r += 2) {
      let s = t.charCodeAt(r) - 64; let l = t.charCodeAt(r + 1) - 64;s = s >> 1 ^ -(1 & s), l = l >> 1 ^ -(1 & l), o = s += o, a = l += a, n.push([s / i, l / i]);
    } return n;
  }Ag.prototype = { constructor: Ag, properties: null, getBoundingRect() {
    const t = this._rect;if (t) return t;for (var e = Number.MAX_VALUE, i = [e, e], n = [-e, -e], o = [], a = [], r = this.geometries, s = 0;s < r.length;s++) {
      if ('polygon' === r[s].type)Wa(r[s].exterior, o, a), St(i, i, o), Mt(n, n, a);
    } return 0 === s && (i[0] = i[1] = n[0] = n[1] = 0), this._rect = new Di(i[0], i[1], n[0] - i[0], n[1] - i[1]);
  }, contain(t) {
    const e = this.getBoundingRect(); const i = this.geometries;if (!e.contain(t[0], t[1])) return !1;t:for (let n = 0, o = i.length;n < o;n++) if ('polygon' === i[n].type) {
      const a = i[n].exterior; const r = i[n].interiors;if (Tg(a, t[0], t[1])) {
        for (let s = 0;s < (r ? r.length : 0);s++) if (Tg(r[s])) continue t;return !0;
      }
    } return !1;
  }, transformTo(t, e, i, n) {
    let o = this.getBoundingRect(); const a = o.width / o.height;i ? n = n || i / a : i = a * n;for (var r = new Di(t, e, i, n), s = o.calculateTransform(r), l = this.geometries, u = 0;u < l.length;u++) if ('polygon' === l[u].type) {
      for (var h = l[u].exterior, c = l[u].interiors, d = 0;d < h.length;d++)bt(h[d], h[d], s);for (let f = 0;f < (c ? c.length : 0);f++) for (d = 0;d < c[f].length;d++)bt(c[f][d], c[f][d], s);
    }(o = this._rect).copy(r), this.center = [o.x + o.width / 2, o.y + o.height / 2];
  }, cloneShallow(t) {
    null == t && (t = this.name);const e = new Ag(t, this.geometries, this.center);return e._rect = this._rect, e.transformTo = null, e;
  } };function Cg(t, r) {
    return (function (t) {
      if (!t.UTF8Encoding) return;let e = t.UTF8Scale;null == e && (e = 1024);for (let i = t.features, n = 0;n < i.length;n++) for (let o = i[n].geometry, a = o.coordinates, r = o.encodeOffsets, s = 0;s < a.length;s++) {
        const l = a[s];if ('Polygon' === o.type)a[s] = Dg(l, r[s], e);else if ('MultiPolygon' === o.type) for (let u = 0;u < l.length;u++) {
          const h = l[u];l[u] = Dg(h, r[s][u], e);
        }
      }t.UTF8Encoding = !1;
    }(t)), O(M(t.features, t => t.geometry && t.properties && 0 < t.geometry.coordinates.length), (t) => {
      const e = t.properties; const i = t.geometry; const n = i.coordinates; const o = [];'Polygon' === i.type && o.push({ type: 'polygon', exterior: n[0], interiors: n.slice(1) }), 'MultiPolygon' === i.type && R(n, (t) => {
        t[0] && o.push({ type: 'polygon', exterior: t[0], interiors: t.slice(1) });
      });const a = new Ag(e[r || 'name'], o, e.cp);return a.properties = e, a;
    });
  } const Lg = jo();function kg(t) {
    return 'category' === t.type ? (function (t) {
      const e = t.getLabelModel(); const i = Ng(t, e);return !e.get('show') || t.scale.isBlank() ? { labels: [], labelCategoryInterval: i.labelCategoryInterval } : i;
    }(t)) : (function (i) {
      const t = i.scale.getTicks(); const n = lg(i);return { labels: O(t, (t, e) => ({ formattedLabel: n(t, e), rawLabel: i.scale.getLabel(t), tickValue: t })) };
    }(t));
  } function Pg(t, e) {
    return 'category' === t.type ? (function (t, e) {
      let i; let n; const o = Og(t, 'ticks'); const a = hg(e); const r = Rg(o, a);if (r) return r;e.get('show') && !t.scale.isBlank() || (i = []);if (C(a))i = Bg(t, a, !0);else if ('auto' === a) {
        const s = Ng(t, t.getLabelModel());n = s.labelCategoryInterval, i = O(s.labels, t => t.tickValue);
      } else i = zg(t, n = a, !0);return Eg(o, a, { ticks: i, tickCategoryInterval: n });
    }(t, e)) : { ticks: t.scale.getTicks() };
  } function Ng(t, e) {
    let i; const n = Og(t, 'labels'); const o = hg(e); const a = Rg(n, o);return a || Eg(n, o, { labels: C(o) ? Bg(t, o) : zg(t, i = 'auto' === o ? (function (t) {
      const e = Lg(t).autoInterval;return null != e ? e : Lg(t).autoInterval = t.calculateCategoryInterval();
    }(t)) : o), labelCategoryInterval: i });
  } function Og(t, e) {
    return Lg(t)[e] || (Lg(t)[e] = []);
  } function Rg(t, e) {
    for (let i = 0;i < t.length;i++) if (t[i].key === e) return t[i].value;
  } function Eg(t, e, i) {
    return t.push({ key: e, value: i }), i;
  } function zg(t, e, i) {
    const n = lg(t); const o = t.scale; const a = o.getExtent(); const r = t.getLabelModel(); const s = []; const l = Math.max((e || 0) + 1, 1); let u = a[0]; const h = o.count();0 !== u && 1 < l && 2 < h / l && (u = Math.round(Math.ceil(u / l) * l));const c = cg(t); const d = r.get('showMinLabel') || c; const f = r.get('showMaxLabel') || c;d && u !== a[0] && g(a[0]);for (var p = u;p <= a[1];p += l)g(p);function g(t) {
      s.push(i ? t : { formattedLabel: n(t), rawLabel: o.getLabel(t), tickValue: t });
    } return f && p - l !== a[1] && g(a[1]), s;
  } function Bg(t, i, n) {
    const o = t.scale; const a = lg(t); const r = [];return R(o.getTicks(), (t) => {
      const e = o.getLabel(t);i(t, e) && r.push(n ? t : { formattedLabel: a(t), rawLabel: e, tickValue: t });
    }), r;
  } const Vg = [0, 1]; const Gg = function (t, e, i) {
    this.dim = t, this.scale = e, this._extent = i || [0, 0], this.inverse = !1, this.onBand = !1;
  };function Fg(t, e) {
    const i = (t[1] - t[0]) / e / 2;t[0] += i, t[1] -= i;
  }Gg.prototype = { constructor: Gg, contain(t) {
    const e = this._extent; const i = Math.min(e[0], e[1]); const n = Math.max(e[0], e[1]);return i <= t && t <= n;
  }, containData(t) {
    return this.scale.contain(t);
  }, getExtent() {
    return this._extent.slice();
  }, getPixelPrecision(t) {
    return Fl(t || this.scale.getExtent(), this._extent);
  }, setExtent(t, e) {
    const i = this._extent;i[0] = t, i[1] = e;
  }, dataToCoord(t, e) {
    let i = this._extent; const n = this.scale;return t = n.normalize(t), this.onBand && 'ordinal' === n.type && Fg(i = i.slice(), n.count()), Rl(t, Vg, i, e);
  }, coordToData(t, e) {
    let i = this._extent; const n = this.scale;this.onBand && 'ordinal' === n.type && Fg(i = i.slice(), n.count());const o = Rl(t, i, Vg, e);return this.scale.scale(o);
  }, pointToData(t, e) {}, getTicksCoords(t) {
    const e = (t = t || {}).tickModel || this.getTickModel(); const i = O(Pg(this, e).ticks, function (t) {
      return { coord: this.dataToCoord(t), tickValue: t };
    }, this);return (function (t, e, i, n) {
      const o = e.length;if (!t.onBand || i || !o) return;let a; let r; const s = t.getExtent();if (1 === o)e[0].coord = s[0], a = e[1] = { coord: s[0] };else {
        const l = e[o - 1].tickValue - e[0].tickValue; const u = (e[o - 1].coord - e[0].coord) / l;R(e, (t) => {
          t.coord -= u / 2;
        });const h = t.scale.getExtent();r = 1 + h[1] - e[o - 1].tickValue, a = { coord: e[o - 1].coord + u * r }, e.push(a);
      } const c = s[0] > s[1];d(e[0].coord, s[0]) && (n ? e[0].coord = s[0] : e.shift());n && d(s[0], e[0].coord) && e.unshift({ coord: s[0] });d(s[1], a.coord) && (n ? a.coord = s[1] : e.pop());n && d(a.coord, s[1]) && e.push({ coord: s[1] });function d(t, e) {
        return t = zl(t), e = zl(e), c ? e < t : t < e;
      }
    }(this, i, e.get('alignWithLabel'), t.clamp)), i;
  }, getMinorTicksCoords() {
    if ('ordinal' === this.scale.type) return [];let t = this.model.getModel('minorTick').get('splitNumber');return 0 < t && t < 100 || (t = 5), O(this.scale.getMinorTicks(t), function (t) {
      return O(t, function (t) {
        return { coord: this.dataToCoord(t), tickValue: t };
      }, this);
    }, this);
  }, getViewLabels() {
    return kg(this).labels;
  }, getLabelModel() {
    return this.model.getModel('axisLabel');
  }, getTickModel() {
    return this.model.getModel('axisTick');
  }, getBandWidth() {
    const t = this._extent; const e = this.scale.getExtent(); let i = e[1] - e[0] + (this.onBand ? 1 : 0);0 === i && (i = 1);const n = Math.abs(t[1] - t[0]);return Math.abs(n) / i;
  }, isHorizontal: null, getRotate: null, calculateCategoryInterval() {
    return (function (t) {
      const e = (function (t) {
        const e = t.getLabelModel();return { axisRotate: t.getRotate ? t.getRotate() : t.isHorizontal && !t.isHorizontal() ? 90 : 0, labelRotate: e.get('rotate') || 0, font: e.getFont() };
      }(t)); const i = lg(t); const n = (e.axisRotate - e.labelRotate) / 180 * Math.PI; const o = t.scale; const a = o.getExtent(); const r = o.count();if (a[1] - a[0] < 1) return 0;let s = 1;40 < r && (s = Math.max(1, Math.floor(r / 40)));for (var l = a[0], u = t.dataToCoord(l + 1) - t.dataToCoord(l), h = Math.abs(u * Math.cos(n)), c = Math.abs(u * Math.sin(n)), d = 0, f = 0;l <= a[1];l += s) {
        var p; var g; const m = gn(i(l), e.font, 'center', 'top');p = 1.3 * m.width, g = 1.3 * m.height, d = Math.max(d, p, 7), f = Math.max(f, g, 7);
      } let v = d / h; let y = f / c;isNaN(v) && (v = 1 / 0), isNaN(y) && (y = 1 / 0);let x = Math.max(0, Math.floor(Math.min(v, y))); const _ = Lg(t.model); const w = t.getExtent(); const b = _.lastAutoInterval; const S = _.lastTickCount;return null != b && null != S && Math.abs(b - x) <= 1 && Math.abs(S - r) <= 1 && x < b && _.axisExtend0 === w[0] && _.axisExtend1 === w[1] ? x = b : (_.lastTickCount = r, _.lastAutoInterval = x, _.axisExtend0 = w[0], _.axisExtend1 = w[1]), x;
    }(this));
  } };const Wg = Cg; const Hg = {};R(['map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter', 'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction', 'extend', 'defaults', 'clone', 'merge'], (t) => {
    Hg[t] = it[t];
  });const Zg = {};function Ug(t, e) {
    const i = t.mapDimension('defaultedLabel', !0); const n = i.length;if (1 === n) return Hh(t, e, i[0]);if (n) {
      for (var o = [], a = 0;a < i.length;a++) {
        const r = Hh(t, e, i[a]);o.push(r);
      } return o.join(' ');
    }
  } function Xg(t, e, i) {
    Ci.call(this), this.updateData(t, e, i);
  }R(['extendShape', 'extendPath', 'makePath', 'makeImage', 'mergePath', 'resizePath', 'createIcon', 'setHoverStyle', 'setLabelStyle', 'setTextStyle', 'setText', 'getFont', 'updateProps', 'initProps', 'getTransform', 'clipPointsByRect', 'clipRectByRect', 'registerShape', 'getShapeClass', 'Group', 'Image', 'Text', 'Circle', 'Sector', 'Ring', 'Polygon', 'Polyline', 'Rect', 'Line', 'BezierCurve', 'Arc', 'IncrementalDisplayable', 'CompoundPath', 'LinearGradient', 'RadialGradient', 'BoundingRect'], (t) => {
    Zg[t] = bl[t];
  }), sc.extend({ type: 'series.line', dependencies: ['grid', 'polar'], getInitialData(t, e) {
    return gp(this.getSource(), this, { useEncodeDefaulter: !0 });
  }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: 'cartesian2d', legendHoverLink: !0, hoverAnimation: !0, clip: !0, label: { position: 'top' }, lineStyle: { width: 2, type: 'solid' }, step: !1, smooth: !1, smoothMonotone: null, symbol: 'emptyCircle', symbolSize: 4, symbolRotate: null, showSymbol: !0, showAllSymbol: 'auto', connectNulls: !1, sampling: 'none', animationEasing: 'linear', progressive: 0, hoverLayerThreshold: 1 / 0 } });const Yg = Xg.prototype; const jg = Xg.getSymbolSize = function (t, e) {
    const i = t.getItemVisual(e, 'symbolSize');return i instanceof Array ? i.slice() : [+i, +i];
  };function qg(t) {
    return [t[0] / 2, t[1] / 2];
  } function Kg(t, e) {
    this.parent.drift(t, e);
  }Yg._createSymbol = function (t, e, i, n, o) {
    this.removeAll();const a = wg(t, -1, -1, 2, 2, e.getItemVisual(i, 'color'), o);a.attr({ z2: 100, culling: !0, scale: qg(n) }), a.drift = Kg, this._symbolType = t, this.add(a);
  }, Yg.stopSymbolAnimation = function (t) {
    this.childAt(0).stopAnimation(t);
  }, Yg.getSymbolPath = function () {
    return this.childAt(0);
  }, Yg.getScale = function () {
    return this.childAt(0).scale;
  }, Yg.highlight = function () {
    this.childAt(0).trigger('emphasis');
  }, Yg.downplay = function () {
    this.childAt(0).trigger('normal');
  }, Yg.setZ = function (t, e) {
    const i = this.childAt(0);i.zlevel = t, i.z = e;
  }, Yg.setDraggable = function (t) {
    const e = this.childAt(0);e.draggable = t, e.cursor = t ? 'move' : e.cursor;
  }, Yg.updateData = function (t, e, i) {
    this.silent = !1;const n = t.getItemVisual(e, 'symbol') || 'circle'; const o = t.hostModel; const a = jg(t, e); const r = n !== this._symbolType;if (r) {
      const s = t.getItemVisual(e, 'symbolKeepAspect');this._createSymbol(n, t, e, a, s);
    } else {
      (l = this.childAt(0)).silent = !1, cl(l, { scale: qg(a) }, o, e);
    } if (this._updateCommon(t, e, a, i), r) {
      var l = this.childAt(0); const u = i && i.fadeIn; const h = { scale: l.scale.slice() };u && (h.style = { opacity: l.style.opacity }), l.scale = [0, 0], u && (l.style.opacity = 0), dl(l, h, o, e);
    } this._seriesModel = o;
  };const $g = ['itemStyle']; const Jg = ['emphasis', 'itemStyle']; const Qg = ['label']; const tm = ['emphasis', 'label'];function em(t, e) {
    if (!this.incremental && !this.useHoverLayer) if ('emphasis' === e) {
      const i = this.__symbolOriginalScale; const n = i[1] / i[0]; const o = { scale: [Math.max(1.1 * i[0], i[0] + 3), Math.max(1.1 * i[1], i[1] + 3 * n)] };this.animateTo(o, 400, 'elasticOut');
    } else 'normal' === e && this.animateTo({ scale: this.__symbolOriginalScale }, 400, 'elasticOut');
  } function im(t) {
    this.group = new Ci, this._symbolCtor = t || Xg;
  }Yg._updateCommon = function (i, t, e, n) {
    const o = this.childAt(0); const a = i.hostModel; const r = i.getItemVisual(t, 'color');'image' !== o.type ? o.useStyle({ strokeNoScale: !0 }) : o.setStyle({ opacity: 1, shadowBlur: null, shadowOffsetX: null, shadowOffsetY: null, shadowColor: null });let s = n && n.itemStyle; let l = n && n.hoverItemStyle; let u = n && n.symbolOffset; let h = n && n.labelModel; let c = n && n.hoverLabelModel; let d = n && n.hoverAnimation; let f = n && n.cursorStyle;if (!n || i.hasItemOption) {
      const p = n && n.itemModel ? n.itemModel : i.getItemModel(t);s = p.getModel($g).getItemStyle(['color']), l = p.getModel(Jg).getItemStyle(), u = p.getShallow('symbolOffset'), h = p.getModel(Qg), c = p.getModel(tm), d = p.getShallow('hoverAnimation'), f = p.getShallow('cursor');
    } else l = P({}, l);const g = o.style; const m = i.getItemVisual(t, 'symbolRotate');o.attr('rotation', (m || 0) * Math.PI / 180 || 0), u && o.attr('position', [El(u[0], e[0]), El(u[1], e[1])]), f && o.attr('cursor', f), o.setColor(r, n && n.symbolInnerColor), o.setStyle(s);const v = i.getItemVisual(t, 'opacity');null != v && (g.opacity = v);const y = i.getItemVisual(t, 'liftZ'); const x = o.__z2Origin;null != y ? null == x && (o.__z2Origin = o.z2, o.z2 += y) : null != x && (o.z2 = x, o.__z2Origin = null);const _ = n && n.useNameLabel;el(g, l, h, c, { labelFetcher: a, labelDataIndex: t, defaultText(t, e) {
      return _ ? i.getName(t) : Ug(i, t);
    }, isRectText: !0, autoColor: r }), o.__symbolOriginalScale = qg(e), o.hoverStyle = l, o.highDownOnUpdate = d && a.isAnimationEnabled() ? em : null, $s(o);
  }, Yg.fadeOut = function (t, e) {
    const i = this.childAt(0);this.silent = i.silent = !0, e && e.keepLabel || (i.style.text = null), cl(i, { style: { opacity: 0 }, scale: [0, 0] }, this._seriesModel, this.dataIndex, t);
  }, w(Xg, Ci);const nm = im.prototype;function om(t, e, i, n) {
    return e && !isNaN(e[0]) && !isNaN(e[1]) && !(n.isIgnore && n.isIgnore(i)) && !(n.clipShape && !n.clipShape.contain(e[0], e[1])) && 'none' !== t.getItemVisual(i, 'symbol');
  } function am(t) {
    return null == t || z(t) || (t = { isIgnore: t }), t || {};
  } function rm(t) {
    const e = t.hostModel;return { itemStyle: e.getModel('itemStyle').getItemStyle(['color']), hoverItemStyle: e.getModel('emphasis.itemStyle').getItemStyle(), symbolRotate: e.get('symbolRotate'), symbolOffset: e.get('symbolOffset'), hoverAnimation: e.get('hoverAnimation'), labelModel: e.getModel('label'), hoverLabelModel: e.getModel('emphasis.label'), cursorStyle: e.get('cursor') };
  } function sm(t, e, i) {
    let n; const o = t.getBaseAxis(); const a = t.getOtherAxis(o); const r = (function (t, e) {
      let i = 0; const n = t.scale.getExtent();'start' === e ? i = n[0] : 'end' === e ? i = n[1] : 0 < n[0] ? i = n[0] : n[1] < 0 && (i = n[1]);return i;
    }(a, i)); const s = o.dim; const l = a.dim; const u = e.mapDimension(l); const h = e.mapDimension(s); const c = 'x' === l || 'radius' === l ? 1 : 0; const d = O(t.dimensions, t => e.mapDimension(t)); const f = e.getCalculationInfo('stackResultDimension');return (n |= fp(e, d[0])) && (d[0] = f), (n |= fp(e, d[1])) && (d[1] = f), { dataDimsForPoint: d, valueStart: r, valueAxisDim: l, baseAxisDim: s, stacked: !!n, valueDim: u, baseDim: h, baseDataOffset: c, stackedOverDimension: e.getCalculationInfo('stackedOverDimension') };
  } function lm(t, e, i, n) {
    let o = NaN;t.stacked && (o = i.get(i.getCalculationInfo('stackedOverDimension'), n)), isNaN(o) && (o = t.valueStart);const a = t.baseDataOffset; const r = [];return r[a] = i.get(t.baseDim, n), r[1 - a] = o, e.dataToPoint(r);
  }nm.updateData = function (o, a) {
    a = am(a);const r = this.group; const s = o.hostModel; const l = this._data; const u = this._symbolCtor; const h = rm(o);l || r.removeAll(), o.diff(l).add((t) => {
      const e = o.getItemLayout(t);if (om(o, e, t, a)) {
        const i = new u(o, t, h);i.attr('position', e), o.setItemGraphicEl(t, i), r.add(i);
      }
    })
      .update((t, e) => {
        let i = l.getItemGraphicEl(e); const n = o.getItemLayout(t);om(o, n, t, a) ? (i ? (i.updateData(o, t, h), cl(i, { position: n }, s)) : (i = new u(o, t)).attr('position', n), r.add(i), o.setItemGraphicEl(t, i)) : r.remove(i);
      })
      .remove((t) => {
        const e = l.getItemGraphicEl(t);e && e.fadeOut(() => {
          r.remove(e);
        });
      })
      .execute(), this._data = o;
  }, nm.isPersistent = function () {
    return !0;
  }, nm.updateLayout = function () {
    const n = this._data;n && n.eachItemGraphicEl((t, e) => {
      const i = n.getItemLayout(e);t.attr('position', i);
    });
  }, nm.incrementalPrepareUpdate = function (t) {
    this._seriesScope = rm(t), this._data = null, this.group.removeAll();
  }, nm.incrementalUpdate = function (t, e, i) {
    function n(t) {
      t.isGroup || (t.incremental = t.useHoverLayer = !0);
    }i = am(i);for (let o = t.start;o < t.end;o++) {
      const a = e.getItemLayout(o);if (om(e, a, o, i)) {
        const r = new this._symbolCtor(e, o, this._seriesScope);r.traverse(n), r.attr('position', a), this.group.add(r), e.setItemGraphicEl(o, r);
      }
    }
  }, nm.remove = function (t) {
    const e = this.group; const i = this._data;i && t ? i.eachItemGraphicEl((t) => {
      t.fadeOut(() => {
        e.remove(t);
      });
    }) : e.removeAll();
  };const um = St; const hm = Mt; const cm = ut; const dm = at; const fm = []; const pm = []; const gm = [];function mm(t) {
    return isNaN(t[0]) || isNaN(t[1]);
  } function vm(t, e, i, n, o, a, r, s, l, u) {
    return 'none' !== u && u ? function (t, e, i, n, o, a, r, s, l, u, h) {
      for (var c = 0, d = i, f = 0;f < n;f++) {
        const p = e[d];if (o <= d || d < 0) break;if (mm(p)) {
          if (h) {
            d += a;continue;
          } break;
        } if (d === i)t[0 < a ? 'moveTo' : 'lineTo'](p[0], p[1]);else if (0 < l) {
          const g = e[c]; const m = 'y' === u ? 1 : 0; const v = (p[m] - g[m]) * l;dm(pm, g), pm[m] = g[m] + v, dm(gm, p), gm[m] = p[m] - v, t.bezierCurveTo(pm[0], pm[1], gm[0], gm[1], p[0], p[1]);
        } else t.lineTo(p[0], p[1]);c = d, d += a;
      } return f;
    }.apply(this, arguments) : function (t, e, i, n, o, a, r, s, l, u, h) {
      for (var c = 0, d = i, f = 0;f < n;f++) {
        const p = e[d];if (o <= d || d < 0) break;if (mm(p)) {
          if (h) {
            d += a;continue;
          } break;
        } if (d === i)t[0 < a ? 'moveTo' : 'lineTo'](p[0], p[1]), dm(pm, p);else if (0 < l) {
          let g = d + a; let m = e[g];if (h) for (;m && mm(e[g]);)m = e[g += a];let v = .5; const y = e[c];if (!(m = e[g]) || mm(m))dm(gm, p);else {
            var x; var _;if (mm(m) && !h && (m = p), ht(fm, m, y), 'x' === u || 'y' === u) {
              const w = 'x' === u ? 0 : 1;x = Math.abs(p[w] - y[w]), _ = Math.abs(p[w] - m[w]);
            } else x = yt(p, y), _ = yt(p, m);cm(gm, p, fm, -l * (1 - (v = _ / (_ + x))));
          }um(pm, pm, s), hm(pm, pm, r), um(gm, gm, s), hm(gm, gm, r), t.bezierCurveTo(pm[0], pm[1], gm[0], gm[1], p[0], p[1]), cm(pm, p, fm, l * v);
        } else t.lineTo(p[0], p[1]);c = d, d += a;
      } return f;
    }.apply(this, arguments);
  } function ym(t, e) {
    const i = [1 / 0, 1 / 0]; const n = [-1 / 0, -1 / 0];if (e) for (let o = 0;o < t.length;o++) {
      const a = t[o];a[0] < i[0] && (i[0] = a[0]), a[1] < i[1] && (i[1] = a[1]), a[0] > n[0] && (n[0] = a[0]), a[1] > n[1] && (n[1] = a[1]);
    } return { min: e ? i : n, max: e ? n : i };
  } const xm = Ar.extend({ type: 'ec-polyline', shape: { points: [], smooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1 }, style: { fill: null, stroke: '#000' }, brush: Xr(Ar.prototype.brush), buildPath(t, e) {
    const i = e.points; let n = 0; let o = i.length; const a = ym(i, e.smoothConstraint);if (e.connectNulls) {
      for (;0 < o && mm(i[o - 1]);o--);for (;n < o && mm(i[n]);n++);
    } for (;n < o;)n += vm(t, i, n, o, o, 1, a.min, a.max, e.smooth, e.smoothMonotone, e.connectNulls) + 1;
  } }); const _m = Ar.extend({ type: 'ec-polygon', shape: { points: [], stackedOnPoints: [], smooth: 0, stackedOnSmooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1 }, brush: Xr(Ar.prototype.brush), buildPath(t, e) {
    const i = e.points; const n = e.stackedOnPoints; let o = 0; let a = i.length; const r = e.smoothMonotone; const s = ym(i, e.smoothConstraint); const l = ym(n, e.smoothConstraint);if (e.connectNulls) {
      for (;0 < a && mm(i[a - 1]);a--);for (;o < a && mm(i[o]);o++);
    } for (;o < a;) {
      const u = vm(t, i, o, a, a, 1, s.min, s.max, e.smooth, r, e.connectNulls);vm(t, n, o + u - 1, u, a, -1, l.min, l.max, e.stackedOnSmooth, r, e.connectNulls), o += u + 1, t.closePath();
    }
  } });function wm(t, e, i) {
    const n = t.getArea(); const o = t.getBaseAxis().isHorizontal(); let a = n.x; let r = n.y; let s = n.width; let l = n.height; const u = i.get('lineStyle.width') || 2;a -= u / 2, r -= u / 2, s += u, l += u, a = Math.floor(a), s = Math.round(s);const h = new rs({ shape: { x: a, y: r, width: s, height: l } });return e && (h.shape[o ? 'width' : 'height'] = 0, dl(h, { shape: { width: s, height: l } }, i)), h;
  } function bm(t, e, i) {
    const n = t.getArea(); const o = new qr({ shape: { cx: zl(t.cx, 1), cy: zl(t.cy, 1), r0: zl(n.r0, 1), r: zl(n.r, 1), startAngle: n.startAngle, endAngle: n.endAngle, clockwise: n.clockwise } });return e && (o.shape.endAngle = n.startAngle, dl(o, { shape: { endAngle: n.endAngle } }, i)), o;
  } function Sm(t, e, i) {
    return t ? 'polar' === t.type ? bm(t, e, i) : 'cartesian2d' === t.type ? wm(t, e, i) : null : null;
  } function Mm(t, e) {
    if (t.length === e.length) {
      for (let i = 0;i < t.length;i++) {
        const n = t[i]; const o = e[i];if (n[0] !== o[0] || n[1] !== o[1]) return;
      } return !0;
    }
  } function Im(t, e) {
    const i = []; const n = []; const o = []; const a = [];return Wa(t, i, n), Wa(e, o, a), Math.max(Math.abs(i[0] - o[0]), Math.abs(i[1] - o[1]), Math.abs(n[0] - a[0]), Math.abs(n[1] - a[1]));
  } function Tm(t) {
    return 'number' === typeof t ? t : t ? .5 : 0;
  } function Am(t, e, i) {
    for (var n = e.getBaseAxis(), o = 'x' === n.dim || 'radius' === n.dim ? 0 : 1, a = [], r = 0;r < t.length - 1;r++) {
      const s = t[r + 1]; const l = t[r];a.push(l);const u = [];switch (i) {
        case 'end':u[o] = s[o], u[1 - o] = l[1 - o], a.push(u);break;case 'middle':var h = (l[o] + s[o]) / 2; var c = [];u[o] = c[o] = h, u[1 - o] = l[1 - o], c[1 - o] = s[1 - o], a.push(u), a.push(c);break;default:u[o] = l[o], u[1 - o] = s[1 - o], a.push(u);
      }
    } return t[r] && a.push(t[r]), a;
  } function Dm(t, e, i) {
    const n = t.get('showAllSymbol'); const o = 'auto' === n;if (!n || o) {
      const a = i.getAxesByScale('ordinal')[0];if (a && (!o || !(function (t, e) {
        const i = t.getExtent(); let n = Math.abs(i[1] - i[0]) / t.scale.count();isNaN(n) && (n = 0);for (let o = e.count(), a = Math.max(1, Math.round(o / 5)), r = 0;r < o;r += a) if (1.5 * Xg.getSymbolSize(e, r)[t.isHorizontal() ? 1 : 0] > n) return !1;return !0;
      }(a, e)))) {
        const r = e.mapDimension(a.dim); const s = {};return R(a.getViewLabels(), (t) => {
          s[t.tickValue] = 1;
        }), function (t) {
          return !s.hasOwnProperty(e.get(r, t));
        };
      }
    }
  } function Cm(t, e, i) {
    if ('cartesian2d' !== t.type) return bm(t, e, i);const n = t.getBaseAxis().isHorizontal(); const o = wm(t, e, i);if (!i.get('clip', !0)) {
      const a = o.shape; const r = Math.max(a.width, a.height);n ? (a.y -= r, a.height += 2 * r) : (a.x -= r, a.width += 2 * r);
    } return o;
  }_c.extend({ type: 'line', init() {
    const t = new Ci; const e = new im;this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t;
  }, render(t, e, i) {
    const n = t.coordinateSystem; const o = this.group; const a = t.getData(); const r = t.getModel('lineStyle'); const s = t.getModel('areaStyle'); let l = a.mapArray(a.getItemLayout); const u = 'polar' === n.type; const h = this._coordSys; const c = this._symbolDraw; let d = this._polyline; let f = this._polygon; const p = this._lineGroup; const g = t.get('animation'); const m = !s.isEmpty(); const v = s.get('origin'); let y = (function (t, e, i) {
      if (!i.valueDim) return [];for (var n = [], o = 0, a = e.count();o < a;o++)n.push(lm(i, t, e, o));return n;
    }(n, a, sm(n, a, v))); const x = t.get('showSymbol'); const _ = x && !u && Dm(t, a, n); const w = this._data;w && w.eachItemGraphicEl((t, e) => {
      t.__temp && (o.remove(t), w.setItemGraphicEl(e, null));
    }), x || c.remove(), o.add(p);let b; const S = !u && t.get('step');n && n.getArea && t.get('clip', !0) && (null != (b = n.getArea()).width ? (b.x -= .1, b.y -= .1, b.width += .2, b.height += .2) : b.r0 && (b.r0 -= .5, b.r1 += .5)), this._clipShapeForSymbol = b, d && h.type === n.type && S === this._step ? (m && !f ? f = this._newPolygon(l, y, n, g) : f && !m && (p.remove(f), f = this._polygon = null), p.setClipPath(Cm(n, !1, t)), x && c.updateData(a, { isIgnore: _, clipShape: b }), a.eachItemGraphicEl((t) => {
      t.stopAnimation(!0);
    }), Mm(this._stackedOnPoints, y) && Mm(this._points, l) || (g ? this._updateAnimation(a, y, n, i, S, v) : (S && (l = Am(l, n, S), y = Am(y, n, S)), d.setShape({ points: l }), f && f.setShape({ points: l, stackedOnPoints: y })))) : (x && c.updateData(a, { isIgnore: _, clipShape: b }), S && (l = Am(l, n, S), y = Am(y, n, S)), d = this._newPolyline(l, n, g), m && (f = this._newPolygon(l, y, n, g)), p.setClipPath(Cm(n, !0, t)));const M = (function (t, e) {
      const i = t.getVisual('visualMeta');if (i && i.length && t.count() && 'cartesian2d' === e.type) {
        for (var n, o, a = i.length - 1;0 <= a;a--) {
          const r = i[a].dimension; const s = t.dimensions[r]; const l = t.getDimensionInfo(s);if ('x' === (n = l && l.coordDim) || 'y' === n) {
            o = i[a];break;
          }
        } if (o) {
          const u = e.getAxis(n); const h = O(o.stops, t => ({ coord: u.toGlobalCoord(u.dataToCoord(t.value)), color: t.color })); const c = h.length; const d = o.outerColors.slice();c && h[0].coord > h[c - 1].coord && (h.reverse(), d.reverse());const f = h[0].coord - 10; const p = h[c - 1].coord + 10; const g = p - f;if (g < .001) return 'transparent';R(h, (t) => {
            t.offset = (t.coord - f) / g;
          }), h.push({ offset: c ? h[c - 1].offset : .5, color: d[1] || 'transparent' }), h.unshift({ offset: c ? h[0].offset : .5, color: d[0] || 'transparent' });const m = new gs(0, 0, 0, 0, h, !0);return m[n] = f, m[`${n}2`] = p, m;
        }
      }
    }(a, n)) || a.getVisual('color');d.useStyle(D(r.getLineStyle(), { fill: 'none', stroke: M, lineJoin: 'bevel' }));let I = t.get('smooth');if (I = Tm(t.get('smooth')), d.setShape({ smooth: I, smoothMonotone: t.get('smoothMonotone'), connectNulls: t.get('connectNulls') }), f) {
      const T = a.getCalculationInfo('stackedOnSeries'); let A = 0;f.useStyle(D(s.getAreaStyle(), { fill: M, opacity: .7, lineJoin: 'bevel' })), T && (A = Tm(T.get('smooth'))), f.setShape({ smooth: I, stackedOnSmooth: A, smoothMonotone: t.get('smoothMonotone'), connectNulls: t.get('connectNulls') });
    } this._data = a, this._coordSys = n, this._stackedOnPoints = y, this._points = l, this._step = S, this._valueOrigin = v;
  }, dispose() {}, highlight(t, e, i, n) {
    const o = t.getData(); const a = Yo(o, n);if (!(a instanceof Array) && null != a && 0 <= a) {
      let r = o.getItemGraphicEl(a);if (!r) {
        const s = o.getItemLayout(a);if (!s) return;if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(s[0], s[1])) return;(r = new Xg(o, a)).position = s, r.setZ(t.get('zlevel'), t.get('z')), r.ignore = isNaN(s[0]) || isNaN(s[1]), r.__temp = !0, o.setItemGraphicEl(a, r), r.stopSymbolAnimation(!0), this.group.add(r);
      }r.highlight();
    } else _c.prototype.highlight.call(this, t, e, i, n);
  }, downplay(t, e, i, n) {
    const o = t.getData(); const a = Yo(o, n);if (null != a && 0 <= a) {
      const r = o.getItemGraphicEl(a);r && (r.__temp ? (o.setItemGraphicEl(a, null), this.group.remove(r)) : r.downplay());
    } else _c.prototype.downplay.call(this, t, e, i, n);
  }, _newPolyline(t) {
    let e = this._polyline;return e && this._lineGroup.remove(e), e = new xm({ shape: { points: t }, silent: !0, z2: 10 }), this._lineGroup.add(e), this._polyline = e;
  }, _newPolygon(t, e) {
    let i = this._polygon;return i && this._lineGroup.remove(i), i = new _m({ shape: { points: t, stackedOnPoints: e }, silent: !0 }), this._lineGroup.add(i), this._polygon = i;
  }, _updateAnimation(t, e, i, n, o, a) {
    const r = this._polyline; const s = this._polygon; const l = t.hostModel; const u = (function (t, e, i, n, o, a, r, s) {
      for (var l = (function (t, e) {
          const i = [];return e.diff(t).add((t) => {
            i.push({ cmd: '+', idx: t });
          })
            .update((t, e) => {
              i.push({ cmd: '=', idx: e, idx1: t });
            })
            .remove((t) => {
              i.push({ cmd: '-', idx: t });
            })
            .execute(), i;
        }(t, e)), u = [], h = [], c = [], d = [], f = [], p = [], g = [], m = sm(o, e, r), v = sm(a, t, s), y = 0;y < l.length;y++) {
        const x = l[y]; let _ = !0;switch (x.cmd) {
          case '=':var w = t.getItemLayout(x.idx); var b = e.getItemLayout(x.idx1);(isNaN(w[0]) || isNaN(w[1])) && (w = b.slice()), u.push(w), h.push(b), c.push(i[x.idx]), d.push(n[x.idx1]), g.push(e.getRawIndex(x.idx1));break;case '+':var S = x.idx;u.push(o.dataToPoint([e.get(m.dataDimsForPoint[0], S), e.get(m.dataDimsForPoint[1], S)])), h.push(e.getItemLayout(S).slice()), c.push(lm(m, o, e, S)), d.push(n[S]), g.push(e.getRawIndex(S));break;case '-':S = x.idx;var M = t.getRawIndex(S);M !== S ? (u.push(t.getItemLayout(S)), h.push(a.dataToPoint([t.get(v.dataDimsForPoint[0], S), t.get(v.dataDimsForPoint[1], S)])), c.push(i[S]), d.push(lm(v, a, t, S)), g.push(M)) : _ = !1;
        }_ && (f.push(x), p.push(p.length));
      }p.sort((t, e) => g[t] - g[e]);const I = []; const T = []; const A = []; const D = []; const C = [];for (y = 0;y < p.length;y++) {
        S = p[y];I[y] = u[S], T[y] = h[S], A[y] = c[S], D[y] = d[S], C[y] = f[S];
      } return { current: I, next: T, stackedOnCurrent: A, stackedOnNext: D, status: C };
    }(this._data, t, this._stackedOnPoints, e, this._coordSys, i, this._valueOrigin, a)); let h = u.current; let c = u.stackedOnCurrent; let d = u.next; let f = u.stackedOnNext;if (o && (h = Am(u.current, i, o), c = Am(u.stackedOnCurrent, i, o), d = Am(u.next, i, o), f = Am(u.stackedOnNext, i, o)), 3e3 < Im(h, d) || s && 3e3 < Im(c, f)) return r.setShape({ points: d }), void(s && s.setShape({ points: d, stackedOnPoints: f }));r.shape.__points = u.current, r.shape.points = h, cl(r, { shape: { points: d } }, l), s && (s.setShape({ points: h, stackedOnPoints: c }), cl(s, { shape: { points: d, stackedOnPoints: f } }, l));for (var p = [], g = u.status, m = 0;m < g.length;m++) {
      if ('=' === g[m].cmd) {
        const v = t.getItemGraphicEl(g[m].idx1);v && p.push({ el: v, ptIdx: m });
      }
    }r.animators && r.animators.length && r.animators[0].during(() => {
      for (let t = 0;t < p.length;t++) {
        p[t].el.attr('position', r.shape.__points[p[t].ptIdx]);
      }
    });
  }, remove(t) {
    const i = this.group; const n = this._data;this._lineGroup.removeAll(), this._symbolDraw.remove(!0), n && n.eachItemGraphicEl((t, e) => {
      t.__temp && (i.remove(t), n.setItemGraphicEl(e, null));
    }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
  } });function Lm(t, r, s) {
    return { seriesType: t, performRawSeries: !0, reset(u, t, e) {
      const i = u.getData(); const h = u.get('symbol'); const c = u.get('symbolSize'); const n = u.get('symbolKeepAspect'); const d = u.get('symbolRotate'); const f = C(h); const p = C(c); const g = C(d); const m = f || p || g; const o = !f && h ? h : r; const a = p ? null : c;if (i.setVisual({ legendSymbol: s || o, symbol: o, symbolSize: a, symbolKeepAspect: n, symbolRotate: d }), !t.isSeriesFiltered(u)) return { dataEach: i.hasItemOption || m ? function (t, e) {
        if (m) {
          const i = u.getRawValue(e); const n = u.getDataParams(e);f && t.setItemVisual(e, 'symbol', h(i, n)), p && t.setItemVisual(e, 'symbolSize', c(i, n)), g && t.setItemVisual(e, 'symbolRotate', d(i, n));
        } if (t.hasItemOption) {
          const o = t.getItemModel(e); const a = o.getShallow('symbol', !0); const r = o.getShallow('symbolSize', !0); const s = o.getShallow('symbolRotate', !0); const l = o.getShallow('symbolKeepAspect', !0);null != a && t.setItemVisual(e, 'symbol', a), null != r && t.setItemVisual(e, 'symbolSize', r), null != s && t.setItemVisual(e, 'symbolRotate', s), null != l && t.setItemVisual(e, 'symbolKeepAspect', l);
        }
      } : null };
    } };
  } function km(t) {
    return { seriesType: t, plan: vc(), reset(t) {
      const e = t.getData(); const c = t.coordinateSystem; const d = t.pipelineContext.large;if (c) {
        const f = O(c.dimensions, t => e.mapDimension(t)).slice(0, 2); const p = f.length; const i = e.getCalculationInfo('stackResultDimension');return fp(e, f[0]) && (f[0] = i), fp(e, f[1]) && (f[1] = i), p && { progress(t, e) {
          for (var i = t.end - t.start, n = d && new Float32Array(i * p), o = t.start, a = 0, r = [], s = [];o < t.end;o++) {
            var l;if (1 === p) {
              var u = e.get(f[0], o);l = !isNaN(u) && c.dataToPoint(u, null, s);
            } else {
              u = r[0] = e.get(f[0], o);const h = r[1] = e.get(f[1], o);l = !isNaN(u) && !isNaN(h) && c.dataToPoint(r, null, s);
            }d ? (n[a++] = l ? l[0] : NaN, n[a++] = l ? l[1] : NaN) : e.setItemLayout(o, l && l.slice() || [NaN, NaN]);
          }d && e.setLayout('symbolPoints', n);
        } };
      }
    } };
  } function Pm(t, e) {
    return Math.round(t.length / 2);
  } const Nm = { average(t) {
    for (var e = 0, i = 0, n = 0;n < t.length;n++)isNaN(t[n]) || (e += t[n], i++);return 0 === i ? NaN : e / i;
  }, sum(t) {
    for (var e = 0, i = 0;i < t.length;i++)e += t[i] || 0;return e;
  }, max(t) {
    for (var e = -1 / 0, i = 0;i < t.length;i++)t[i] > e && (e = t[i]);return isFinite(e) ? e : NaN;
  }, min(t) {
    for (var e = 1 / 0, i = 0;i < t.length;i++)t[i] < e && (e = t[i]);return isFinite(e) ? e : NaN;
  }, nearest(t) {
    return t[0];
  } };function Om(t) {
    return this._axes[t];
  } function Rm(t) {
    this._axes = {}, this._dimList = [], this.name = t || '';
  } function Em(t) {
    Rm.call(this, t);
  }Rm.prototype = { constructor: Rm, type: 'cartesian', getAxis(t) {
    return this._axes[t];
  }, getAxes() {
    return O(this._dimList, Om, this);
  }, getAxesByScale(e) {
    return e = e.toLowerCase(), M(this.getAxes(), t => t.scale.type === e);
  }, addAxis(t) {
    const e = t.dim;this._axes[e] = t, this._dimList.push(e);
  }, dataToCoord(t) {
    return this._dataCoordConvert(t, 'dataToCoord');
  }, coordToData(t) {
    return this._dataCoordConvert(t, 'coordToData');
  }, _dataCoordConvert(t, e) {
    for (var i = this._dimList, n = t instanceof Array ? [] : {}, o = 0;o < i.length;o++) {
      const a = i[o]; const r = this._axes[a];n[a] = r[e](t[a]);
    } return n;
  } }, Em.prototype = { constructor: Em, type: 'cartesian2d', dimensions: ['x', 'y'], getBaseAxis() {
    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');
  }, containPoint(t) {
    const e = this.getAxis('x'); const i = this.getAxis('y');return e.contain(e.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1]));
  }, containData(t) {
    return this.getAxis('x').containData(t[0]) && this.getAxis('y').containData(t[1]);
  }, dataToPoint(t, e, i) {
    const n = this.getAxis('x'); const o = this.getAxis('y');return (i = i || [])[0] = n.toGlobalCoord(n.dataToCoord(t[0])), i[1] = o.toGlobalCoord(o.dataToCoord(t[1])), i;
  }, clampData(t, e) {
    const i = this.getAxis('x').scale; const n = this.getAxis('y').scale; const o = i.getExtent(); const a = n.getExtent(); const r = i.parse(t[0]); const s = n.parse(t[1]);return (e = e || [])[0] = Math.min(Math.max(Math.min(o[0], o[1]), r), Math.max(o[0], o[1])), e[1] = Math.min(Math.max(Math.min(a[0], a[1]), s), Math.max(a[0], a[1])), e;
  }, pointToData(t, e) {
    const i = this.getAxis('x'); const n = this.getAxis('y');return (e = e || [])[0] = i.coordToData(i.toLocalCoord(t[0])), e[1] = n.coordToData(n.toLocalCoord(t[1])), e;
  }, getOtherAxis(t) {
    return this.getAxis('x' === t.dim ? 'y' : 'x');
  }, getArea() {
    const t = this.getAxis('x').getGlobalExtent(); const e = this.getAxis('y').getGlobalExtent(); const i = Math.min(t[0], t[1]); const n = Math.min(e[0], e[1]);return new Di(i, n, Math.max(t[0], t[1]) - i, Math.max(e[0], e[1]) - n);
  } }, w(Em, Rm);function zm(t, e, i, n, o) {
    Gg.call(this, t, e, i), this.type = n || 'value', this.position = o || 'bottom';
  }zm.prototype = { constructor: zm, index: 0, getAxesOnZeroOf: null, model: null, isHorizontal() {
    const t = this.position;return 'top' === t || 'bottom' === t;
  }, getGlobalExtent(t) {
    const e = this.getExtent();return e[0] = this.toGlobalCoord(e[0]), e[1] = this.toGlobalCoord(e[1]), t && e[0] > e[1] && e.reverse(), e;
  }, getOtherAxis() {
    this.grid.getOtherAxis();
  }, pointToData(t, e) {
    return this.coordToData(this.toLocalCoord(t['x' === this.dim ? 0 : 1]), e);
  }, toLocalCoord: null, toGlobalCoord: null }, w(zm, Gg);const Bm = { show: !0, zlevel: 0, z: 0, inverse: !1, name: '', nameLocation: 'end', nameRotate: null, nameTruncate: { maxWidth: null, ellipsis: '...', placeholder: '.' }, nameTextStyle: {}, nameGap: 15, silent: !1, triggerEvent: !1, tooltip: { show: !1 }, axisPointer: {}, axisLine: { show: !0, onZero: !0, onZeroAxisIndex: null, lineStyle: { color: '#333', width: 1, type: 'solid' }, symbol: ['none', 'none'], symbolSize: [10, 15] }, axisTick: { show: !0, inside: !1, length: 5, lineStyle: { width: 1 } }, axisLabel: { show: !0, inside: !1, rotate: 0, showMinLabel: null, showMaxLabel: null, margin: 8, fontSize: 12 }, splitLine: { show: !0, lineStyle: { color: ['#ccc'], width: 1, type: 'solid' } }, splitArea: { show: !1, areaStyle: { color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)'] } } }; const Vm = {};Vm.categoryAxis = m({ boundaryGap: !0, deduplication: null, splitLine: { show: !1 }, axisTick: { alignWithLabel: !1, interval: 'auto' }, axisLabel: { interval: 'auto' } }, Bm), Vm.valueAxis = m({ boundaryGap: [0, 0], splitNumber: 5, minorTick: { show: !1, splitNumber: 5, length: 3, lineStyle: {} }, minorSplitLine: { show: !1, lineStyle: { color: '#eee', width: 1 } } }, Bm), Vm.timeAxis = D({ scale: !0, min: 'dataMin', max: 'dataMax' }, Vm.valueAxis), Vm.logAxis = D({ scale: !0, logBase: 10 }, Vm.valueAxis);function Gm(a, t, r, e) {
    R(Fm, (o) => {
      t.extend({ type: `${a}Axis.${o}`, mergeDefaultAndTheme(t, e) {
        const i = this.layoutMode; const n = i ? Iu(t) : {};m(t, e.getTheme().get(`${o}Axis`)), m(t, this.getDefaultOption()), t.type = r(a, t), i && Mu(t, n, i);
      }, optionUpdated() {
        'category' === this.option.type && (this.__ordinalMeta = vp.createByAxisModel(this));
      }, getCategories(t) {
        const e = this.option;if ('category' === e.type) return t ? e.data : this.__ordinalMeta.categories;
      }, getOrdinalMeta() {
        return this.__ordinalMeta;
      }, defaultOption: p([{}, Vm[`${o}Axis`], e], !0) });
    }), ku.registerSubTypeDefaulter(`${a}Axis`, T(r, a));
  } var Fm = ['value', 'category', 'time', 'log']; var Wm = ku.extend({ type: 'cartesian2dAxis', axis: null, init() {
    Wm.superApply(this, 'init', arguments), this.resetRange();
  }, mergeOption() {
    Wm.superApply(this, 'mergeOption', arguments), this.resetRange();
  }, restoreData() {
    Wm.superApply(this, 'restoreData', arguments), this.resetRange();
  }, getCoordSysModel() {
    return this.ecModel.queryComponents({ mainType: 'grid', index: this.option.gridIndex, id: this.option.gridId })[0];
  } });function Hm(t, e) {
    return e.type || (e.data ? 'category' : 'value');
  }m(Wm.prototype, dg);const Zm = { offset: 0 };function Um(t, e) {
    return t.getCoordSysModel() === e;
  } function Xm(t, e, i) {
    this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, i), this.model = t;
  }Gm('x', Wm, Hm, Zm), Gm('y', Wm, Hm, Zm), ku.extend({ type: 'grid', dependencies: ['xAxis', 'yAxis'], layoutMode: 'box', coordinateSystem: null, defaultOption: { show: !1, zlevel: 0, z: 0, left: '10%', top: 60, right: '10%', bottom: 60, containLabel: !1, backgroundColor: 'rgba(0,0,0,0)', borderWidth: 1, borderColor: '#ccc' } });const Ym = Xm.prototype;function jm(t, e, i, n) {
    i.getAxesOnZeroOf = function () {
      return o ? [o] : [];
    };let o; const a = t[e]; const r = i.model; const s = r.get('axisLine.onZero'); const l = r.get('axisLine.onZeroAxisIndex');if (s) {
      if (null != l)qm(a[l]) && (o = a[l]);else for (const u in a) if (a.hasOwnProperty(u) && qm(a[u]) && !n[h(a[u])]) {
        o = a[u];break;
      }o && (n[h(o)] = !0);
    } function h(t) {
      return `${t.dim}_${t.index}`;
    }
  } function qm(t) {
    return t && 'category' !== t.type && 'time' !== t.type && (function (t) {
      const e = t.scale.getExtent(); const i = e[0]; const n = e[1];return !(0 < i && 0 < n || i < 0 && n < 0);
    }(t));
  }Ym.type = 'grid', Ym.axisPointerEnabled = !0, Ym.getRect = function () {
    return this._rect;
  }, Ym.update = function (t, e) {
    const i = this._axesMap;this._updateScale(t, this.model), R(i.x, (t) => {
      rg(t.scale, t.model);
    }), R(i.y, (t) => {
      rg(t.scale, t.model);
    });const n = {};R(i.x, (t) => {
      jm(i, 'y', t, n);
    }), R(i.y, (t) => {
      jm(i, 'x', t, n);
    }), this.resize(this.model, e);
  }, Ym.resize = function (t, e, i) {
    const o = bu(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() });this._rect = o;const n = this._axesList;function a() {
      R(n, (t) => {
        const e = t.isHorizontal(); const i = e ? [0, o.width] : [0, o.height]; const n = t.inverse ? 1 : 0;t.setExtent(i[n], i[1 - n]), (function (t, e) {
          const i = t.getExtent(); const n = i[0] + i[1];t.toGlobalCoord = 'x' === t.dim ? function (t) {
            return t + e;
          } : function (t) {
            return n - t + e;
          }, t.toLocalCoord = 'x' === t.dim ? function (t) {
            return t - e;
          } : function (t) {
            return n - t + e;
          };
        }(t, e ? o.x : o.y));
      });
    }a(), !i && t.get('containLabel') && (R(n, (t) => {
      if (!t.model.get('axisLabel.inside')) {
        const e = (function (t) {
          const e = t.model; const i = t.scale;if (e.get('axisLabel.show') && !i.isBlank()) {
            let n; let o; const a = 'category' === t.type; const r = i.getExtent();o = a ? i.count() : (n = i.getTicks()).length;let s; let l; let u; let h; let c; let d; let f; let p; let g; const m = t.getLabelModel(); const v = lg(t); let y = 1;40 < o && (y = Math.ceil(o / 40));for (let x = 0;x < o;x += y) {
              const _ = v(n ? n[x] : r[0] + x); const w = m.getTextRect(_); const b = (l = w, u = m.get('rotate') || 0, void 0, h = u * Math.PI / 180, c = l.plain(), d = c.width, f = c.height, p = d * Math.abs(Math.cos(h)) + Math.abs(f * Math.sin(h)), g = d * Math.abs(Math.sin(h)) + Math.abs(f * Math.cos(h)), new Di(c.x, c.y, p, g));s ? s.union(b) : s = b;
            } return s;
          }
        }(t));if (e) {
          const i = t.isHorizontal() ? 'height' : 'width'; const n = t.model.get('axisLabel.margin');o[i] -= e[i] + n, 'top' === t.position ? o.y += e.height + n : 'left' === t.position && (o.x += e.width + n);
        }
      }
    }), a());
  }, Ym.getAxis = function (t, e) {
    const i = this._axesMap[t];if (null != i) {
      if (null == e) for (const n in i) if (i.hasOwnProperty(n)) return i[n];return i[e];
    }
  }, Ym.getAxes = function () {
    return this._axesList.slice();
  }, Ym.getCartesian = function (t, e) {
    if (null != t && null != e) {
      const i = `x${t}y${e}`;return this._coordsMap[i];
    }z(t) && (e = t.yAxisIndex, t = t.xAxisIndex);for (let n = 0, o = this._coordsList;n < o.length;n++) if (o[n].getAxis('x').index === t || o[n].getAxis('y').index === e) return o[n];
  }, Ym.getCartesians = function () {
    return this._coordsList.slice();
  }, Ym.convertToPixel = function (t, e, i) {
    const n = this._findConvertTarget(t, e);return n.cartesian ? n.cartesian.dataToPoint(i) : n.axis ? n.axis.toGlobalCoord(n.axis.dataToCoord(i)) : null;
  }, Ym.convertFromPixel = function (t, e, i) {
    const n = this._findConvertTarget(t, e);return n.cartesian ? n.cartesian.pointToData(i) : n.axis ? n.axis.coordToData(n.axis.toLocalCoord(i)) : null;
  }, Ym._findConvertTarget = function (t, e) {
    let i; let n; const o = e.seriesModel; const a = e.xAxisModel || o && o.getReferringComponents('xAxis')[0]; const r = e.yAxisModel || o && o.getReferringComponents('yAxis')[0]; const s = e.gridModel; const l = this._coordsList;if (o)_(l, i = o.coordinateSystem) < 0 && (i = null);else if (a && r)i = this.getCartesian(a.componentIndex, r.componentIndex);else if (a)n = this.getAxis('x', a.componentIndex);else if (r)n = this.getAxis('y', r.componentIndex);else if (s) {
      s.coordinateSystem === this && (i = this._coordsList[0]);
    } return { cartesian: i, axis: n };
  }, Ym.containPoint = function (t) {
    const e = this._coordsList[0];if (e) return e.containPoint(t);
  }, Ym._initCartesian = function (r, t, e) {
    const s = { left: !1, right: !1, top: !1, bottom: !1 }; const l = { x: {}, y: {} }; const u = { x: 0, y: 0 };if (t.eachComponent('xAxis', i('x'), this), t.eachComponent('yAxis', i('y'), this), !u.x || !u.y) return this._axesMap = {}, void(this._axesList = []);function i(a) {
      return function (t, e) {
        if (Um(t, r)) {
          let i = t.get('position');'x' === a ? 'top' !== i && 'bottom' !== i && (i = s.bottom ? 'top' : 'bottom') : 'left' !== i && 'right' !== i && (i = s.left ? 'right' : 'left'), s[i] = !0;const n = new zm(a, sg(t), [0, 0], t.get('type'), i); const o = 'category' === n.type;n.onBand = o && t.get('boundaryGap'), n.inverse = t.get('inverse'), (t.axis = n).model = t, n.grid = this, n.index = e, this._axesList.push(n), l[a][e] = n, u[a]++;
        }
      };
    }R((this._axesMap = l).x, function (o, a) {
      R(l.y, function (t, e) {
        const i = `x${a}y${e}`; const n = new Em(i);n.grid = this, n.model = r, this._coordsMap[i] = n, this._coordsList.push(n), n.addAxis(o), n.addAxis(t);
      }, this);
    }, this);
  }, Ym._updateScale = function (l, u) {
    function h(e, i) {
      R(e.mapDimension(i.dim, !0), (t) => {
        i.scale.unionExtentFromData(e, pp(e, t));
      });
    }R(this._axesList, (t) => {
      t.scale.setExtent(1 / 0, -1 / 0);
    }), l.eachSeries(function (t) {
      if (Jm(t)) {
        const e = $m(t, l); const i = e[0]; const n = e[1];if (!Um(i, u) || !Um(n, u)) return;const o = this.getCartesian(i.componentIndex, n.componentIndex); const a = t.getData(); const r = o.getAxis('x'); const s = o.getAxis('y');'list' === a.type && (h(a, r, t), h(a, s, t));
      }
    }, this);
  }, Ym.getTooltipAxes = function (n) {
    const o = []; const a = [];return R(this.getCartesians(), (t) => {
      const e = null != n && 'auto' !== n ? t.getAxis(n) : t.getBaseAxis(); const i = t.getOtherAxis(e);_(o, e) < 0 && o.push(e), _(a, i) < 0 && a.push(i);
    }), { baseAxes: o, otherAxes: a };
  };const Km = ['xAxis', 'yAxis'];function $m(e) {
    return O(Km, t => e.getReferringComponents(t)[0]);
  } function Jm(t) {
    return 'cartesian2d' === t.get('coordinateSystem');
  }Xm.create = function (n, o) {
    const a = [];return n.eachComponent('grid', (t, e) => {
      const i = new Xm(t, n, o);i.name = `grid_${e}`, i.resize(t, o, !0), t.coordinateSystem = i, a.push(i);
    }), n.eachSeries((t) => {
      if (Jm(t)) {
        const e = $m(t); const i = e[0]; const n = e[1]; const o = i.getCoordSysModel().coordinateSystem;t.coordinateSystem = o.getCartesian(i.componentIndex, n.componentIndex);
      }
    }), a;
  }, Xm.dimensions = Xm.prototype.dimensions = Em.prototype.dimensions, lh.register('cartesian2d', Xm);function Qm(t, e) {
    this.opt = e, this.axisModel = t, D(e, { labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: !0 }), this.group = new Ci;const i = new Ci({ position: e.position.slice(), rotation: e.rotation });i.updateTransform(), this._transform = i.transform, this._dumbGroup = i;
  } const tv = Math.PI;Qm.prototype = { constructor: Qm, hasBuilder(t) {
    return !!ev[t];
  }, add(t) {
    ev[t].call(this);
  }, getGroup() {
    return this.group;
  } };var ev = { axisLine() {
    const a = this.opt; const t = this.axisModel;if (t.get('axisLine.show')) {
      const e = this.axisModel.axis.getExtent(); const i = this._transform; const r = [e[0], 0]; const n = [e[1], 0];i && (bt(r, r, i), bt(n, n, i));const s = P({ lineCap: 'round' }, t.getModel('axisLine.lineStyle').getLineStyle());this.group.add(new ls({ anid: 'line', subPixelOptimize: !0, shape: { x1: r[0], y1: r[1], x2: n[0], y2: n[1] }, style: s, strokeContainThreshold: a.strokeContainThreshold || 5, silent: !0, z2: 1 }));let l = t.get('axisLine.symbol'); let o = t.get('axisLine.symbolSize'); let u = t.get('axisLine.symbolOffset') || 0;if ('number' === typeof u && (u = [u, u]), null != l) {
        'string' === typeof l && (l = [l, l]), 'string' !== typeof o && 'number' !== typeof o || (o = [o, o]);const h = o[0]; const c = o[1];R([{ rotate: a.rotation + Math.PI / 2, offset: u[0], r: 0 }, { rotate: a.rotation - Math.PI / 2, offset: u[1], r: Math.sqrt((r[0] - n[0]) * (r[0] - n[0]) + (r[1] - n[1]) * (r[1] - n[1])) }], function (t, e) {
          if ('none' !== l[e] && null != l[e]) {
            const i = wg(l[e], -h / 2, -c / 2, h, c, s.stroke, !0); const n = t.r + t.offset; const o = [r[0] + n * Math.cos(a.rotation), r[1] - n * Math.sin(a.rotation)];i.attr({ rotation: t.rotate, position: o, silent: !0, z2: 11 }), this.group.add(i);
          }
        }, this);
      }
    }
  }, axisTickLabel() {
    const t = this.axisModel; const e = this.opt; const i = (function (t, e, i) {
      const n = e.axis; const o = e.getModel('axisTick');if (!o.get('show') || n.scale.isBlank()) return;for (var a = o.getModel('lineStyle'), r = i.tickDirection * o.get('length'), s = lv(n.getTicksCoords(), t._transform, r, D(a.getLineStyle(), { stroke: e.get('axisLine.lineStyle.color') }), 'ticks'), l = 0;l < s.length;l++)t.group.add(s[l]);return s;
    }(this, t, e));!(function (t, e, i) {
      if (cg(t.axis)) return;const n = t.get('axisLabel.showMinLabel'); const o = t.get('axisLabel.showMaxLabel');i = i || [];const a = (e = e || [])[0]; const r = e[1]; const s = e[e.length - 1]; const l = e[e.length - 2]; const u = i[0]; const h = i[1]; const c = i[i.length - 1]; const d = i[i.length - 2];!1 === n ? (av(a), av(u)) : rv(a, r) && (n ? (av(r), av(h)) : (av(a), av(u)));!1 === o ? (av(s), av(c)) : rv(l, s) && (o ? (av(l), av(d)) : (av(s), av(c)));
    }(t, (function (u, h, c) {
      const d = h.axis;if (!W(c.axisLabelShow, h.get('axisLabel.show')) || d.scale.isBlank()) return;const f = h.getModel('axisLabel'); const p = f.get('margin'); const t = d.getViewLabels(); const e = (W(c.labelRotate, f.get('rotate')) || 0) * tv / 180; const g = nv(c.rotation, e, c.labelDirection); const m = h.getCategories && h.getCategories(!0); const v = []; const y = ov(h); const x = h.get('triggerEvent');return R(t, (t, e) => {
        const i = t.tickValue; const n = t.formattedLabel; const o = t.rawLabel; let a = f;m && m[i] && m[i].textStyle && (a = new Cl(m[i].textStyle, f, h.ecModel));const r = a.getTextColor() || h.get('axisLine.lineStyle.color'); const s = [d.dataToCoord(i), c.labelOffset + c.labelDirection * p]; const l = new Ur({ anid: `label_${i}`, position: s, rotation: g.rotation, silent: y, z2: 10 });nl(l.style, a, { text: n, textAlign: a.getShallow('align', !0) || g.textAlign, textVerticalAlign: a.getShallow('verticalAlign', !0) || a.getShallow('baseline', !0) || g.textVerticalAlign, textFill: 'function' === typeof r ? r('category' === d.type ? o : 'value' === d.type ? `${i}` : i, e) : r }), x && (l.eventData = iv(h), l.eventData.targetType = 'axisLabel', l.eventData.value = o), u._dumbGroup.add(l), l.updateTransform(), v.push(l), u.group.add(l), l.decomposeTransform();
      }), v;
    }(this, t, e)), i)), (function (t, e, i) {
      const n = e.axis; const o = e.getModel('minorTick');if (!o.get('show') || n.scale.isBlank()) return;const a = n.getMinorTicksCoords();if (!a.length) return;for (let r = o.getModel('lineStyle'), s = i.tickDirection * o.get('length'), l = D(r.getLineStyle(), D(e.getModel('axisTick').getLineStyle(), { stroke: e.get('axisLine.lineStyle.color') })), u = 0;u < a.length;u++) for (let h = lv(a[u], t._transform, s, l, `minorticks_${u}`), c = 0;c < h.length;c++)t.group.add(h[c]);
    }(this, t, e));
  }, axisName() {
    const t = this.opt; const e = this.axisModel; const i = W(t.axisName, e.get('name'));if (i) {
      let n; let o; const a = e.get('nameLocation'); const r = t.nameDirection; const s = e.getModel('nameTextStyle'); const l = e.get('nameGap') || 0; const u = this.axisModel.axis.getExtent(); const h = u[0] > u[1] ? -1 : 1; const c = ['start' === a ? u[0] - h * l : 'end' === a ? u[1] + h * l : (u[0] + u[1]) / 2, sv(a) ? t.labelOffset + r * l : 0]; let d = e.get('nameRotate');null != d && (d = d * tv / 180), sv(a) ? n = nv(t.rotation, null != d ? d : t.rotation, r) : (n = (function (t, e, i, n) {
        let o; let a; const r = Zl(i - t.rotation); const s = n[0] > n[1]; const l = 'start' === e && !s || 'start' !== e && s;o = Ul(r - tv / 2) ? (a = l ? 'bottom' : 'top', 'center') : Ul(r - 1.5 * tv) ? (a = l ? 'top' : 'bottom', 'center') : (a = 'middle', r < 1.5 * tv && tv / 2 < r ? l ? 'left' : 'right' : l ? 'right' : 'left');return { rotation: r, textAlign: o, textVerticalAlign: a };
      }(t, a, d || 0, u)), null != (o = t.axisNameAvailableWidth) && (o = Math.abs(o / Math.sin(n.rotation)), isFinite(o) || (o = null)));const f = s.getFont(); const p = e.get('nameTruncate', !0) || {}; const g = p.ellipsis; const m = W(t.nameTruncateMaxWidth, p.maxWidth, o); const v = null != g && null != m ? pu(i, m, f, g, { minChar: 2, placeholder: p.placeholder }) : i; const y = e.get('tooltip', !0); const x = e.mainType; const _ = { componentType: x, name: i, $vars: ['name'] };_[`${x}Index`] = e.componentIndex;const w = new Ur({ anid: 'name', __fullText: i, __truncatedText: v, position: c, rotation: n.rotation, silent: ov(e), z2: 1, tooltip: y && y.show ? P({ content: i, formatter() {
        return i;
      }, formatterParams: _ }, y) : null });nl(w.style, s, { text: v, textFont: f, textFill: s.getTextColor() || e.get('axisLine.lineStyle.color'), textAlign: s.get('align') || n.textAlign, textVerticalAlign: s.get('verticalAlign') || n.textVerticalAlign }), e.get('triggerEvent') && (w.eventData = iv(e), w.eventData.targetType = 'axisName', w.eventData.name = i), this._dumbGroup.add(w), w.updateTransform(), this.group.add(w), w.decomposeTransform();
    }
  } }; var iv = Qm.makeAxisEventDataBase = function (t) {
    const e = { componentType: t.mainType, componentIndex: t.componentIndex };return e[`${t.mainType}Index`] = t.componentIndex, e;
  }; var nv = Qm.innerTextLayout = function (t, e, i) {
    let n; const o = Zl(e - t);return { rotation: o, textAlign: Ul(o) ? (n = 0 < i ? 'top' : 'bottom', 'center') : Ul(o - tv) ? (n = 0 < i ? 'bottom' : 'top', 'center') : (n = 'middle', 0 < o && o < tv ? 0 < i ? 'right' : 'left' : 0 < i ? 'left' : 'right'), textVerticalAlign: n };
  };var ov = Qm.isLabelSilent = function (t) {
    const e = t.get('tooltip');return t.get('silent') || !(t.get('triggerEvent') || e && e.show);
  };function av(t) {
    t && (t.ignore = !0);
  } function rv(t, e) {
    const i = t && t.getBoundingRect().clone(); const n = e && e.getBoundingRect().clone();if (i && n) {
      const o = re([]);return he(o, o, -t.rotation), i.applyTransform(le([], o, t.getLocalTransform())), n.applyTransform(le([], o, e.getLocalTransform())), i.intersect(n);
    }
  } function sv(t) {
    return 'middle' === t || 'center' === t;
  } function lv(t, e, i, n, o) {
    for (var a = [], r = [], s = [], l = 0;l < t.length;l++) {
      const u = t[l].coord;r[0] = u, s[r[1] = 0] = u, s[1] = i, e && (bt(r, r, e), bt(s, s, e));const h = new ls({ anid: `${o}_${t[l].tickValue}`, subPixelOptimize: !0, shape: { x1: r[0], y1: r[1], x2: s[0], y2: s[1] }, style: n, z2: 2, silent: !0 });a.push(h);
    } return a;
  } const uv = R; const hv = T;function cv(t, e) {
    const i = { axesInfo: {}, seriesInvolved: !1, coordSysAxesInfo: {}, coordSysMap: {} };return (function (p, g, t) {
      const a = g.getComponent('tooltip'); const m = g.getComponent('axisPointer'); const v = m.get('link', !0) || []; const y = [];uv(t.getCoordinateSystems(), (c) => {
        if (c.axisPointerEnabled) {
          const t = gv(c.model); var d = p.coordSysAxesInfo[t] = {}; var f = (p.coordSysMap[t] = c).model.getModel('tooltip', a);if (uv(c.getAxes(), hv(o, !1, null)), c.getTooltipAxes && a && f.get('show')) {
            const e = 'axis' === f.get('trigger'); const i = 'cross' === f.get('axisPointer.type'); const n = c.getTooltipAxes(f.get('axisPointer.axis'));(e || i) && uv(n.baseAxes, hv(o, !i || 'cross', e)), i && uv(n.otherAxes, hv(o, 'cross', !1));
          }
        } function o(t, e, i) {
          let n = i.model.getModel('axisPointer', m); const o = n.get('show');if (o && ('auto' !== o || t || pv(n))) {
            null == e && (e = n.get('triggerTooltip'));const a = (n = t ? (function (t, e, i, n, o, a) {
              const r = e.getModel('axisPointer'); const s = {};uv(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], (t) => {
                s[t] = k(r.get(t));
              }), s.snap = 'category' !== t.type && !!a, 'cross' === r.get('type') && (s.type = 'line');const l = s.label || (s.label = {});if (null == l.show && (l.show = !1), 'cross' === o) {
                const u = r.get('label.show');if (l.show = null == u || u, !a) {
                  const h = s.lineStyle = r.get('crossStyle');h && D(l, h.textStyle);
                }
              } return t.model.getModel('axisPointer', new Cl(s, i, n));
            }(i, f, m, g, t, e)) : n).get('snap'); const r = gv(i.model); const s = e || a || 'category' === i.type; const l = p.axesInfo[r] = { key: r, axis: i, coordSys: c, axisPointerModel: n, triggerTooltip: e, involveSeries: s, snap: a, useHandle: pv(n), seriesModels: [] };d[r] = l, p.seriesInvolved |= s;const u = (function (t, e) {
              for (let i = e.model, n = e.dim, o = 0;o < t.length;o++) {
                const a = t[o] || {};if (dv(a[`${n}AxisId`], i.id) || dv(a[`${n}AxisIndex`], i.componentIndex) || dv(a[`${n}AxisName`], i.name)) return o;
              }
            }(v, i));if (null != u) {
              const h = y[u] || (y[u] = { axesInfo: {} });h.axesInfo[r] = l, h.mapper = v[u].mapper, l.linkGroup = h;
            }
          }
        }
      });
    }(i, t, e)), i.seriesInvolved && (function (o, t) {
      t.eachSeries((i) => {
        const n = i.coordinateSystem; const t = i.get('tooltip.trigger', !0); const e = i.get('tooltip.show', !0);n && 'none' !== t && !1 !== t && 'item' !== t && !1 !== e && !1 !== i.get('axisPointer.show', !0) && uv(o.coordSysAxesInfo[gv(n.model)], (t) => {
          const e = t.axis;n.getAxis(e.dim) === e && (t.seriesModels.push(i), null == t.seriesDataCount && (t.seriesDataCount = 0), t.seriesDataCount += i.getData().count());
        });
      }, this);
    }(i, t)), i;
  } function dv(t, e) {
    return 'all' === t || L(t) && 0 <= _(t, e) || t === e;
  } function fv(t) {
    const e = (t.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;return e && e.axesInfo[gv(t)];
  } function pv(t) {
    return !!t.get('handle.show');
  } function gv(t) {
    return `${t.type}||${t.id}`;
  } var mv = Af({ type: 'axis', _axisPointer: null, axisPointerClass: null, render(t, e, i, n) {
    this.axisPointerClass && (function (t) {
      const e = fv(t);if (e) {
        const i = e.axisPointerModel; const n = e.axis.scale; const o = i.option; const a = i.get('status'); let r = i.get('value');null != r && (r = n.parse(r));const s = pv(i);null == a && (o.status = s ? 'show' : 'hide');const l = n.getExtent().slice();l[0] > l[1] && l.reverse(), (null == r || r > l[1]) && (r = l[1]), r < l[0] && (r = l[0]), o.value = r, s && (o.status = e.axis.scale.isBlank() ? 'hide' : 'show');
      }
    }(t)), mv.superApply(this, 'render', arguments), vv(this, t, e, i, n, !0);
  }, updateAxisPointer(t, e, i, n, o) {
    vv(this, t, e, i, n, !1);
  }, remove(t, e) {
    const i = this._axisPointer;i && i.remove(e), mv.superApply(this, 'remove', arguments);
  }, dispose(t, e) {
    yv(this, e), mv.superApply(this, 'dispose', arguments);
  } });function vv(t, e, i, n, o, a) {
    const r = mv.getAxisPointerClass(t.axisPointerClass);if (r) {
      const s = (function (t) {
        const e = fv(t);return e && e.axisPointerModel;
      }(e));s ? (t._axisPointer || (t._axisPointer = new r)).render(e, s, n, a) : yv(t, n);
    }
  } function yv(t, e, i) {
    const n = t._axisPointer;n && n.dispose(e, i), t._axisPointer = null;
  } const xv = [];function _v(t, e, i) {
    i = i || {};const n = t.coordinateSystem; const o = e.axis; const a = {}; const r = o.getAxesOnZeroOf()[0]; const s = o.position; const l = r ? 'onZero' : s; const u = o.dim; const h = n.getRect(); const c = [h.x, h.x + h.width, h.y, h.y + h.height]; const d = { left: 0, right: 1, top: 0, bottom: 1, onZero: 2 }; const f = e.get('offset') || 0; const p = 'x' === u ? [c[2] - f, c[3] + f] : [c[0] - f, c[1] + f];if (r) {
      const g = r.toGlobalCoord(r.dataToCoord(0));p[d.onZero] = Math.max(Math.min(g, p[1]), p[0]);
    }a.position = ['y' === u ? p[d[l]] : c[0], 'x' === u ? p[d[l]] : c[3]], a.rotation = Math.PI / 2 * ('x' === u ? 0 : 1);a.labelDirection = a.tickDirection = a.nameDirection = { top: -1, bottom: 1, left: -1, right: 1 }[s], a.labelOffset = r ? p[d[s]] - p[d.onZero] : 0, e.get('axisTick.inside') && (a.tickDirection = -a.tickDirection), W(i.labelInside, e.get('axisLabel.inside')) && (a.labelDirection = -a.labelDirection);const m = e.get('axisLabel.rotate');return a.labelRotate = 'top' === l ? -m : m, a.z2 = 1, a;
  } function wv(t, e, i, n) {
    const o = i.axis;if (!o.scale.isBlank()) {
      const a = i.getModel('splitArea'); const r = a.getModel('areaStyle'); let s = r.get('color'); const l = n.coordinateSystem.getRect(); const u = o.getTicksCoords({ tickModel: a, clamp: !0 });if (u.length) {
        const h = s.length; const c = t.__splitAreaColors; const d = Q(); let f = 0;if (c) for (var p = 0;p < u.length;p++) {
          const g = c.get(u[p].tickValue);if (null != g) {
            f = (g + (h - 1) * p) % h;break;
          }
        } let m = o.toGlobalCoord(u[0].coord); const v = r.getAreaStyle();s = L(s) ? s : [s];for (p = 1;p < u.length;p++) {
          var y; var x; var _; var w; const b = o.toGlobalCoord(u[p].coord);m = o.isHorizontal() ? (y = m, x = l.y, _ = b - y, w = l.height, y + _) : (y = l.x, x = m, _ = l.width, x + (w = b - x));const S = u[p - 1].tickValue;null != S && d.set(S, f), e.add(new rs({ anid: null != S ? `area_${S}` : null, shape: { x: y, y: x, width: _, height: w }, style: D({ fill: s[f] }, v), silent: !0 })), f = (f + 1) % h;
        }t.__splitAreaColors = d;
      }
    }
  } function bv(t) {
    t.__splitAreaColors = null;
  }mv.registerAxisPointerClass = function (t, e) {
    xv[t] = e;
  }, mv.getAxisPointerClass = function (t) {
    return t && xv[t];
  };const Sv = ['axisLine', 'axisTickLabel', 'axisName']; const Mv = ['splitArea', 'splitLine', 'minorSplitLine']; var Iv = mv.extend({ type: 'cartesianAxis', axisPointerClass: 'CartesianAxisPointer', render(e, t, i, n) {
    this.group.removeAll();const o = this._axisGroup;if (this._axisGroup = new Ci, this.group.add(this._axisGroup), e.get('show')) {
      const a = e.getCoordSysModel(); const r = _v(a, e); const s = new Qm(e, r);R(Sv, s.add, s), this._axisGroup.add(s.getGroup()), R(Mv, function (t) {
        e.get(`${t}.show`) && this[`_${t}`](e, a);
      }, this), ml(o, this._axisGroup, e), Iv.superCall(this, 'render', e, t, i, n);
    }
  }, remove() {
    bv(this);
  }, _splitLine(t, e) {
    const i = t.axis;if (!i.scale.isBlank()) {
      const n = t.getModel('splitLine'); const o = n.getModel('lineStyle'); let a = o.get('color');a = L(a) ? a : [a];for (let r = e.coordinateSystem.getRect(), s = i.isHorizontal(), l = 0, u = i.getTicksCoords({ tickModel: n }), h = [], c = [], d = o.getLineStyle(), f = 0;f < u.length;f++) {
        const p = i.toGlobalCoord(u[f].coord);s ? (h[0] = p, h[1] = r.y, c[0] = p, c[1] = r.y + r.height) : (h[0] = r.x, h[1] = p, c[0] = r.x + r.width, c[1] = p);const g = l++ % a.length; const m = u[f].tickValue;this._axisGroup.add(new ls({ anid: null != m ? `line_${u[f].tickValue}` : null, subPixelOptimize: !0, shape: { x1: h[0], y1: h[1], x2: c[0], y2: c[1] }, style: D({ stroke: a[g] }, d), silent: !0 }));
      }
    }
  }, _minorSplitLine(t, e) {
    const i = t.axis; const n = t.getModel('minorSplitLine').getModel('lineStyle'); const o = e.coordinateSystem.getRect(); const a = i.isHorizontal(); const r = i.getMinorTicksCoords();if (r.length) for (let s = [], l = [], u = n.getLineStyle(), h = 0;h < r.length;h++) for (let c = 0;c < r[h].length;c++) {
      const d = i.toGlobalCoord(r[h][c].coord);a ? (s[0] = d, s[1] = o.y, l[0] = d, l[1] = o.y + o.height) : (s[0] = o.x, s[1] = d, l[0] = o.x + o.width, l[1] = d), this._axisGroup.add(new ls({ anid: `minor_line_${r[h][c].tickValue}`, subPixelOptimize: !0, shape: { x1: s[0], y1: s[1], x2: l[0], y2: l[1] }, style: u, silent: !0 }));
    }
  }, _splitArea(t, e) {
    wv(this, this._axisGroup, t, e);
  } });Iv.extend({ type: 'xAxis' }), Iv.extend({ type: 'yAxis' }), Af({ type: 'grid', render(t, e) {
    this.group.removeAll(), t.get('show') && this.group.add(new rs({ shape: t.coordinateSystem.getRect(), style: D({ fill: t.get('backgroundColor') }, t.getItemStyle()), silent: !0, z2: -1 }));
  } }), yf((t) => {
    t.xAxis && t.yAxis && !t.grid && (t.grid = {});
  }), Sf(Lm('line', 'circle', 'line')), bf(km('line')), xf(Ld.PROCESSOR.STATISTIC, { seriesType: 'line', modifyOutputEnd: !0, reset(t, e, i) {
    const n = t.getData(); const o = t.get('sampling'); const a = t.coordinateSystem;if ('cartesian2d' === a.type && o) {
      let r; const s = a.getBaseAxis(); const l = a.getOtherAxis(s); const u = s.getExtent(); const h = Math.abs(u[1] - u[0]); const c = Math.round(n.count() / h);1 < c && ('string' === typeof o ? r = Nm[o] : 'function' === typeof o && (r = o), r && t.setData(n.downSample(n.mapDimension(l.dim), 1 / c, r, Pm)));
    }
  } });const Tv = sc.extend({ type: 'series.__base_bar__', getInitialData(t, e) {
    return gp(this.getSource(), this, { useEncodeDefaulter: !0 });
  }, getMarkerPosition(t) {
    const e = this.coordinateSystem;if (e) {
      const i = e.dataToPoint(e.clampData(t)); const n = this.getData(); const o = n.getLayout('offset'); const a = n.getLayout('size');return i[e.getBaseAxis().isHorizontal() ? 0 : 1] += o + a / 2, i;
    } return [NaN, NaN];
  }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: 'cartesian2d', legendHoverLink: !0, barMinHeight: 0, barMinAngle: 0, large: !1, largeThreshold: 400, progressive: 3e3, progressiveChunkMode: 'mod', itemStyle: {}, emphasis: {} } });function Av(t, e, i, n, o, a) {
    el(t, e, i.getModel('label'), i.getModel('emphasis.label'), { labelFetcher: o, labelDataIndex: a, defaultText: Ug(o.getData(), a), isRectText: !0, autoColor: n }), Dv(t), Dv(e);
  } function Dv(t, e) {
    'outside' === t.textPosition && (t.textPosition = e);
  }Tv.extend({ type: 'series.bar', dependencies: ['grid', 'polar'], brushSelector: 'rect', getProgressive() {
    return !!this.get('large') && this.get('progressive');
  }, getProgressiveThreshold() {
    let t = this.get('progressiveThreshold'); const e = this.get('largeThreshold');return t < e && (t = e), t;
  }, defaultOption: { clip: !0, roundCap: !1, showBackground: !1, backgroundStyle: { color: 'rgba(180, 180, 180, 0.2)', borderColor: null, borderWidth: 0, borderType: 'solid', borderRadius: 0, shadowBlur: 0, shadowColor: null, shadowOffsetX: 0, shadowOffsetY: 0, opacity: 1 } } });const Cv = ha([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]); const Lv = { getBarItemStyle(t) {
    const e = Cv(this, t);if (this.getBorderLineDash) {
      const i = this.getBorderLineDash();i && (e.lineDash = i);
    } return e;
  } }; const kv = Cs({ type: 'sausage', shape: { cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, buildPath(t, e) {
    const i = e.cx; const n = e.cy; const o = Math.max(e.r0 || 0, 0); const a = Math.max(e.r, 0); const r = .5 * (a - o); const s = o + r; const l = e.startAngle; const u = e.endAngle; const h = e.clockwise; const c = Math.cos(l); const d = Math.sin(l); const f = Math.cos(u); const p = Math.sin(u);(h ? u - l < 2 * Math.PI : l - u < 2 * Math.PI) && (t.moveTo(c * o + i, d * o + n), t.arc(c * s + i, d * s + n, r, -Math.PI + l, l, !h)), t.arc(i, n, a, l, u, !h), t.moveTo(f * a + i, p * a + n), t.arc(f * s + i, p * s + n, r, u - 2 * Math.PI, u - Math.PI, !h), 0 !== o && (t.arc(i, n, o, u, l, h), t.moveTo(c * o + i, p * o + n)), t.closePath();
  } }); const Pv = ['itemStyle', 'barBorderWidth']; const Nv = [0, 0];P(Cl.prototype, Lv), Cf({ type: 'bar', render(t, e, i) {
    this._updateDrawMode(t);const n = t.get('coordinateSystem');return 'cartesian2d' !== n && 'polar' !== n || (this._isLargeDraw ? this._renderLarge(t, e, i) : this._renderNormal(t, e, i)), this.group;
  }, incrementalPrepareRender(t, e, i) {
    this._clear(), this._updateDrawMode(t);
  }, incrementalRender(t, e, i, n) {
    this._incrementalRenderLarge(t, e);
  }, _updateDrawMode(t) {
    const e = t.pipelineContext.large;(null == this._isLargeDraw || e ^ this._isLargeDraw) && (this._isLargeDraw = e, this._clear());
  }, _renderNormal(s, t, e) {
    let l; const u = this.group; const h = s.getData(); const c = this._data; const d = s.coordinateSystem; const i = d.getBaseAxis();'cartesian2d' === d.type ? l = i.isHorizontal() : 'polar' === d.type && (l = 'angle' === i.dim);const f = s.isAnimationEnabled() ? s : null; const p = s.get('clip', !0); const g = (function (t, e) {
      const i = t.getArea && t.getArea();if ('cartesian2d' === t.type) {
        const n = t.getBaseAxis();if ('category' !== n.type || !n.onBand) {
          const o = e.getLayout('bandWidth');n.isHorizontal() ? (i.x -= o, i.width += 2 * o) : (i.y -= o, i.height += 2 * o);
        }
      } return i;
    }(d, h));u.removeClipPath();function m(t) {
      const e = Gv[d.type](h, t); const i = (function (t, e, i) {
        return new('polar' === t.type ? qr : rs)({ shape: Xv(e, i, t), silent: !0, z2: 0 });
      }(d, l, e));return i.useStyle(x.getBarItemStyle()), 'cartesian2d' === d.type && i.setShape('r', _), w[t] = i;
    } const v = s.get('roundCap', !0); const y = s.get('showBackground', !0); var x = s.getModel('backgroundStyle'); var _ = x.get('barBorderRadius') || 0; var w = []; const b = this._backgroundEls || [];h.diff(c).add((t) => {
      const e = h.getItemModel(t); const i = Gv[d.type](h, t, e);if (y && m(t), h.hasValue(t)) {
        if (p) if (Ev[d.type](g, i)) return void u.remove(n);var n = zv[d.type](t, i, l, f, !1, v);h.setItemGraphicEl(t, n), u.add(n), Wv(n, h, t, e, i, s, l, 'polar' === d.type);
      }
    })
      .update((t, e) => {
        const i = h.getItemModel(t); const n = Gv[d.type](h, t, i);if (y) {
          let o;0 === b.length ? o = m(e) : ((o = b[e]).useStyle(x.getBarItemStyle()), 'cartesian2d' === d.type && o.setShape('r', _), w[t] = o);const a = Gv[d.type](h, t);cl(o, { shape: Xv(l, a, d) }, f, t);
        } let r = c.getItemGraphicEl(e);if (h.hasValue(t)) {
          if (p) if (Ev[d.type](g, n)) return void u.remove(r);r ? cl(r, { shape: n }, f, t) : r = zv[d.type](t, n, l, f, !0, v), h.setItemGraphicEl(t, r), u.add(r), Wv(r, h, t, i, n, s, l, 'polar' === d.type);
        } else u.remove(r);
      })
      .remove((t) => {
        const e = c.getItemGraphicEl(t);'cartesian2d' === d.type ? e && Bv(t, f, e) : e && Vv(t, f, e);
      })
      .execute();const n = this._backgroundGroup || (this._backgroundGroup = new Ci);n.removeAll();for (let o = 0;o < w.length;++o)n.add(w[o]);u.add(n), this._backgroundEls = w, this._data = h;
  }, _renderLarge(t, e, i) {
    this._clear(), Zv(t, this.group);const n = t.get('clip', !0) ? Sm(t.coordinateSystem, !1, t) : null;n ? this.group.setClipPath(n) : this.group.removeClipPath();
  }, _incrementalRenderLarge(t, e) {
    this._removeBackground(), Zv(e, this.group, !0);
  }, dispose: et, remove(t) {
    this._clear(t);
  }, _clear(e) {
    const t = this.group; const i = this._data;e && e.get('animation') && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl((t) => {
      'sector' === t.type ? Vv(t.dataIndex, e, t) : Bv(t.dataIndex, e, t);
    })) : t.removeAll(), this._data = null;
  }, _removeBackground() {
    this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
  } });const Ov = Math.max; const Rv = Math.min; var Ev = { cartesian2d(t, e) {
    const i = e.width < 0 ? -1 : 1; const n = e.height < 0 ? -1 : 1;i < 0 && (e.x += e.width, e.width = -e.width), n < 0 && (e.y += e.height, e.height = -e.height);const o = Ov(e.x, t.x); const a = Rv(e.x + e.width, t.x + t.width); const r = Ov(e.y, t.y); const s = Rv(e.y + e.height, t.y + t.height);e.x = o, e.y = r, e.width = a - o, e.height = s - r;const l = e.width < 0 || e.height < 0;return i < 0 && (e.x += e.width, e.width = -e.width), n < 0 && (e.y += e.height, e.height = -e.height), l;
  }, polar(t, e) {
    const i = e.r0 <= e.r ? 1 : -1;if (i < 0) {
      var n = e.r;e.r = e.r0, e.r0 = n;
    }n = Rv(e.r, t.r);const o = Ov(e.r0, t.r0); const a = (e.r = n) - (e.r0 = o) < 0;if (i < 0) {
      n = e.r;e.r = e.r0, e.r0 = n;
    } return a;
  } }; var zv = { cartesian2d(t, e, i, n, o) {
    const a = new rs({ shape: P({}, e), z2: 1 });if (a.name = 'item', n) {
      const r = i ? 'height' : 'width'; const s = {};a.shape[r] = 0, s[r] = e[r], bl[o ? 'updateProps' : 'initProps'](a, { shape: s }, n, t);
    } return a;
  }, polar(t, e, i, n, o, a) {
    const r = e.startAngle < e.endAngle; const s = new(!i && a ? kv : qr)({ shape: D({ clockwise: r }, e), z2: 1 });if (s.name = 'item', n) {
      const l = i ? 'r' : 'endAngle'; const u = {};s.shape[l] = i ? 0 : e.startAngle, u[l] = e[l], bl[o ? 'updateProps' : 'initProps'](s, { shape: u }, n, t);
    } return s;
  } };function Bv(t, e, i) {
    i.style.text = null, cl(i, { shape: { width: 0 } }, e, t, () => {
      i.parent && i.parent.remove(i);
    });
  } function Vv(t, e, i) {
    i.style.text = null, cl(i, { shape: { r: i.shape.r0 } }, e, t, () => {
      i.parent && i.parent.remove(i);
    });
  } var Gv = { cartesian2d(t, e, i) {
    const n = t.getItemLayout(e); const o = i ? (function (t, e) {
      const i = t.get(Pv) || 0; const n = isNaN(e.width) ? Number.MAX_VALUE : Math.abs(e.width); const o = isNaN(e.height) ? Number.MAX_VALUE : Math.abs(e.height);return Math.min(i, n, o);
    }(i, n)) : 0; const a = 0 < n.width ? 1 : -1; const r = 0 < n.height ? 1 : -1;return { x: n.x + a * o / 2, y: n.y + r * o / 2, width: n.width - a * o, height: n.height - r * o };
  }, polar(t, e, i) {
    const n = t.getItemLayout(e);return { cx: n.cx, cy: n.cy, r0: n.r0, r: n.r, startAngle: n.startAngle, endAngle: n.endAngle };
  } };function Fv(t) {
    return null != t.startAngle && null != t.endAngle && t.startAngle === t.endAngle;
  } function Wv(t, e, i, n, o, a, r, s) {
    const l = e.getItemVisual(i, 'color'); const u = e.getItemVisual(i, 'opacity'); const h = e.getVisual('borderColor'); const c = n.getModel('itemStyle'); const d = n.getModel('emphasis.itemStyle').getBarItemStyle();s || t.setShape('r', c.get('barBorderRadius') || 0), t.useStyle(D({ stroke: Fv(o) ? 'none' : h, fill: Fv(o) ? 'none' : l, opacity: u }, c.getBarItemStyle()));const f = n.getShallow('cursor');f && t.attr('cursor', f);r ? o.height : o.width;s || Av(t.style, d, n, l, a, i), Fv(o) && (d.fill = d.stroke = 'none'), $s(t, d);
  } const Hv = Ar.extend({ type: 'largeBar', shape: { points: [] }, buildPath(t, e) {
    for (let i = e.points, n = this.__startPoint, o = this.__baseDimIdx, a = 0;a < i.length;a += 2)n[o] = i[a + o], t.moveTo(n[0], n[1]), t.lineTo(i[a], i[a + 1]);
  } });function Zv(t, e, i) {
    const n = t.getData(); const o = []; const a = n.getLayout('valueAxisHorizontal') ? 1 : 0;o[1 - a] = n.getLayout('valueAxisStart');const r = n.getLayout('largeDataIndices'); const s = n.getLayout('barWidth'); const l = t.getModel('backgroundStyle');if (t.get('showBackground', !0)) {
      const u = n.getLayout('largeBackgroundPoints'); const h = [];h[1 - a] = n.getLayout('backgroundStart');const c = new Hv({ shape: { points: u }, incremental: !!i, __startPoint: h, __baseDimIdx: a, __largeDataIndices: r, __barWidth: s, silent: !0, z2: 0 });!(function (t, e, i) {
        const n = e.get('borderColor') || e.get('color'); const o = e.getItemStyle(['color', 'borderColor']);t.useStyle(o), t.style.fill = null, t.style.stroke = n, t.style.lineWidth = i.getLayout('barWidth');
      }(c, l, n)), e.add(c);
    } const d = new Hv({ shape: { points: n.getLayout('largePoints') }, incremental: !!i, __startPoint: o, __baseDimIdx: a, __largeDataIndices: r, __barWidth: s });e.add(d), (function (t, e, i) {
      const n = i.getVisual('borderColor') || i.getVisual('color'); const o = e.getModel('itemStyle').getItemStyle(['color', 'borderColor']);t.useStyle(o), t.style.fill = null, t.style.stroke = n, t.style.lineWidth = i.getLayout('barWidth');
    }(d, t, n)), d.seriesIndex = t.seriesIndex, t.get('silent') || (d.on('mousedown', Uv), d.on('mousemove', Uv));
  } var Uv = Lc(function (t) {
    const e = (function (t, e, i) {
      const n = t.__baseDimIdx; const o = 1 - n; const a = t.shape.points; const r = t.__largeDataIndices; const s = Math.abs(t.__barWidth / 2); const l = t.__startPoint[o];Nv[0] = e, Nv[1] = i;for (let u = Nv[n], h = Nv[1 - n], c = u - s, d = u + s, f = 0, p = a.length / 2;f < p;f++) {
        const g = 2 * f; const m = a[g + n]; const v = a[g + o];if (c <= m && m <= d && (l <= v ? l <= h && h <= v : v <= h && h <= l)) return r[f];
      } return -1;
    }(this, t.offsetX, t.offsetY));this.dataIndex = 0 <= e ? e : null;
  }, 30, !1);function Xv(t, e, i) {
    let n; const o = 'polar' === i.type;return n = o ? i.getArea() : i.grid.getRect(), o ? { cx: n.cx, cy: n.cy, r0: t ? n.r0 : e.r0, r: t ? n.r : e.r, startAngle: t ? e.startAngle : 0, endAngle: t ? e.endAngle : 2 * Math.PI } : { x: t ? e.x : n.x, y: t ? n.y : e.y, width: t ? e.width : n.width, height: t ? n.height : e.height };
  }bf(Ld.VISUAL.LAYOUT, T(zp, 'bar')), bf(Ld.VISUAL.PROGRESSIVE_LAYOUT, Bp), Sf({ seriesType: 'bar', reset(t) {
    t.getData().setVisual('legendSymbol', 'roundRect');
  } });function Yv(t, e, i) {
    e = L(e) && { coordDimensions: e } || P({}, e);const n = t.getSource(); const o = lp(n, e); const a = new Yf(o, t);return a.initData(n, i), a;
  } const jv = { updateSelectedMap(t) {
    this._targetList = L(t) ? t.slice() : [], this._selectTargetMap = S(t || [], (t, e) => (t.set(e.name, e), t), Q());
  }, select(t, e) {
    const i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);'single' === this.get('selectedMode') && this._selectTargetMap.each((t) => {
      t.selected = !1;
    }), i && (i.selected = !0);
  }, unSelect(t, e) {
    const i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);i && (i.selected = !1);
  }, toggleSelected(t, e) {
    const i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);if (null != i) return this[i.selected ? 'unSelect' : 'select'](t, e), i.selected;
  }, isSelected(t, e) {
    const i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);return i && i.selected;
  } };function qv(i, e) {
    this.getAllNames = function () {
      const t = e();return t.mapArray(t.getName);
    }, this.containName = function (t) {
      return 0 <= e().indexOfName(t);
    }, this.indexOfName = function (t) {
      return i().indexOfName(t);
    }, this.getItemVisual = function (t, e) {
      return i().getItemVisual(t, e);
    };
  } var Kv = Df({ type: 'series.pie', init(t) {
    Kv.superApply(this, 'init', arguments), this.legendVisualProvider = new qv(A(this.getData, this), A(this.getRawData, this)), this.updateSelectedMap(this._createSelectableList()), this._defaultLabelLine(t);
  }, mergeOption(t) {
    Kv.superCall(this, 'mergeOption', t), this.updateSelectedMap(this._createSelectableList());
  }, getInitialData(t, e) {
    return Yv(this, { coordDimensions: ['value'], encodeDefaulter: T(Ju, this) });
  }, _createSelectableList() {
    for (var t = this.getRawData(), e = t.mapDimension('value'), i = [], n = 0, o = t.count();n < o;n++)i.push({ name: t.getName(n), value: t.get(e, n), selected: Zh(t, n, 'selected') });return i;
  }, getDataParams(t) {
    const e = this.getData(); const i = Kv.superCall(this, 'getDataParams', t); const n = [];return e.each(e.mapDimension('value'), (t) => {
      n.push(t);
    }), i.percent = Wl(n, t, e.hostModel.get('percentPrecision')), i.$vars.push('percent'), i;
  }, _defaultLabelLine(t) {
    Go(t, 'labelLine', ['show']);const e = t.labelLine; const i = t.emphasis.labelLine;e.show = e.show && t.label.show, i.show = i.show && t.emphasis.label.show;
  }, defaultOption: { zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, center: ['50%', '50%'], radius: [0, '75%'], clockwise: !0, startAngle: 90, minAngle: 0, minShowLabelAngle: 0, selectedOffset: 10, hoverOffset: 10, avoidLabelOverlap: !0, percentPrecision: 2, stillShowZeroSum: !0, left: 0, top: 0, right: 0, bottom: 0, width: null, height: null, label: { rotate: !1, show: !0, position: 'outer', alignTo: 'none', margin: '25%', bleedMargin: 10, distanceToLabelLine: 5 }, labelLine: { show: !0, length: 15, length2: 15, smooth: !1, lineStyle: { width: 1, type: 'solid' } }, itemStyle: { borderWidth: 1 }, animationType: 'expansion', animationTypeUpdate: 'transition', animationEasing: 'cubicOut' } });function $v(t, e, i, n) {
    const o = e.getData(); const a = this.dataIndex; const r = o.getName(a); const s = e.get('selectedOffset');n.dispatchAction({ type: 'pieToggleSelect', from: t, name: r, seriesId: e.id }), o.each((t) => {
      Jv(o.getItemGraphicEl(t), o.getItemLayout(t), e.isSelected(o.getName(t)), s, i);
    });
  } function Jv(t, e, i, n, o) {
    const a = (e.startAngle + e.endAngle) / 2; const r = i ? n : 0; const s = [Math.cos(a) * r, Math.sin(a) * r];o ? t.animate().when(200, { position: s })
      .start('bounceOut') : t.attr('position', s);
  } function Qv(t, e) {
    Ci.call(this);const i = new qr({ z2: 2 }); const n = new ts; const o = new Ur;this.add(i), this.add(n), this.add(o), this.updateData(t, e, !0);
  }b(Kv, jv);const ty = Qv.prototype;ty.updateData = function (t, e, i) {
    const n = this.childAt(0); const o = this.childAt(1); const a = this.childAt(2); const r = t.hostModel; const s = t.getItemModel(e); const l = t.getItemLayout(e); const u = P({}, l);u.label = null;const h = r.getShallow('animationTypeUpdate');i ? (n.setShape(u), 'scale' === r.getShallow('animationType') ? (n.shape.r = l.r0, dl(n, { shape: { r: l.r } }, r, e)) : (n.shape.endAngle = l.startAngle, cl(n, { shape: { endAngle: l.endAngle } }, r, e))) : 'expansion' === h ? n.setShape(u) : cl(n, { shape: u }, r, e);const c = t.getItemVisual(e, 'color');n.useStyle(D({ lineJoin: 'bevel', fill: c }, s.getModel('itemStyle').getItemStyle())), n.hoverStyle = s.getModel('emphasis.itemStyle').getItemStyle();const d = s.getShallow('cursor');d && n.attr('cursor', d), Jv(this, t.getItemLayout(e), r.isSelected(t.getName(e)), r.get('selectedOffset'), r.get('animation'));const f = !i && 'transition' === h;this._updateLabel(t, e, f), this.highDownOnUpdate = r.get('silent') ? null : function (t, e) {
      const i = r.isAnimationEnabled() && s.get('hoverAnimation');'emphasis' === e ? (o.ignore = o.hoverIgnore, a.ignore = a.hoverIgnore, i && (n.stopAnimation(!0), n.animateTo({ shape: { r: l.r + r.get('hoverOffset') } }, 300, 'elasticOut'))) : (o.ignore = o.normalIgnore, a.ignore = a.normalIgnore, i && (n.stopAnimation(!0), n.animateTo({ shape: { r: l.r } }, 300, 'elasticOut')));
    }, $s(this);
  }, ty._updateLabel = function (t, e, i) {
    const n = this.childAt(1); const o = this.childAt(2); const a = t.hostModel; const r = t.getItemModel(e); const s = t.getItemLayout(e).label; let l = t.getItemVisual(e, 'color');if (!s || isNaN(s.x) || isNaN(s.y))o.ignore = o.normalIgnore = o.hoverIgnore = n.ignore = n.normalIgnore = n.hoverIgnore = !0;else {
      const u = { points: s.linePoints || [[s.x, s.y], [s.x, s.y], [s.x, s.y]] }; const h = { x: s.x, y: s.y };i ? (cl(n, { shape: u }, a, e), cl(o, { style: h }, a, e)) : (n.attr({ shape: u }), o.attr({ style: h })), o.attr({ rotation: s.rotation, origin: [s.x, s.y], z2: 10 });const c = r.getModel('label'); const d = r.getModel('emphasis.label'); const f = r.getModel('labelLine'); const p = r.getModel('emphasis.labelLine');l = t.getItemVisual(e, 'color');el(o.style, o.hoverStyle = {}, c, d, { labelFetcher: t.hostModel, labelDataIndex: e, defaultText: s.text, autoColor: l, useInsideStyle: !!s.inside }, { textAlign: s.textAlign, textVerticalAlign: s.verticalAlign, opacity: t.getItemVisual(e, 'opacity') }), o.ignore = o.normalIgnore = !c.get('show'), o.hoverIgnore = !d.get('show'), n.ignore = n.normalIgnore = !f.get('show'), n.hoverIgnore = !p.get('show'), n.setStyle({ stroke: l, opacity: t.getItemVisual(e, 'opacity') }), n.setStyle(f.getModel('lineStyle').getLineStyle()), n.hoverStyle = p.getModel('lineStyle').getLineStyle();let g = f.get('smooth');g && !0 === g && (g = .4), n.setShape({ smooth: g });
    }
  }, w(Qv, Ci);function ey(i, t) {
    R(t, (a) => {
      a.update = 'updateView', _f(a, (t, e) => {
        const o = {};return e.eachComponent({ mainType: 'series', subType: i, query: t }, (i) => {
          i[a.method] && i[a.method](t.name, t.dataIndex);const n = i.getData();n.each((t) => {
            const e = n.getName(t);o[e] = i.isSelected(e) || !1;
          });
        }), { name: t.name, selected: o, seriesId: t.seriesId };
      });
    });
  } function iy(n) {
    return { getTargetSeries(t) {
      const e = {}; const i = Q();return t.eachSeriesByType(n, (t) => {
        t.__paletteScope = e, i.set(t.uid, t);
      }), i;
    }, reset(s, t) {
      const l = s.getRawData(); const u = {}; const h = s.getData();h.each((t) => {
        const e = h.getRawIndex(t);u[e] = t;
      }), l.each((t) => {
        let e; const i = u[t]; const n = null != i && h.getItemVisual(i, 'color', !0); const o = null != i && h.getItemVisual(i, 'borderColor', !0);if (n && o || (e = l.getItemModel(t)), !n) {
          const a = e.get('itemStyle.color') || s.getColorFromPalette(l.getName(t) || `${t}`, s.__paletteScope, l.count());null != i && h.setItemVisual(i, 'color', a);
        } if (!o) {
          const r = e.get('itemStyle.borderColor');null != i && h.setItemVisual(i, 'borderColor', r);
        }
      });
    } };
  }_c.extend({ type: 'pie', init() {
    const t = new Ci;this._sectorGroup = t;
  }, render(t, e, i, n) {
    if (!n || n.from !== this.uid) {
      const o = t.getData(); const a = this._data; const r = this.group; const s = e.get('animation'); const l = !a; const u = t.get('animationType'); const h = t.get('animationTypeUpdate'); const c = T($v, this.uid, t, s, i); const d = t.get('selectedMode');if (o.diff(a).add((t) => {
        const e = new Qv(o, t);l && 'scale' !== u && e.eachChild((t) => {
          t.stopAnimation(!0);
        }), d && e.on('click', c), o.setItemGraphicEl(t, e), r.add(e);
      })
        .update((t, e) => {
          const i = a.getItemGraphicEl(e);l || 'transition' === h || i.eachChild((t) => {
            t.stopAnimation(!0);
          }), i.updateData(o, t), i.off('click'), d && i.on('click', c), r.add(i), o.setItemGraphicEl(t, i);
        })
        .remove((t) => {
          const e = a.getItemGraphicEl(t);r.remove(e);
        })
        .execute(), s && 0 < o.count() && (l ? 'scale' !== u : 'transition' !== h)) {
        for (var f = o.getItemLayout(0), p = 1;isNaN(f.startAngle) && p < o.count();++p)f = o.getItemLayout(p);const g = Math.max(i.getWidth(), i.getHeight()) / 2; const m = A(r.removeClipPath, r);r.setClipPath(this._createClipPath(f.cx, f.cy, g, f.startAngle, f.clockwise, m, t, l));
      } else r.removeClipPath();this._data = o;
    }
  }, dispose() {}, _createClipPath(t, e, i, n, o, a, r, s) {
    const l = new qr({ shape: { cx: t, cy: e, r0: 0, r: i, startAngle: n, endAngle: n, clockwise: o } });return (s ? dl : cl)(l, { shape: { endAngle: n + (o ? 1 : -1) * Math.PI * 2 } }, r, a), l;
  }, containPoint(t, e) {
    const i = e.getData().getItemLayout(0);if (i) {
      const n = t[0] - i.cx; const o = t[1] - i.cy; const a = Math.sqrt(n * n + o * o);return a <= i.r && a >= i.r0;
    }
  } });const ny = Math.PI / 180;function oy(o, t, e, i, n, a, r, s, l, u) {
    function h(t, e, i) {
      for (let n = t;n < e && !(o[n].y + i > l + r);n++) if (o[n].y += i, t < n && n + 1 < e && o[n + 1].y > o[n].y + o[n].height) return void c(n, i / 2);c(e - 1, i / 2);
    } function c(t, e) {
      for (let i = t;0 <= i && !(o[i].y - e < l) && (o[i].y -= e, !(0 < i && o[i].y > o[i - 1].y + o[i - 1].height));i--);
    } function d(t, e, i, n, o, a) {
      for (let r = e ? Number.MAX_VALUE : 0, s = 0, l = t.length;s < l;s++) if ('none' === t[s].labelAlignTo) {
        const u = Math.abs(t[s].y - n); const h = t[s].len; const c = t[s].len2; let d = u < o + h ? Math.sqrt((o + h + c) * (o + h + c) - u * u) : Math.abs(t[s].x - i);e && r <= d && (d = r - 10), !e && d <= r && (d = r + 10), t[s].x = i + d * a, r = d;
      }
    }o.sort((t, e) => t.y - e.y);for (var f, p = 0, g = o.length, m = [], v = [], y = 0;y < g;y++) {
      if ('outer' === o[y].position && 'labelLine' === o[y].labelAlignTo) {
        const x = o[y].x - u;o[y].linePoints[1][0] += x, o[y].x = u;
      }(f = o[y].y - p) < 0 && h(y, g, -f), p = o[y].y + o[y].height;
    }r - p < 0 && c(g - 1, p - r);for (y = 0;y < g;y++)o[y].y >= e ? v.push(o[y]) : m.push(o[y]);d(m, !1, t, e, i, n), d(v, !0, t, e, i, n);
  } function ay(t) {
    return 'center' === t.position;
  } function ry(L, k, P, t, N, e) {
    let O; let R; const E = L.getData(); const z = []; let B = !1; const V = (L.get('minShowLabelAngle') || 0) * ny;E.each((t) => {
      const e = E.getItemLayout(t); const i = E.getItemModel(t); const n = i.getModel('label'); const o = n.get('position') || i.get('emphasis.label.position'); const a = n.get('distanceToLabelLine'); const r = n.get('alignTo'); const s = El(n.get('margin'), P); const l = n.get('bleedMargin'); const u = n.getFont(); const h = i.getModel('labelLine'); let c = h.get('length');c = El(c, P);let d = h.get('length2');if (d = El(d, P), !(e.angle < V)) {
        let f; let p; let g; let m; const v = (e.startAngle + e.endAngle) / 2; const y = Math.cos(v); const x = Math.sin(v);O = e.cx, R = e.cy;let _; const w = L.getFormattedLabel(t, 'normal') || E.getName(t); const b = gn(w, u, m, 'top'); const S = 'inside' === o || 'inner' === o;if ('center' === o)f = e.cx, p = e.cy, m = 'center';else {
          const M = (S ? (e.r + e.r0) / 2 * y : e.r * y) + O; const I = (S ? (e.r + e.r0) / 2 * x : e.r * x) + R;if (f = M + 3 * y, p = I + 3 * x, !S) {
            const T = M + y * (c + k - e.r); const A = I + x * (c + k - e.r); const D = T + (y < 0 ? -1 : 1) * d;f = 'edge' === r ? y < 0 ? N + s : N + P - s : D + (y < 0 ? -a : a), g = [[M, I], [T, A], [D, p = A]];
          }m = S ? 'center' : 'edge' === r ? 0 < y ? 'right' : 'left' : 0 < y ? 'left' : 'right';
        } const C = n.get('rotate');_ = 'number' === typeof C ? C * (Math.PI / 180) : C ? y < 0 ? -v + Math.PI : -v : 0, B = !!_, e.label = { x: f, y: p, position: o, height: b.height, len: c, len2: d, linePoints: g, textAlign: m, verticalAlign: 'middle', rotation: _, inside: S, labelDistance: a, labelAlignTo: r, labelMargin: s, bleedMargin: l, textRect: b, text: w, font: u }, S || z.push(e.label);
      }
    }), !B && L.get('avoidLabelOverlap') && (function (t, e, i, n, o, a, r, s) {
      for (var l = [], u = [], h = Number.MAX_VALUE, c = -Number.MAX_VALUE, d = 0;d < t.length;d++)ay(t[d]) || (t[d].x < e ? (h = Math.min(h, t[d].x), l.push(t[d])) : (c = Math.max(c, t[d].x), u.push(t[d])));for (oy(u, e, i, n, 1, 0, a, 0, s, c), oy(l, e, i, n, -1, 0, a, 0, s, h), d = 0;d < t.length;d++) {
        const f = t[d];if (!ay(f)) {
          const p = f.linePoints;if (p) {
            var g; const m = 'edge' === f.labelAlignTo; let v = f.textRect.width;(g = m ? f.x < e ? p[2][0] - f.labelDistance - r - f.labelMargin : r + o - f.labelMargin - p[2][0] - f.labelDistance : f.x < e ? f.x - r - f.bleedMargin : r + o - f.x - f.bleedMargin) < f.textRect.width && (f.text = xn(f.text, g, f.font), 'edge' === f.labelAlignTo && (v = pn(f.text, f.font)));const y = p[1][0] - p[2][0];m ? f.x < e ? p[2][0] = r + f.labelMargin + v + f.labelDistance : p[2][0] = r + o - f.labelMargin - v - f.labelDistance : (f.x < e ? p[2][0] = f.x + f.labelDistance : p[2][0] = f.x - f.labelDistance, p[1][0] = p[2][0] + y), p[1][1] = p[2][1] = f.y;
          }
        }
      }
    }(z, O, R, k, P, t, N, e));
  } const sy = 2 * Math.PI; const ly = Math.PI / 180;function uy(t) {
    return { seriesType: t, reset(t, e) {
      const n = e.findComponents({ mainType: 'legend' });if (n && n.length) {
        const o = t.getData();o.filterSelf((t) => {
          for (let e = o.getName(t), i = 0;i < n.length;i++) if (!n[i].isSelected(e)) return !1;return !0;
        });
      }
    } };
  }ey('pie', [{ type: 'pieToggleSelect', event: 'pieselectchanged', method: 'toggleSelected' }, { type: 'pieSelect', event: 'pieselected', method: 'select' }, { type: 'pieUnSelect', event: 'pieunselected', method: 'unSelect' }]), Sf(iy('pie')), bf(T((t, e, A, i) => {
    e.eachSeriesByType(t, (t) => {
      const o = t.getData(); const e = o.mapDimension('value'); const a = (function (t, e) {
        return bu(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() });
      }(t, A)); let i = t.get('center'); let n = t.get('radius');L(n) || (n = [0, n]), L(i) || (i = [i, i]);const r = El(a.width, A.getWidth()); const s = El(a.height, A.getHeight()); const l = Math.min(r, s); const u = El(i[0], r) + a.x; const h = El(i[1], s) + a.y; const c = El(n[0], l / 2); const d = El(n[1], l / 2); const f = -t.get('startAngle') * ly; const p = t.get('minAngle') * ly; let g = 0;o.each(e, (t) => {
        isNaN(t) || g++;
      });const m = o.getSum(e); let v = Math.PI / (m || g) * 2; const y = t.get('clockwise'); const x = t.get('roseType'); const _ = t.get('stillShowZeroSum'); const w = o.getDataExtent(e);w[0] = 0;let b = sy; let S = 0; let M = f; const I = y ? 1 : -1;if (o.each(e, (t, e) => {
        let i;if (isNaN(t))o.setItemLayout(e, { angle: NaN, startAngle: NaN, endAngle: NaN, clockwise: y, cx: u, cy: h, r0: c, r: x ? NaN : d, viewRect: a });else {
          (i = 'area' !== x ? 0 === m && _ ? v : t * v : sy / g) < p ? b -= i = p : S += t;const n = M + I * i;o.setItemLayout(e, { angle: i, startAngle: M, endAngle: n, clockwise: y, cx: u, cy: h, r0: c, r: x ? Rl(t, w, [c, d]) : d, viewRect: a }), M = n;
        }
      }), b < sy && g) if (b <= .001) {
        const T = sy / g;o.each(e, (t, e) => {
          if (!isNaN(t)) {
            const i = o.getItemLayout(e);i.angle = T, i.startAngle = f + I * e * T, i.endAngle = f + I * (e + 1) * T;
          }
        });
      } else v = b / S, M = f, o.each(e, (t, e) => {
        if (!isNaN(t)) {
          const i = o.getItemLayout(e); const n = i.angle === p ? p : t * v;i.startAngle = M, i.endAngle = M + I * n, M += I * n;
        }
      });ry(t, d, a.width, a.height, a.x, a.y);
    });
  }, 'pie')), xf(uy('pie')), sc.extend({ type: 'series.scatter', dependencies: ['grid', 'polar', 'geo', 'singleAxis', 'calendar'], getInitialData(t, e) {
    return gp(this.getSource(), this, { useEncodeDefaulter: !0 });
  }, brushSelector: 'point', getProgressive() {
    const t = this.option.progressive;return null == t ? this.option.large ? 5e3 : this.get('progressive') : t;
  }, getProgressiveThreshold() {
    const t = this.option.progressiveThreshold;return null == t ? this.option.large ? 1e4 : this.get('progressiveThreshold') : t;
  }, defaultOption: { coordinateSystem: 'cartesian2d', zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, symbolSize: 10, large: !1, largeThreshold: 2e3, itemStyle: { opacity: .8 }, clip: !0 } });const hy = Cs({ shape: { points: null }, symbolProxy: null, softClipShape: null, buildPath(t, e) {
    const i = e.points; const n = e.size; const o = this.symbolProxy; const a = o.shape;if (!((t.getContext ? t.getContext() : t) && n[0] < 4)) for (let r = 0;r < i.length;) {
      const s = i[r++]; const l = i[r++];isNaN(s) || isNaN(l) || this.softClipShape && !this.softClipShape.contain(s, l) || (a.x = s - n[0] / 2, a.y = l - n[1] / 2, a.width = n[0], a.height = n[1], o.buildPath(t, a, !0));
    }
  }, afterBrush(t) {
    const e = this.shape; const i = e.points; const n = e.size;if (n[0] < 4) {
      this.setTransform(t);for (let o = 0;o < i.length;) {
        const a = i[o++]; const r = i[o++];isNaN(a) || isNaN(r) || this.softClipShape && !this.softClipShape.contain(a, r) || t.fillRect(a - n[0] / 2, r - n[1] / 2, n[0], n[1]);
      } this.restoreTransform(t);
    }
  }, findDataIndex(t, e) {
    for (let i = this.shape, n = i.points, o = i.size, a = Math.max(o[0], 4), r = Math.max(o[1], 4), s = n.length / 2 - 1;0 <= s;s--) {
      const l = 2 * s; const u = n[l] - a / 2; const h = n[1 + l] - r / 2;if (u <= t && h <= e && t <= u + a && e <= h + r) return s;
    } return -1;
  } });function cy() {
    this.group = new Ci;
  } const dy = cy.prototype;function fy(t, e, i) {
    Gg.call(this, t, e, i), this.type = 'value', this.angle = 0, this.name = '', this.model;
  } function py(t, e, i) {
    this._model = t, this.dimensions = [], this._indicatorAxes = O(t.getIndicatorModels(), function (t, e) {
      const i = `indicator_${e}`; const n = new fy(i, 'log' === t.get('axisType') ? new ng : new Dp);return n.name = t.get('name'), (n.model = t).axis = n, this.dimensions.push(i), n;
    }, this), this.resize(t, i), this.cx, this.cy, this.r, this.r0, this.startAngle;
  }dy.isPersistent = function () {
    return !this._incremental;
  }, dy.updateData = function (t, e) {
    this.group.removeAll();const i = new hy({ rectHover: !0, cursor: 'default' });i.setShape({ points: t.getLayout('symbolPoints') }), this._setCommon(i, t, !1, e), this.group.add(i), this._incremental = null;
  }, dy.updateLayout = function (t) {
    if (!this._incremental) {
      let n = t.getLayout('symbolPoints');this.group.eachChild((t) => {
        if (null != t.startIndex) {
          const e = 2 * (t.endIndex - t.startIndex); const i = 4 * t.startIndex * 2;n = new Float32Array(n.buffer, i, e);
        }t.setShape('points', n);
      });
    }
  }, dy.incrementalPrepareUpdate = function (t) {
    this.group.removeAll(), this._clearIncremental(), 2e6 < t.count() ? (this._incremental || (this._incremental = new vs({ silent: !0 })), this.group.add(this._incremental)) : this._incremental = null;
  }, dy.incrementalUpdate = function (t, e, i) {
    let n;this._incremental ? (n = new hy, this._incremental.addDisplayable(n, !0)) : ((n = new hy({ rectHover: !0, cursor: 'default', startIndex: t.start, endIndex: t.end })).incremental = !0, this.group.add(n)), n.setShape({ points: e.getLayout('symbolPoints') }), this._setCommon(n, e, !!this._incremental, i);
  }, dy._setCommon = function (i, t, e, n) {
    const o = t.hostModel;n = n || {};const a = t.getVisual('symbolSize');i.setShape('size', a instanceof Array ? a : [a, a]), i.softClipShape = n.clipShape || null, i.symbolProxy = wg(t.getVisual('symbol'), 0, 0, 0, 0), i.setColor = i.symbolProxy.setColor;const r = i.shape.size[0] < 4;i.useStyle(o.getModel('itemStyle').getItemStyle(r ? ['color', 'shadowBlur', 'shadowColor'] : ['color']));const s = t.getVisual('color');s && i.setColor(s), e || (i.seriesIndex = o.seriesIndex, i.on('mousemove', (t) => {
      i.dataIndex = null;const e = i.findDataIndex(t.offsetX, t.offsetY);0 <= e && (i.dataIndex = e + (i.startIndex || 0));
    }));
  }, dy.remove = function () {
    this._clearIncremental(), this._incremental = null, this.group.removeAll();
  }, dy._clearIncremental = function () {
    const t = this._incremental;t && t.clearDisplaybles();
  }, Cf({ type: 'scatter', render(t, e, i) {
    const n = t.getData();this._updateSymbolDraw(n, t).updateData(n, { clipShape: this._getClipShape(t) }), this._finished = !0;
  }, incrementalPrepareRender(t, e, i) {
    const n = t.getData();this._updateSymbolDraw(n, t).incrementalPrepareUpdate(n), this._finished = !1;
  }, incrementalRender(t, e, i) {
    this._symbolDraw.incrementalUpdate(t, e.getData(), { clipShape: this._getClipShape(e) }), this._finished = t.end === e.getData().count();
  }, updateTransform(t, e, i) {
    const n = t.getData();if (this.group.dirty(), !this._finished || 1e4 < n.count() || !this._symbolDraw.isPersistent()) return { update: !0 };const o = km().reset(t);o.progress && o.progress({ start: 0, end: n.count() }, n), this._symbolDraw.updateLayout(n);
  }, _getClipShape(t) {
    const e = t.coordinateSystem; const i = e && e.getArea && e.getArea();return t.get('clip', !0) ? i : null;
  }, _updateSymbolDraw(t, e) {
    let i = this._symbolDraw; const n = e.pipelineContext.large;return i && n === this._isLargeDraw || (i && i.remove(), i = this._symbolDraw = n ? new cy : new im, this._isLargeDraw = n, this.group.removeAll()), this.group.add(i.group), i;
  }, remove(t, e) {
    this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
  }, dispose() {} }), Sf(Lm('scatter', 'circle')), bf(km('scatter')), w(fy, Gg), py.prototype.getIndicatorAxes = function () {
    return this._indicatorAxes;
  }, py.prototype.dataToPoint = function (t, e) {
    const i = this._indicatorAxes[e];return this.coordToPoint(i.dataToCoord(t), e);
  }, py.prototype.coordToPoint = function (t, e) {
    const i = this._indicatorAxes[e].angle;return [this.cx + t * Math.cos(i), this.cy - t * Math.sin(i)];
  }, py.prototype.pointToData = function (t) {
    let e = t[0] - this.cx; let i = t[1] - this.cy; const n = Math.sqrt(e * e + i * i);e /= n, i /= n;for (var o, a = Math.atan2(-i, e), r = 1 / 0, s = -1, l = 0;l < this._indicatorAxes.length;l++) {
      const u = this._indicatorAxes[l]; const h = Math.abs(a - u.angle);h < r && (o = u, s = l, r = h);
    } return [s, +(o && o.coordToData(n))];
  }, py.prototype.resize = function (t, e) {
    const i = t.get('center'); const n = e.getWidth(); const o = e.getHeight(); const a = Math.min(n, o) / 2;this.cx = El(i[0], n), this.cy = El(i[1], o), this.startAngle = t.get('startAngle') * Math.PI / 180;let r = t.get('radius');'string' !== typeof r && 'number' !== typeof r || (r = [0, r]), this.r0 = El(r[0], a), this.r = El(r[1], a), R(this._indicatorAxes, function (t, e) {
      t.setExtent(this.r0, this.r);let i = this.startAngle + e * Math.PI * 2 / this._indicatorAxes.length;i = Math.atan2(Math.sin(i), Math.cos(i)), t.angle = i;
    }, this);
  }, py.prototype.update = function (n, t) {
    const o = this._indicatorAxes; const a = this._model;R(o, (t) => {
      t.scale.setExtent(1 / 0, -1 / 0);
    }), n.eachSeriesByType('radar', (t, e) => {
      if ('radar' === t.get('coordinateSystem') && n.getComponent('radar', t.get('radarIndex')) === a) {
        const i = t.getData();R(o, (t) => {
          t.scale.unionExtentFromData(i, i.mapDimension(t.dim));
        });
      }
    }, this);const c = a.get('splitNumber');function d(t) {
      const e = Math.pow(10, Math.floor(Math.log(t) / Math.LN10)); let i = t / e;return 2 === i ? i = 5 : i *= 2, i * e;
    }R(o, (t, e) => {
      const i = ag(t.scale, t.model).extent;rg(t.scale, t.model);const n = t.model; const o = t.scale; const a = n.getMin(); const r = n.getMax(); let s = o.getInterval();if (null != a && null != r)o.setExtent(+a, +r), o.setInterval((r - a) / c);else if (null != a) for (;u = a + s * c, o.setExtent(+a, u), o.setInterval(s), s = d(s), u < i[1] && isFinite(u) && isFinite(i[1]););else if (null != r) for (;h = r - s * c, o.setExtent(h, +r), o.setInterval(s), s = d(s), h > i[0] && isFinite(h) && isFinite(i[0]););else {
        const l = o.getTicks().length - 1;c < l && (s = d(s));var u; var h = zl((u = Math.ceil(i[1] / s) * s) - s * c);o.setExtent(h, u), o.setInterval(s);
      }
    });
  }, py.dimensions = [], py.create = function (i, n) {
    const o = [];return i.eachComponent('radar', (t) => {
      const e = new py(t, i, n);o.push(e), t.coordinateSystem = e;
    }), i.eachSeriesByType('radar', (t) => {
      'radar' === t.get('coordinateSystem') && (t.coordinateSystem = o[t.get('radarIndex') || 0]);
    }), o;
  }, lh.register('radar', py);const gy = Vm.valueAxis;function my(t, e) {
    return D({ show: e }, t);
  }Tf({ type: 'radar', optionUpdated() {
    const o = this.get('boundaryGap'); const a = this.get('splitNumber'); const r = this.get('scale'); const s = this.get('axisLine'); const l = this.get('axisTick'); const u = this.get('axisType'); const h = this.get('axisLabel'); const c = this.get('name'); const d = this.get('name.show'); const f = this.get('name.formatter'); const p = this.get('nameGap'); const g = this.get('triggerEvent'); const t = O(this.get('indicator') || [], function (t) {
      null != t.max && 0 < t.max && !t.min ? t.min = 0 : null != t.min && t.min < 0 && !t.max && (t.max = 0);let e = c;if (null != t.color && (e = D({ color: t.color }, c)), t = m(k(t), { boundaryGap: o, splitNumber: a, scale: r, axisLine: s, axisTick: l, axisType: u, axisLabel: h, name: t.text, nameLocation: 'end', nameGap: p, nameTextStyle: e, triggerEvent: g }, !1), d || (t.name = ''), 'string' === typeof f) {
        const i = t.name;t.name = f.replace('{value}', null != i ? i : '');
      } else 'function' === typeof f && (t.name = f(t.name, t));const n = P(new Cl(t, null, this.ecModel), dg);return n.mainType = 'radar', n.componentIndex = this.componentIndex, n;
    }, this);this.getIndicatorModels = function () {
      return t;
    };
  }, defaultOption: { zlevel: 0, z: 0, center: ['50%', '50%'], radius: '75%', startAngle: 90, name: { show: !0 }, boundaryGap: [0, 0], splitNumber: 5, nameGap: 15, scale: !1, shape: 'polygon', axisLine: m({ lineStyle: { color: '#bbb' } }, gy.axisLine), axisLabel: my(gy.axisLabel, !1), axisTick: my(gy.axisTick, !1), axisType: 'interval', splitLine: my(gy.splitLine, !0), splitArea: my(gy.splitArea, !0), indicator: [] } });const vy = ['axisLine', 'axisTickLabel', 'axisName'];Af({ type: 'radar', render(t, e, i) {
    this.group.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t);
  }, _buildAxes(t) {
    const e = t.coordinateSystem;R(O(e.getIndicatorAxes(), t => new Qm(t.model, { position: [e.cx, e.cy], rotation: t.angle, labelDirection: -1, tickDirection: -1, nameDirection: 1 })), function (t) {
      R(vy, t.add, t), this.group.add(t.getGroup());
    }, this);
  }, _buildSplitLineAndArea(t) {
    const n = t.coordinateSystem; const e = n.getIndicatorAxes();if (e.length) {
      const i = t.get('shape'); const o = t.getModel('splitLine'); const a = t.getModel('splitArea'); const r = o.getModel('lineStyle'); const s = a.getModel('areaStyle'); const l = o.get('show'); const u = a.get('show'); let h = r.get('color'); let c = s.get('color');h = L(h) ? h : [h], c = L(c) ? c : [c];const d = []; const f = [];if ('circle' === i) for (var p = e[0].getTicksCoords(), g = n.cx, m = n.cy, v = 0;v < p.length;v++) {
        if (l)d[I(d, h, v)].push(new Yr({ shape: { cx: g, cy: m, r: p[v].coord } }));if (u && v < p.length - 1)f[I(f, c, v)].push(new Kr({ shape: { cx: g, cy: m, r0: p[v].coord, r: p[v + 1].coord } }));
      } else {
        let y; const x = O(e, (t, e) => {
          const i = t.getTicksCoords();return y = null == y ? i.length - 1 : Math.min(i.length - 1, y), O(i, t => n.coordToPoint(t.coord, e));
        }); let _ = [];for (v = 0;v <= y;v++) {
          for (var w = [], b = 0;b < e.length;b++)w.push(x[b][v]);if (w[0] && w.push(w[0].slice()), l)d[I(d, h, v)].push(new ts({ shape: { points: w } }));if (u && _)f[I(f, c, v - 1)].push(new Qr({ shape: { points: w.concat(_) } }));_ = w.slice().reverse();
        }
      } const S = r.getLineStyle(); const M = s.getAreaStyle();R(f, function (t, e) {
        this.group.add(Rs(t, { style: D({ stroke: 'none', fill: c[e % c.length] }, M), silent: !0 }));
      }, this), R(d, function (t, e) {
        this.group.add(Rs(t, { style: D({ fill: 'none', stroke: h[e % h.length] }, S), silent: !0 }));
      }, this);
    } function I(t, e, i) {
      const n = i % e.length;return t[n] = t[n] || [], n;
    }
  } });var yy = sc.extend({ type: 'series.radar', dependencies: ['radar'], init(t) {
    yy.superApply(this, 'init', arguments), this.legendVisualProvider = new qv(A(this.getData, this), A(this.getRawData, this));
  }, getInitialData(t, e) {
    return Yv(this, { generateCoord: 'indicator_', generateCoordCount: 1 / 0 });
  }, formatTooltip(n, t, e, i) {
    const o = this.getData(); const a = this.coordinateSystem.getIndicatorAxes(); const r = this.getData().getName(n); const s = 'html' === i ? '<br/>' : '\n';return au('' === r ? this.name : r) + s + O(a, (t, e) => {
      const i = o.get(o.mapDimension(t.dim), n);return au(`${t.name} : ${i}`);
    }).join(s);
  }, getTooltipPosition(t) {
    if (null != t) for (var e = this.getData(), i = this.coordinateSystem, n = e.getValues(O(i.dimensions, t => e.mapDimension(t)), t, !0), o = 0, a = n.length;o < a;o++) if (!isNaN(n[o])) {
      const r = i.getIndicatorAxes();return i.coordToPoint(r[o].dataToCoord(n[o]), o);
    }
  }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: 'radar', legendHoverLink: !0, radarIndex: 0, lineStyle: { width: 2, type: 'solid' }, label: { position: 'top' }, symbol: 'emptyCircle', symbolSize: 4 } });Cf({ type: 'radar', render(l, t, e) {
    const i = l.coordinateSystem; const g = this.group; const m = l.getData(); const s = this._data;function u(t, e) {
      const i = t.getItemVisual(e, 'symbol') || 'circle'; const n = t.getItemVisual(e, 'color');if ('none' !== i) {
        const o = (function (t) {
          return L(t) || (t = [+t, +t]), t;
        }(t.getItemVisual(e, 'symbolSize'))); const a = wg(i, -1, -1, 2, 2, n); const r = t.getItemVisual(e, 'symbolRotate') || 0;return a.attr({ style: { strokeNoScale: !0 }, z2: 100, scale: [o[0] / 2, o[1] / 2], rotation: r * Math.PI / 180 || 0 }), a;
      }
    } function h(t, e, i, n, o, a) {
      i.removeAll();for (let r = 0;r < e.length - 1;r++) {
        const s = u(n, o);s && (t[s.__dimIdx = r] ? (s.attr('position', t[r]), bl[a ? 'initProps' : 'updateProps'](s, { position: e[r] }, l, o)) : s.attr('position', e[r]), i.add(s));
      }
    } function c(t) {
      return O(t, t => [i.cx, i.cy]);
    }m.diff(s).add((t) => {
      const e = m.getItemLayout(t);if (e) {
        const i = new Qr; const n = new ts; const o = { shape: { points: e } };i.shape.points = c(e), n.shape.points = c(e), dl(i, o, l, t), dl(n, o, l, t);const a = new Ci; const r = new Ci;a.add(n), a.add(i), a.add(r), h(n.shape.points, e, r, m, t, !0), m.setItemGraphicEl(t, a);
      }
    })
      .update((t, e) => {
        const i = s.getItemGraphicEl(e); const n = i.childAt(0); const o = i.childAt(1); const a = i.childAt(2); const r = { shape: { points: m.getItemLayout(t) } };r.shape.points && (h(n.shape.points, r.shape.points, a, m, t, !1), cl(n, r, l), cl(o, r, l), m.setItemGraphicEl(t, i));
      })
      .remove((t) => {
        g.remove(s.getItemGraphicEl(t));
      })
      .execute(), m.eachItemGraphicEl((t, i) => {
      const e = m.getItemModel(i); const n = t.childAt(0); const o = t.childAt(1); const a = t.childAt(2); const r = m.getItemVisual(i, 'color');g.add(t), n.useStyle(D(e.getModel('lineStyle').getLineStyle(), { fill: 'none', stroke: r })), n.hoverStyle = e.getModel('emphasis.lineStyle').getLineStyle();const s = e.getModel('areaStyle'); const l = e.getModel('emphasis.areaStyle'); const u = s.isEmpty() && s.parentModel.isEmpty(); let h = l.isEmpty() && l.parentModel.isEmpty();h = h && u, o.ignore = u, o.useStyle(D(s.getAreaStyle(), { fill: r, opacity: .7 })), o.hoverStyle = l.getAreaStyle();const c = e.getModel('itemStyle').getItemStyle(['color']); const d = e.getModel('emphasis.itemStyle').getItemStyle(); const f = e.getModel('label'); const p = e.getModel('emphasis.label');a.eachChild((t) => {
        t.setStyle(c), t.hoverStyle = k(d);let e = m.get(m.dimensions[t.__dimIdx], i);null != e && !isNaN(e) || (e = ''), el(t.style, t.hoverStyle, f, p, { labelFetcher: m.hostModel, labelDataIndex: i, labelDimIndex: t.__dimIdx, defaultText: e, autoColor: r, isRectText: !0 });
      }), t.highDownOnUpdate = function (t, e) {
        o.attr('ignore', 'emphasis' === e ? h : u);
      }, $s(t);
    }), this._data = m;
  }, remove() {
    this.group.removeAll(), this._data = null;
  }, dispose() {} });function xy(t) {
    return !isNaN(t[0]) && !isNaN(t[1]);
  } function _y(t) {
    return [t.cx, t.cy];
  }Sf(iy('radar')), Sf(Lm('radar', 'circle')), bf((t) => {
    t.eachSeriesByType('radar', (t) => {
      const i = t.getData(); const o = []; const a = t.coordinateSystem;if (a) {
        const e = a.getIndicatorAxes();R(e, (t, n) => {
          i.each(i.mapDimension(e[n].dim), (t, e) => {
            o[e] = o[e] || [];const i = a.dataToPoint(t, n);o[e][n] = xy(i) ? i : _y(a);
          });
        }), i.each((t) => {
          const e = I(o[t], t => xy(t)) || _y(a);o[t].push(e.slice()), i.setItemLayout(t, o[t]);
        });
      }
    });
  }), xf(uy('radar')), yf((i) => {
    let t = i.polar;if (t) {
      L(t) || (t = [t]);const n = [];R(t, (t, e) => {
        t.indicator ? (t.type && !t.shape && (t.shape = t.type), i.radar = i.radar || [], L(i.radar) || (i.radar = [i.radar]), i.radar.push(t)) : n.push(t);
      }), i.polar = n;
    }R(i.series, (t) => {
      t && 'radar' === t.type && t.polarIndex && (t.radarIndex = t.polarIndex);
    });
  });for (var wy = [126, 25], by = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, .7], [52, .7], [56, 7.7], [59, .7], [64, .7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]], Sy = 0;Sy < by.length;Sy++) for (let My = 0;My < by[Sy].length;My++)by[Sy][My][0] /= 10.5, by[Sy][My][1] /= -14, by[Sy][My][0] += wy[0], by[Sy][My][1] += wy[1];const Iy = { 南海诸岛: [32, 80], 广东: [0, -10], 香港: [10, 5], 澳门: [-10, 10], 天津: [5, 5] }; const Ty = { Russia: [100, 60], 'United States': [-99, 38], 'United States of America': [-99, 38] }; const Ay = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]]; const Dy = jo(); const Cy = { load(n, t, e) {
    const i = Dy(t).parsed;if (i) return i;let o; const a = t.specialAreas || {}; const r = t.geoJSON;try {
      o = r ? Cg(r, e) : [];
    } catch (t) {
      throw new Error(`Invalid geoJson format\n${t.message}`);
    } return (function (t, e) {
      'china' === t && e.push(new Ag('南海诸岛', O(by, t => ({ type: 'polygon', exterior: t })), wy));
    }(n, o)), R(o, (t) => {
      const e = t.name;!(function (t, e) {
        if ('china' === t) {
          const i = Iy[e.name];if (i) {
            const n = e.center;n[0] += i[0] / 10.5, n[1] += -i[1] / 14;
          }
        }
      }(n, t)), (function (t, e) {
        if ('world' === t) {
          const i = Ty[e.name];if (i) {
            const n = e.center;n[0] = i[0], n[1] = i[1];
          }
        }
      }(n, t)), (function (t, e) {
        'china' === t && '台湾' === e.name && e.geometries.push({ type: 'polygon', exterior: Ay[0] });
      }(n, t));const i = a[e];i && t.transformTo(i.left, i.top, i.width, i.height);
    }), Dy(t).parsed = { regions: o, boundingRect: (function (t) {
      for (var e, i = 0;i < t.length;i++) {
        const n = t[i].getBoundingRect();(e = e || n.clone()).union(n);
      } return e;
    }(o)) };
  } };const Ly = jo();function ky(t, e) {
    let i; let n; const o = t.svgXML;try {
      Y(null != (n = (i = o && (function (t, e) {
        return (new hd).parse(t, e);
      }(o, { ignoreViewBox: !0, ignoreRootClip: !0 })) || {}).root));
    } catch (t) {
      throw new Error(`Invalid svg format\n${t.message}`);
    } const a = i.width; const r = i.height; const s = i.viewBoxRect;if (e || (e = null == a || null == r ? n.getBoundingRect() : new Di(0, 0, 0, 0), null != a && (e.width = a), null != r && (e.height = r)), s) {
      const l = wd(s, e.width, e.height); const u = n;(n = new Ci).add(u), u.scale = l.scale, u.position = l.position;
    } return n.setClipPath(new rs({ shape: e.plain() })), { root: n, boundingRect: e };
  } const Py = { geoJSON: Cy, svg: { load(t, e) {
    const i = Ly(e).originRoot;if (i) return { root: i, boundingRect: Ly(e).boundingRect };const n = ky(e);return Ly(e).originRoot = n.root, Ly(e).boundingRect = n.boundingRect, n;
  }, makeGraphic(t, e, i) {
    const n = Ly(e); const o = n.rootMap || (n.rootMap = Q()); let a = o.get(i);if (a) return a;const r = n.originRoot; const s = n.boundingRect;return a = n.originRootHostKey ? ky(e, s).root : (n.originRootHostKey = i, r), o.set(i, a);
  }, removeGraphic(t, e, i) {
    const n = Ly(e); const o = n.rootMap;o && o.removeKey(i), i === n.originRootHostKey && (n.originRootHostKey = null);
  } } }; const Ny = { load(n, o, a) {
    let r; const s = []; const l = Q(); const u = Q();return R(Ry(n), (t) => {
      const e = Py[t.type].load(n, t, a);R(e.regions, (t) => {
        let e = t.name;o && o.hasOwnProperty(e) && (t = t.cloneShallow(e = o[e])), s.push(t), l.set(e, t), u.set(e, t.center);
      });const i = e.boundingRect;i && (r ? r.union(i) : r = i.clone());
    }), { regions: s, regionsMap: l, nameCoordMap: u, boundingRect: r || new Di(0, 0, 0, 0) };
  }, makeGraphic: Oy('makeGraphic'), removeGraphic: Oy('removeGraphic') };function Oy(a) {
    return function (i, n) {
      const t = Ry(i); const o = [];return R(t, (t) => {
        const e = Py[t.type][a];e && o.push(e(i, t, n));
      }), o;
    };
  } function Ry(t) {
    return Sd.retrieveMap(t) || [];
  }b(sc.extend({ type: 'series.map', dependencies: ['geo'], layoutMode: 'box', needsDrawMap: !1, seriesGroup: [], getInitialData(t) {
    for (var e = Yv(this, { coordDimensions: ['value'], encodeDefaulter: T(Ju, this) }), i = e.mapDimension('value'), n = Q(), o = [], a = [], r = 0, s = e.count();r < s;r++) {
      const l = e.getName(r);n.set(l, !0), o.push({ name: l, value: e.get(i, r), selected: Zh(e, r, 'selected') });
    } return R(Ny.load(this.getMapType(), this.option.nameMap, this.option.nameProperty).regions, (t) => {
      const e = t.name;n.get(e) || (o.push({ name: e }), a.push(e));
    }), this.updateSelectedMap(o), e.appendValues([], a), e;
  }, getHostGeoModel() {
    const t = this.option.geoIndex;return null != t ? this.dependentModels.geo[t] : null;
  }, getMapType() {
    return (this.getHostGeoModel() || this).option.map;
  }, getRawValue(t) {
    const e = this.getData();return e.get(e.mapDimension('value'), t);
  }, getRegionModel(t) {
    const e = this.getData();return e.getItemModel(e.indexOfName(t));
  }, formatTooltip(t, e, i, n) {
    for (var o = this.getData(), a = tu(this.getRawValue(t)), r = o.getName(t), s = this.seriesGroup, l = [], u = 0;u < s.length;u++) {
      const h = s[u].originalData.indexOfName(r); const c = o.mapDimension('value');isNaN(s[u].originalData.get(c, h)) || l.push(au(s[u].name));
    } const d = 'html' === n ? '<br/>' : '\n';return l.join(', ') + d + au(`${r} : ${a}`);
  }, getTooltipPosition(t) {
    if (null != t) {
      const e = this.getData().getName(t); const i = this.coordinateSystem; const n = i.getRegion(e);return n && i.dataToPoint(n.center);
    }
  }, setZoom(t) {
    this.option.zoom = t;
  }, setCenter(t) {
    this.option.center = t;
  }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: 'geo', map: '', left: 'center', top: 'center', aspectScale: .75, showLegendSymbol: !0, dataRangeHoverLink: !0, boundingCoords: null, center: null, zoom: 1, scaleLimit: null, label: { show: !1, color: '#000' }, itemStyle: { borderWidth: .5, borderColor: '#444', areaColor: '#eee' }, emphasis: { label: { show: !0, color: 'rgb(100,0,0)' }, itemStyle: { areaColor: 'rgba(255,215,0,0.8)' } }, nameProperty: 'name' } }), jv);const Ey = '\0_ec_interaction_mutex';function zy(t, e) {
    return !!By(t)[e];
  } function By(t) {
    return t[Ey] || (t[Ey] = {});
  } function Vy(i) {
    this.pointerChecker, this._zr = i, this._opt = {};const t = A; const n = t(Gy, this); const o = t(Fy, this); const a = t(Wy, this); const r = t(Hy, this); const s = t(Zy, this);Ct.call(this), this.setPointerChecker = function (t) {
      this.pointerChecker = t;
    }, this.enable = function (t, e) {
      this.disable(), this._opt = D(k(e) || {}, { zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !1, preventDefaultMouseMove: !0 }), null == t && (t = !0), !0 !== t && 'move' !== t && 'pan' !== t || (i.on('mousedown', n), i.on('mousemove', o), i.on('mouseup', a)), !0 !== t && 'scale' !== t && 'zoom' !== t || (i.on('mousewheel', r), i.on('pinch', s));
    }, this.disable = function () {
      i.off('mousedown', n), i.off('mousemove', o), i.off('mouseup', a), i.off('mousewheel', r), i.off('pinch', s);
    }, this.dispose = this.disable, this.isDragging = function () {
      return this._dragging;
    }, this.isPinching = function () {
      return this._pinching;
    };
  } function Gy(t) {
    if (!(Yt(t) || t.target && t.target.draggable)) {
      const e = t.offsetX; const i = t.offsetY;this.pointerChecker && this.pointerChecker(t, e, i) && (this._x = e, this._y = i, this._dragging = !0);
    }
  } function Fy(t) {
    if (this._dragging && Yy('moveOnMouseMove', t, this._opt) && 'pinch' !== t.gestureEvent && !zy(this._zr, 'globalPan')) {
      const e = t.offsetX; const i = t.offsetY; const n = this._x; const o = this._y; const a = e - n; const r = i - o;this._x = e, this._y = i, this._opt.preventDefaultMouseMove && Xt(t.event), Xy(this, 'pan', 'moveOnMouseMove', t, { dx: a, dy: r, oldX: n, oldY: o, newX: e, newY: i });
    }
  } function Wy(t) {
    Yt(t) || (this._dragging = !1);
  } function Hy(t) {
    const e = Yy('zoomOnMouseWheel', t, this._opt); const i = Yy('moveOnMouseWheel', t, this._opt); const n = t.wheelDelta; const o = Math.abs(n); const a = t.offsetX; const r = t.offsetY;if (0 !== n && (e || i)) {
      if (e) {
        const s = 3 < o ? 1.4 : 1 < o ? 1.2 : 1.1;Uy(this, 'zoom', 'zoomOnMouseWheel', t, { scale: 0 < n ? s : 1 / s, originX: a, originY: r });
      } if (i) {
        const l = Math.abs(n);Uy(this, 'scrollMove', 'moveOnMouseWheel', t, { scrollDelta: (0 < n ? 1 : -1) * (3 < l ? .4 : 1 < l ? .15 : .05), originX: a, originY: r });
      }
    }
  } function Zy(t) {
    zy(this._zr, 'globalPan') || Uy(this, 'zoom', null, t, { scale: 1 < t.pinchScale ? 1.1 : 1 / 1.1, originX: t.pinchX, originY: t.pinchY });
  } function Uy(t, e, i, n, o) {
    t.pointerChecker && t.pointerChecker(n, o.originX, o.originY) && (Xt(n.event), Xy(t, e, i, n, o));
  } function Xy(t, e, i, n, o) {
    o.isAvailableBehavior = A(Yy, null, i, n), t.trigger(e, o);
  } function Yy(t, e, i) {
    const n = i[t];return !t || n && (!E(n) || e.event[`${n}Key`]);
  } function jy(t, e, i) {
    const n = t.target; const o = n.position;o[0] += e, o[1] += i, n.dirty();
  } function qy(t, e, i, n) {
    const o = t.target; const a = t.zoomLimit; const r = o.position; const s = o.scale; let l = t.zoom = t.zoom || 1;if (l *= e, a) {
      const u = a.min || 0; const h = a.max || 1 / 0;l = Math.max(Math.min(h, l), u);
    } const c = l / t.zoom;t.zoom = l, r[0] -= (i - r[0]) * (c - 1), r[1] -= (n - r[1]) * (c - 1), s[0] *= c, s[1] *= c, o.dirty();
  }_f({ type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update' }, () => {}), b(Vy, Ct);const Ky = { axisPointer: 1, tooltip: 1, brush: 1 };function $y(t, e, i) {
    const n = e.getComponentByElement(t.topTarget); const o = n && n.coordinateSystem;return n && n !== i && !Ky[n.mainType] && o && o.model !== i;
  } function Jy(t) {
    const e = t.getItemStyle(); const i = t.get('areaColor');return null != i && (e.fill = i), e;
  } function Qy(i, t) {
    t.eachChild((e) => {
      R(e.__regions, (t) => {
        e.trigger(i.isSelected(t.name) ? 'emphasis' : 'normal');
      });
    });
  } function tx(t, e) {
    const i = new Ci;this.uid = Nl('ec_map_draw'), this._controller = new Vy(t.getZr()), this._controllerHost = { target: e ? i : null }, this.group = i, this._updateGroup = e, this._mouseDownFlag, this._mapName, this._initialized, i.add(this._regionsGroup = new Ci), i.add(this._backgroundGroup = new Ci);
  }tx.prototype = { constructor: tx, draw(_, t, e, i, n) {
    const w = 'geo' === _.mainType; let b = _.getData && _.getData();w && t.eachComponent({ mainType: 'series', subType: 'map' }, (t) => {
      b || t.getHostGeoModel() !== _ || (b = t.getData());
    });const o = _.coordinateSystem;this._updateBackground(o);let S; const M = this._regionsGroup; const I = this.group; const a = o.getTransformInfo(); const T = !M.childAt(0) || n;if (T)I.transform = a.roamTransform, I.decomposeTransform(), I.dirty();else {
      const r = new ve;r.transform = a.roamTransform, r.decomposeTransform();const s = { scale: r.scale, position: r.position };S = r.scale, cl(I, s, _);
    } const A = a.rawScale; const D = a.rawPosition;M.removeAll();const C = ['itemStyle']; const L = ['emphasis', 'itemStyle']; const k = ['label']; const P = ['emphasis', 'label']; const N = Q();R(o.regions, (t) => {
      const e = N.get(t.name) || N.set(t.name, new Ci); const a = new ps({ segmentIgnoreThreshold: 1, shape: { paths: [] } });e.add(a);let i; const n = (x = _.getRegionModel(t.name) || _).getModel(C); const o = x.getModel(L); const r = Jy(n); const s = Jy(o); const l = x.getModel(k); const u = x.getModel(P);if (b) {
        i = b.indexOfName(t.name);const h = b.getItemVisual(i, 'color', !0);h && (r.fill = h);
      } function c(t) {
        return [t[0] * A[0] + D[0], t[1] * A[1] + D[1]];
      }R(t.geometries, (t) => {
        if ('polygon' === t.type) {
          for (var e = [], i = 0;i < t.exterior.length;++i)e.push(c(t.exterior[i]));a.shape.paths.push(new Qr({ segmentIgnoreThreshold: 1, shape: { points: e } }));for (i = 0;i < (t.interiors ? t.interiors.length : 0);++i) {
            for (let n = t.interiors[i], o = (e = [], 0);o < n.length;++o)e.push(c(n[o]));a.shape.paths.push(new Qr({ segmentIgnoreThreshold: 1, shape: { points: e } }));
          }
        }
      }), a.setStyle(r), a.style.strokeNoScale = !0, a.culling = !0;const d = l.get('show'); const f = u.get('show'); const p = b && isNaN(b.get(b.mapDimension('value'), i)); const g = b && b.getItemLayout(i);if (w || p && (d || f) || g && g.showLabel) {
        let m; const v = w ? t.name : i;(!b || 0 <= i) && (m = _);const y = new Ur({ position: c(t.center.slice()), scale: [1 / I.scale[0], 1 / I.scale[1]], z2: 10, silent: !0 });if (el(y.style, y.hoverStyle = {}, l, u, { labelFetcher: m, labelDataIndex: v, defaultText: t.name, useInsideStyle: !1 }, { textAlign: 'center', textVerticalAlign: 'middle' }), !T)cl(y, { scale: [1 / S[0], 1 / S[1]] }, _);e.add(y);
      } if (b)b.setItemGraphicEl(i, e);else {
        var x = _.getRegionModel(t.name);a.eventData = { componentType: 'geo', componentIndex: _.componentIndex, geoIndex: _.componentIndex, name: t.name, region: x && x.option || {} };
      }(e.__regions || (e.__regions = [])).push(t), e.highDownSilentOnTouch = !!_.get('selectedMode'), $s(e, s), M.add(e);
    }), this._updateController(_, t, e), (function (n, o, a, r, s) {
      a.off('click'), a.off('mousedown'), o.get('selectedMode') && (a.on('mousedown', () => {
        n._mouseDownFlag = !0;
      }), a.on('click', (t) => {
        if (n._mouseDownFlag) {
          n._mouseDownFlag = !1;for (var e = t.target;!e.__regions;)e = e.parent;if (e) {
            const i = { type: `${'geo' === o.mainType ? 'geo' : 'map'}ToggleSelect`, batch: O(e.__regions, t => ({ name: t.name, from: s.uid })) };i[`${o.mainType}Id`] = o.id, r.dispatchAction(i), Qy(o, a);
          }
        }
      }));
    }(this, _, M, e, i)), Qy(_, M);
  }, remove() {
    this._regionsGroup.removeAll(), this._backgroundGroup.removeAll(), this._controller.dispose(), this._mapName && Ny.removeGraphic(this._mapName, this.uid), this._mapName = null, this._controllerHost = {};
  }, _updateBackground(t) {
    const e = t.map;this._mapName !== e && R(Ny.makeGraphic(e, this.uid), function (t) {
      this._backgroundGroup.add(t);
    }, this), this._mapName = e;
  }, _updateController(n, t, o) {
    const a = n.coordinateSystem; const e = this._controller; const i = this._controllerHost;i.zoomLimit = n.get('scaleLimit'), i.zoom = a.getZoom(), e.enable(n.get('roam') || !1);const r = n.mainType;function s() {
      const t = { type: 'geoRoam', componentType: r };return t[`${r}Id`] = n.id, t;
    }e.off('pan').on('pan', function (t) {
      this._mouseDownFlag = !1, jy(i, t.dx, t.dy), o.dispatchAction(P(s(), { dx: t.dx, dy: t.dy }));
    }, this), e.off('zoom').on('zoom', function (t) {
      if (this._mouseDownFlag = !1, qy(i, t.scale, t.originX, t.originY), o.dispatchAction(P(s(), { zoom: t.scale, originX: t.originX, originY: t.originY })), this._updateGroup) {
        const e = this.group.scale;this._regionsGroup.traverse((t) => {
          'text' === t.type && t.attr('scale', [1 / e[0], 1 / e[1]]);
        });
      }
    }, this), e.setPointerChecker((t, e, i) => a.getViewRectAfterRoam().contain(e, i) && !$y(t, o, n));
  } };const ex = '__seriesMapHighDown'; const ix = '__seriesMapCallKey';function nx(t) {
    const e = this[ex];e && e.recordVersion === this[ix] && ox(e, t);
  } function ox(t, e) {
    const i = t.circle; const n = t.labelModel; const o = t.hoverLabelModel; const a = t.emphasisText; const r = t.normalText;e ? (i.style.extendFrom(nl({}, o, { text: o.get('show') ? a : null }, { isRectText: !0, useInsideStyle: !1 }, !0)), i.__mapOriginalZ2 = i.z2, i.z2 += bs) : (nl(i.style, n, { text: n.get('show') ? r : null, textPosition: n.getShallow('position') || 'bottom' }, { isRectText: !0, useInsideStyle: !1 }), i.dirty(!1), null != i.__mapOriginalZ2 && (i.z2 = i.__mapOriginalZ2, i.__mapOriginalZ2 = null));
  } function ax(t, e, i) {
    const n = t.getZoom(); let o = t.getCenter(); let a = e.zoom; const r = t.dataToPoint(o);if (null != e.dx && null != e.dy) {
      r[0] -= e.dx, r[1] -= e.dy;o = t.pointToData(r);t.setCenter(o);
    } if (null != a) {
      if (i) {
        const s = i.min || 0; const l = i.max || 1 / 0;a = Math.max(Math.min(n * a, l), s) / n;
      }t.scale[0] *= a, t.scale[1] *= a;const u = t.position; const h = (e.originX - u[0]) * (a - 1); const c = (e.originY - u[1]) * (a - 1);u[0] -= h, u[1] -= c, t.updateTransform();o = t.pointToData(r);t.setCenter(o), t.setZoom(a * n);
    } return { center: t.getCenter(), zoom: t.getZoom() };
  }Cf({ type: 'map', render(t, e, i, n) {
    if (!n || 'mapToggleSelect' !== n.type || n.from !== this.uid) {
      const o = this.group;if (o.removeAll(), !t.getHostGeoModel()) {
        if (n && 'geoRoam' === n.type && 'series' === n.componentType && n.seriesId === t.id)(a = this._mapDraw) && o.add(a.group);else if (t.needsDrawMap) {
          var a = this._mapDraw || new tx(i, !0);o.add(a.group), a.draw(t, e, i, this, n), this._mapDraw = a;
        } else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;t.get('showLegendSymbol') && e.getComponent('legend') && this._renderSymbols(t, e, i);
      }
    }
  }, remove() {
    this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
  }, dispose() {
    this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
  }, _renderSymbols(x, t, e) {
    const _ = x.originalData; const w = this.group;_.each(_.mapDimension('value'), (t, e) => {
      if (!isNaN(t)) {
        const i = _.getItemLayout(e);if (i && i.point) {
          const n = i.point; const o = i.offset; const a = new Yr({ style: { fill: x.getData().getVisual('color') }, shape: { cx: n[0] + 9 * o, cy: n[1], r: 3 }, silent: !0, z2: 8 + (o ? 0 : bs + 1) });if (!o) {
            const r = x.mainSeries.getData(); const s = _.getName(e); const l = r.indexOfName(s); const u = _.getItemModel(e); const h = u.getModel('label'); const c = u.getModel('emphasis.label'); const d = r.getItemGraphicEl(l); const f = H(x.getFormattedLabel(l, 'normal'), s); const p = H(x.getFormattedLabel(l, 'emphasis'), f); let g = d[ex]; const m = Math.random();if (!g) {
              g = d[ex] = {};const v = T(nx, !0); const y = T(nx, !1);d.on('mouseover', v).on('mouseout', y)
                .on('emphasis', v)
                .on('normal', y);
            }P(g, { recordVersion: d[ix] = m, circle: a, labelModel: h, hoverLabelModel: c, emphasisText: p, normalText: f }), ox(g, !1);
          }w.add(a);
        }
      }
    });
  } }), _f({ type: 'geoRoam', event: 'geoRoam', update: 'updateTransform' }, (n, t) => {
    const o = n.componentType || 'series';t.eachComponent({ mainType: o, query: n }, (t) => {
      const e = t.coordinateSystem;if ('geo' === e.type) {
        const i = ax(e, n, t.get('scaleLimit'));t.setCenter && t.setCenter(i.center), t.setZoom && t.setZoom(i.zoom), 'series' === o && R(t.seriesGroup, (t) => {
          t.setCenter(i.center), t.setZoom(i.zoom);
        });
      }
    });
  });const rx = bt;function sx() {
    ve.call(this);
  } function lx(t) {
    this.name = t, this.zoomLimit, ve.call(this), this._roamTransformable = new sx, this._rawTransformable = new sx, this._center, this._zoom;
  } function ux(t, e, i, n) {
    const o = i.seriesModel; const a = o ? o.coordinateSystem : null;return a === this ? a[t](n) : null;
  } function hx(t, e, i, n) {
    lx.call(this, t), this.map = e;const o = Ny.load(e, i);this._nameCoordMap = o.nameCoordMap, this._regionsMap = o.regionsMap, this._invertLongitute = null == n || n, this.regions = o.regions, this._rect = o.boundingRect;
  } function cx(t, e, i, n) {
    const o = i.geoModel; const a = i.seriesModel; const r = o ? o.coordinateSystem : a ? a.coordinateSystem || (a.getReferringComponents('geo')[0] || {}).coordinateSystem : null;return r === this ? r[t](n) : null;
  } function dx(t, e) {
    const i = t.get('boundingCoords');if (null != i) {
      const n = i[0]; const o = i[1];isNaN(n[0]) || isNaN(n[1]) || isNaN(o[0]) || isNaN(o[1]) || this.setBoundingRect(n[0], n[1], o[0] - n[0], o[1] - n[1]);
    } let a; const r = this.getBoundingRect(); let s = t.get('layoutCenter'); let l = t.get('layoutSize'); const u = e.getWidth(); const h = e.getHeight(); const c = r.width / r.height * this.aspectScale; let d = !1;if (s && l && (s = [El(s[0], u), El(s[1], h)], l = El(l, Math.min(u, h)), isNaN(s[0]) || isNaN(s[1]) || isNaN(l) || (d = !0)), d) {
      var f = {};1 < c ? (f.width = l, f.height = l / c) : (f.height = l, f.width = l * c), f.y = s[1] - f.height / 2, f.x = s[0] - f.width / 2;
    } else (a = t.getBoxLayoutParams()).aspect = c, f = bu(a, { width: u, height: h });this.setViewRect(f.x, f.y, f.width, f.height), this.setCenter(t.get('center')), this.setZoom(t.get('zoom'));
  } function fx(i, t) {
    R(t.get('geoCoord'), (t, e) => {
      i.addGeoCoord(e, t);
    });
  }b(sx, ve), lx.prototype = { constructor: lx, type: 'view', dimensions: ['x', 'y'], setBoundingRect(t, e, i, n) {
    return this._rect = new Di(t, e, i, n), this._rect;
  }, getBoundingRect() {
    return this._rect;
  }, setViewRect(t, e, i, n) {
    this.transformTo(t, e, i, n), this._viewRect = new Di(t, e, i, n);
  }, transformTo(t, e, i, n) {
    const o = this.getBoundingRect(); const a = this._rawTransformable;a.transform = o.calculateTransform(new Di(t, e, i, n)), a.decomposeTransform(), this._updateTransform();
  }, setCenter(t) {
    t && (this._center = t, this._updateCenterAndZoom());
  }, setZoom(t) {
    t = t || 1;const e = this.zoomLimit;e && (null != e.max && (t = Math.min(e.max, t)), null != e.min && (t = Math.max(e.min, t))), this._zoom = t, this._updateCenterAndZoom();
  }, getDefaultCenter() {
    const t = this.getBoundingRect();return [t.x + t.width / 2, t.y + t.height / 2];
  }, getCenter() {
    return this._center || this.getDefaultCenter();
  }, getZoom() {
    return this._zoom || 1;
  }, getRoamTransform() {
    return this._roamTransformable.getLocalTransform();
  }, _updateCenterAndZoom() {
    const t = this._rawTransformable.getLocalTransform(); const e = this._roamTransformable; let i = this.getDefaultCenter(); let n = this.getCenter(); const o = this.getZoom();n = bt([], n, t), i = bt([], i, t), e.origin = n, e.position = [i[0] - n[0], i[1] - n[1]], e.scale = [o, o], this._updateTransform();
  }, _updateTransform() {
    const t = this._roamTransformable; const e = this._rawTransformable;(e.parent = t).updateTransform(), e.updateTransform(), se(this.transform || (this.transform = []), e.transform || ae()), this._rawTransform = e.getLocalTransform(), this.invTransform = this.invTransform || [], de(this.invTransform, this.transform), this.decomposeTransform();
  }, getTransformInfo() {
    const t = this._roamTransformable.transform; const e = this._rawTransformable;return { roamTransform: t ? U(t) : ae(), rawScale: U(e.scale), rawPosition: U(e.position) };
  }, getViewRect() {
    return this._viewRect;
  }, getViewRectAfterRoam() {
    const t = this.getBoundingRect().clone();return t.applyTransform(this.transform), t;
  }, dataToPoint(t, e, i) {
    const n = e ? this._rawTransform : this.transform;return i = i || [], n ? rx(i, t, n) : at(i, t);
  }, pointToData(t) {
    const e = this.invTransform;return e ? rx([], t, e) : [t[0], t[1]];
  }, convertToPixel: T(ux, 'dataToPoint'), convertFromPixel: T(ux, 'pointToData'), containPoint(t) {
    return this.getViewRectAfterRoam().contain(t[0], t[1]);
  } }, b(lx, ve), hx.prototype = { constructor: hx, type: 'geo', dimensions: ['lng', 'lat'], containCoord(t) {
    for (let e = this.regions, i = 0;i < e.length;i++) if (e[i].contain(t)) return !0;return !1;
  }, transformTo(t, e, i, n) {
    let o = this.getBoundingRect(); const a = this._invertLongitute;o = o.clone(), a && (o.y = -o.y - o.height);const r = this._rawTransformable;if (r.transform = o.calculateTransform(new Di(t, e, i, n)), r.decomposeTransform(), a) {
      const s = r.scale;s[1] = -s[1];
    }r.updateTransform(), this._updateTransform();
  }, getRegion(t) {
    return this._regionsMap.get(t);
  }, getRegionByCoord(t) {
    for (let e = this.regions, i = 0;i < e.length;i++) if (e[i].contain(t)) return e[i];
  }, addGeoCoord(t, e) {
    this._nameCoordMap.set(t, e);
  }, getGeoCoord(t) {
    return this._nameCoordMap.get(t);
  }, getBoundingRect() {
    return this._rect;
  }, dataToPoint(t, e, i) {
    if ('string' === typeof t && (t = this.getGeoCoord(t)), t) return lx.prototype.dataToPoint.call(this, t, e, i);
  }, convertToPixel: T(cx, 'dataToPoint'), convertFromPixel: T(cx, 'pointToData') }, b(hx, lx);const px = { dimensions: hx.prototype.dimensions, create(t, s) {
    const l = [];t.eachComponent('geo', (t, e) => {
      const i = t.get('map'); let n = t.get('aspectScale'); let o = !0; const a = Sd.retrieveMap(i);a && a[0] && 'svg' === a[0].type ? (null == n && (n = 1), o = !1) : null == n && (n = .75);const r = new hx(i + e, i, t.get('nameMap'), o);r.aspectScale = n, r.zoomLimit = t.get('scaleLimit'), l.push(r), fx(r, t), (t.coordinateSystem = r).model = t, r.resize = dx, r.resize(t, s);
    }), t.eachSeries((t) => {
      if ('geo' === t.get('coordinateSystem')) {
        const e = t.get('geoIndex') || 0;t.coordinateSystem = l[e];
      }
    });const i = {};return t.eachSeriesByType('map', (t) => {
      if (!t.getHostGeoModel()) {
        const e = t.getMapType();i[e] = i[e] || [], i[e].push(t);
      }
    }), R(i, (t, e) => {
      const i = new hx(e, e, p(O(t, t => t.get('nameMap'))));i.zoomLimit = W.apply(null, O(t, t => t.get('scaleLimit'))), l.push(i), i.resize = dx, i.aspectScale = t[0].get('aspectScale'), i.resize(t[0], s), R(t, (t) => {
        fx(t.coordinateSystem = i, t);
      });
    }), l;
  }, getFilledRegions(t, e, i) {
    for (var n = (t || []).slice(), o = Q(), a = 0;a < n.length;a++)o.set(n[a].name, n[a]);return R(Ny.load(e, i).regions, (t) => {
      const e = t.name;o.get(e) || n.push({ name: e });
    }), n;
  } };wf('geo', px);bf((i) => {
    const o = {};i.eachSeriesByType('map', (t) => {
      const e = t.getMapType();if (!t.getHostGeoModel() && !o[e]) {
        const l = {};R(t.seriesGroup, (t) => {
          const r = t.coordinateSystem; const s = t.originalData;t.get('showLegendSymbol') && i.getComponent('legend') && s.each(s.mapDimension('value'), (t, e) => {
            const i = s.getName(e); const n = r.getRegion(i);if (n && !isNaN(t)) {
              const o = l[i] || 0; const a = r.dataToPoint(n.center);l[i] = o + 1, s.setItemLayout(e, { point: a, offset: o });
            }
          });
        });const n = t.getData();n.each((t) => {
          const e = n.getName(t); const i = n.getItemLayout(t) || {};i.showLabel = !l[e], n.setItemLayout(t, i);
        }), o[e] = !0;
      }
    });
  }), Sf((t) => {
    t.eachSeriesByType('map', (t) => {
      const e = t.get('color'); const i = t.getModel('itemStyle'); const n = i.get('areaColor'); const o = i.get('color') || e[t.seriesIndex % e.length];t.getData().setVisual({ areaColor: n, color: o });
    });
  }), xf(Ld.PROCESSOR.STATISTIC, (t) => {
    const n = {};t.eachSeriesByType('map', (t) => {
      const e = t.getHostGeoModel(); const i = e ? `o${e.id}` : `i${t.getMapType()}`;(n[i] = n[i] || []).push(t);
    }), R(n, (t, e) => {
      for (var i = (function (u, h) {
          const c = {};return R(u, (n) => {
            n.each(n.mapDimension('value'), (t, e) => {
              const i = `ec-${n.getName(e)}`;c[i] = c[i] || [], isNaN(t) || c[i].push(t);
            });
          }), u[0].map(u[0].mapDimension('value'), (t, e) => {
            for (var i, n = `ec-${u[0].getName(e)}`, o = 0, a = 1 / 0, r = -1 / 0, s = c[n].length, l = 0;l < s;l++)a = Math.min(a, c[n][l]), r = Math.max(r, c[n][l]), o += c[n][l];return i = 'min' === h ? a : 'max' === h ? r : 'average' === h ? o / s : o, 0 === s ? NaN : i;
          });
        }(O(t, t => t.getData()), t[0].get('mapValueCalculation'))), n = 0;n < t.length;n++)t[n].originalData = t[n].getData();for (n = 0;n < t.length;n++)(t[n].seriesGroup = t)[n].needsDrawMap = 0 === n && !t[n].getHostGeoModel(), t[n].setData(i.cloneShallow()), t[n].mainSeries = t[0];
    });
  }), yf((t) => {
    const e = [];R(t.series, (t) => {
      t && 'map' === t.type && (e.push(t), t.map = t.map || t.mapType, D(t, t.mapLocation));
    });
  }), ey('map', [{ type: 'mapToggleSelect', event: 'mapselectchanged', method: 'toggleSelected' }, { type: 'mapSelect', event: 'mapselected', method: 'select' }, { type: 'mapUnSelect', event: 'mapunselected', method: 'unSelect' }]);const gx = R; const mx = '\0__link_datas'; const vx = '\0__link_mainData';function yx(i) {
    const n = i.mainData; let t = i.datas;t || (t = { main: n }, i.datasAttr = { main: 'data' }), i.datas = i.mainData = null, Mx(n, t, i), gx(t, (e) => {
      gx(n.TRANSFERABLE_METHODS, (t) => {
        e.wrapMethod(t, T(xx, i));
      });
    }), n.wrapMethod('cloneShallow', T(bx, i)), gx(n.CHANGABLE_METHODS, (t) => {
      n.wrapMethod(t, T(_x, i));
    }), Y(t[n.dataType] === n);
  } function xx(t, e) {
    if (function (t) {
      return t[vx] === t;
    }(this)) {
      const i = P({}, this[mx]);Mx(i[this.dataType] = e, i, t);
    } else Ix(e, this.dataType, this[vx], t);return e;
  } function _x(t, e) {
    return t.struct && t.struct.update(this), e;
  } function bx(i, n) {
    return gx(n[mx], (t, e) => {
      t !== n && Ix(t.cloneShallow(), e, n, i);
    }), n;
  } function Sx(t) {
    const e = this[vx];return null == t || null == e ? e : e[mx][t];
  } function Mx(i, t, n) {
    i[mx] = {}, gx(t, (t, e) => {
      Ix(t, e, i, n);
    });
  } function Ix(t, e, i, n) {
    (i[mx][e] = t)[vx] = i, t.dataType = e, n.struct && (t[n.structAttr] = n.struct, n.struct[n.datasAttr[e]] = t), t.getLinkedData = Sx;
  } function Tx(t, e) {
    this.name = t || '', this.depth = 0, this.height = 0, this.parentNode = null, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.hostTree = e;
  } function Ax(t) {
    this.root, this.data, this._nodes = [], this.hostModel = t;
  } function Dx(t, e) {
    const i = e.children;t.parentNode !== e && (i.push(t), t.parentNode = e);
  } function Cx(t, e) {
    const i = t.isExpand ? t.children : []; const n = t.parentNode.children; const o = t.hierNode.i ? n[t.hierNode.i - 1] : null;if (i.length) {
      !(function (t) {
        const e = t.children; let i = e.length; let n = 0; let o = 0;for (;0 <= --i;) {
          const a = e[i];a.hierNode.prelim += n, a.hierNode.modifier += n, o += a.hierNode.change, n += a.hierNode.shift + o;
        }
      }(t));const a = (i[0].hierNode.prelim + i[i.length - 1].hierNode.prelim) / 2;o ? (t.hierNode.prelim = o.hierNode.prelim + e(t, o), t.hierNode.modifier = t.hierNode.prelim - a) : t.hierNode.prelim = a;
    } else o && (t.hierNode.prelim = o.hierNode.prelim + e(t, o));t.parentNode.hierNode.defaultAncestor = (function (t, e, i, n) {
      if (e) {
        for (var o = t, a = t, r = a.parentNode.children[0], s = e, l = o.hierNode.modifier, u = a.hierNode.modifier, h = r.hierNode.modifier, c = s.hierNode.modifier;s = Nx(s), a = Ox(a), s && a;) {
          o = Nx(o), r = Ox(r), o.hierNode.ancestor = t;const d = s.hierNode.prelim + c - a.hierNode.prelim - u + n(s, a);0 < d && (Rx((p = t, g = i, (f = s).hierNode.ancestor.parentNode === p.parentNode ? f.hierNode.ancestor : g), t, d), u += d, l += d), c += s.hierNode.modifier, u += a.hierNode.modifier, l += o.hierNode.modifier, h += r.hierNode.modifier;
        }s && !Nx(o) && (o.hierNode.thread = s, o.hierNode.modifier += c - l), a && !Ox(r) && (r.hierNode.thread = a, r.hierNode.modifier += u - h, i = t);
      } let f; let p; let g;return i;
    }(t, o, t.parentNode.hierNode.defaultAncestor || n[0], e));
  } function Lx(t) {
    const e = t.hierNode.prelim + t.parentNode.hierNode.modifier;t.setLayout({ x: e }, !0), t.hierNode.modifier += t.parentNode.hierNode.modifier;
  } function kx(t) {
    return arguments.length ? t : Ex;
  } function Px(t, e) {
    const i = {};return t -= Math.PI / 2, i.x = e * Math.cos(t), i.y = e * Math.sin(t), i;
  } function Nx(t) {
    const e = t.children;return e.length && t.isExpand ? e[e.length - 1] : t.hierNode.thread;
  } function Ox(t) {
    const e = t.children;return e.length && t.isExpand ? e[0] : t.hierNode.thread;
  } function Rx(t, e, i) {
    const n = i / (e.hierNode.i - t.hierNode.i);e.hierNode.change -= n, e.hierNode.shift += i, e.hierNode.modifier += i, e.hierNode.prelim += i, t.hierNode.change += n;
  } function Ex(t, e) {
    return t.parentNode === e.parentNode ? 1 : 2;
  }Tx.prototype = { constructor: Tx, isRemoved() {
    return this.dataIndex < 0;
  }, eachNode(t, e, i) {
    'function' === typeof t && (i = e, e = t, t = null), E(t = t || {}) && (t = { order: t });let n; const o = t.order || 'preorder'; const a = this[t.attr || 'children'];'preorder' === o && (n = e.call(i, this));for (let r = 0;!n && r < a.length;r++)a[r].eachNode(t, e, i);'postorder' === o && e.call(i, this);
  }, updateDepthAndHeight(t) {
    let e = 0;this.depth = t;for (let i = 0;i < this.children.length;i++) {
      const n = this.children[i];n.updateDepthAndHeight(t + 1), n.height > e && (e = n.height);
    } this.height = e + 1;
  }, getNodeById(t) {
    if (this.getId() === t) return this;for (let e = 0, i = this.children, n = i.length;e < n;e++) {
      const o = i[e].getNodeById(t);if (o) return o;
    }
  }, contains(t) {
    if (t === this) return !0;for (let e = 0, i = this.children, n = i.length;e < n;e++) {
      const o = i[e].contains(t);if (o) return o;
    }
  }, getAncestors(t) {
    for (var e = [], i = t ? this : this.parentNode;i;)e.push(i), i = i.parentNode;return e.reverse(), e;
  }, getValue(t) {
    const e = this.hostTree.data;return e.get(e.getDimension(t || 'value'), this.dataIndex);
  }, setLayout(t, e) {
    0 <= this.dataIndex && this.hostTree.data.setItemLayout(this.dataIndex, t, e);
  }, getLayout() {
    return this.hostTree.data.getItemLayout(this.dataIndex);
  }, getModel(t) {
    if (!(this.dataIndex < 0)) return this.hostTree.data.getItemModel(this.dataIndex).getModel(t);
  }, setVisual(t, e) {
    0 <= this.dataIndex && this.hostTree.data.setItemVisual(this.dataIndex, t, e);
  }, getVisual(t, e) {
    return this.hostTree.data.getItemVisual(this.dataIndex, t, e);
  }, getRawIndex() {
    return this.hostTree.data.getRawIndex(this.dataIndex);
  }, getId() {
    return this.hostTree.data.getId(this.dataIndex);
  }, isAncestorOf(t) {
    for (let e = t.parentNode;e;) {
      if (e === this) return !0;e = e.parentNode;
    } return !1;
  }, isDescendantOf(t) {
    return t !== this && t.isAncestorOf(this);
  } }, Ax.prototype = { constructor: Ax, type: 'tree', eachNode(t, e, i) {
    this.root.eachNode(t, e, i);
  }, getNodeByDataIndex(t) {
    const e = this.data.getRawIndex(t);return this._nodes[e];
  }, getNodeByName(t) {
    return this.root.getNodeByName(t);
  }, update() {
    for (var t = this.data, e = this._nodes, i = 0, n = e.length;i < n;i++)e[i].dataIndex = -1;for (i = 0, n = t.count();i < n;i++)e[t.getRawIndex(i)].dataIndex = i;
  }, clearLayouts() {
    this.data.clearItemLayouts();
  } }, Ax.createTree = function (t, e, i) {
    const s = new Ax(e); const l = []; let u = 1;!(function t(e, i) {
      const n = e.value;u = Math.max(u, L(n) ? n.length : 1);l.push(e);const o = new Tx(e.name, s);i ? Dx(o, i) : s.root = o;s._nodes.push(o);const a = e.children;if (a) for (let r = 0;r < a.length;r++)t(a[r], o);
    }(t)), s.root.updateDepthAndHeight(0);const n = lp(l, { coordDimensions: ['value'], dimensionsCount: u }); const o = new Yf(n, e);return o.initData(l), i && i(o), yx({ mainData: o, struct: s, structAttr: 'tree' }), s.update(), s;
  }, sc.extend({ type: 'series.tree', layoutInfo: null, layoutMode: 'box', getInitialData(t) {
    const e = { name: t.name, children: t.data }; const n = new Cl(t.leaves || {}, this, this.ecModel); var o = Ax.createTree(e, this, (t) => {
      t.wrapMethod('getItemModel', (t, e) => {
        const i = o.getNodeByDataIndex(e);return i.children.length && i.isExpand || (t.parentModel = n), t;
      });
    });let i = 0;o.eachNode('preorder', (t) => {
      t.depth > i && (i = t.depth);
    });const a = t.expandAndCollapse && 0 <= t.initialTreeDepth ? t.initialTreeDepth : i;return o.root.eachNode('preorder', (t) => {
      const e = t.hostTree.data.getRawDataItem(t.dataIndex);t.isExpand = e && null != e.collapsed ? !e.collapsed : t.depth <= a;
    }), o.data;
  }, getOrient() {
    let t = this.get('orient');return 'horizontal' === t ? t = 'LR' : 'vertical' === t && (t = 'TB'), t;
  }, setZoom(t) {
    this.option.zoom = t;
  }, setCenter(t) {
    this.option.center = t;
  }, formatTooltip(t) {
    for (var e = this.getData().tree, i = e.root.children[0], n = e.getNodeByDataIndex(t), o = n.getValue(), a = n.name;n && n !== i;)a = `${n.parentNode.name}.${a}`, n = n.parentNode;return au(a + (isNaN(o) || null == o ? '' : ` : ${o}`));
  }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: 'view', left: '12%', top: '12%', right: '12%', bottom: '12%', layout: 'orthogonal', edgeShape: 'curve', edgeForkPosition: '50%', roam: !1, nodeScaleRatio: .4, center: null, zoom: 1, orient: 'LR', symbol: 'emptyCircle', symbolSize: 7, expandAndCollapse: !0, initialTreeDepth: 2, lineStyle: { color: '#ccc', width: 1.5, curveness: .5 }, itemStyle: { color: 'lightsteelblue', borderColor: '#c23531', borderWidth: 1.5 }, label: { show: !0, color: '#555' }, leaves: { label: { show: !0 } }, animationEasing: 'linear', animationDuration: 700, animationDurationUpdate: 1e3 } });const zx = Cs({ shape: { parentPoint: [], childPoints: [], orient: '', forkPosition: '' }, style: { stroke: '#000', fill: null }, buildPath(t, e) {
    const i = e.childPoints; const n = i.length; const o = e.parentPoint; const a = i[0]; const r = i[n - 1];if (1 === n) return t.moveTo(o[0], o[1]), void t.lineTo(a[0], a[1]);const s = e.orient; const l = 'TB' === s || 'BT' === s ? 0 : 1; const u = 1 - l; const h = El(e.forkPosition, 1); const c = [];c[l] = o[l], c[u] = o[u] + (r[u] - o[u]) * h, t.moveTo(o[0], o[1]), t.lineTo(c[0], c[1]), t.moveTo(a[0], a[1]), c[l] = a[l], t.lineTo(c[0], c[1]), c[l] = r[l], t.lineTo(c[0], c[1]), t.lineTo(r[0], r[1]);for (let d = 1;d < n - 1;d++) {
      const f = i[d];t.moveTo(f[0], f[1]), c[l] = f[l], t.lineTo(c[0], c[1]);
    }
  } });function Bx(t, e) {
    const i = t.getItemLayout(e);return i && !isNaN(i.x) && !isNaN(i.y) && 'none' !== t.getItemVisual(e, 'symbol');
  } function Vx(t, e, i) {
    return i.itemModel = e, i.itemStyle = e.getModel('itemStyle').getItemStyle(), i.hoverItemStyle = e.getModel('emphasis.itemStyle').getItemStyle(), i.lineStyle = e.getModel('lineStyle').getLineStyle(), i.labelModel = e.getModel('label'), i.hoverLabelModel = e.getModel('emphasis.label'), !1 === t.isExpand && 0 !== t.children.length ? i.symbolInnerColor = i.itemStyle.fill : i.symbolInnerColor = '#fff', i;
  } function Gx(t, e, i, n, o, a) {
    const r = !i; const s = t.tree.getNodeByDataIndex(e); const l = s.getModel(); const u = (a = Vx(s, l, a), t.tree.root); const h = s.parentNode === u ? s : s.parentNode || s; const c = t.getItemGraphicEl(h.dataIndex); const d = h.getLayout(); const f = c ? { x: c.position[0], y: c.position[1], rawX: c.__radialOldRawX, rawY: c.__radialOldRawY } : d; const p = s.getLayout();r ? (i = new Xg(t, e, a)).attr('position', [f.x, f.y]) : i.updateData(t, e, a), i.__radialOldRawX = i.__radialRawX, i.__radialOldRawY = i.__radialRawY, i.__radialRawX = p.rawX, i.__radialRawY = p.rawY, n.add(i), t.setItemGraphicEl(e, i), cl(i, { position: [p.x, p.y] }, o);const g = i.getSymbolPath();if ('radial' === a.layout) {
      let m; let v; const y = u.children[0]; const x = y.getLayout(); const _ = y.children.length;if (p.x === x.x && !0 === s.isExpand) {
        const w = {};w.x = (y.children[0].getLayout().x + y.children[_ - 1].getLayout().x) / 2, w.y = (y.children[0].getLayout().y + y.children[_ - 1].getLayout().y) / 2, (m = Math.atan2(w.y - x.y, w.x - x.x)) < 0 && (m = 2 * Math.PI + m), (v = w.x < x.x) && (m -= Math.PI);
      } else (m = Math.atan2(p.y - x.y, p.x - x.x)) < 0 && (m = 2 * Math.PI + m), 0 === s.children.length || 0 !== s.children.length && !1 === s.isExpand ? (v = p.x < x.x) && (m -= Math.PI) : (v = p.x > x.x) || (m -= Math.PI);const b = v ? 'left' : 'right'; const S = a.labelModel.get('rotate'); const M = S * (Math.PI / 180);g.setStyle({ textPosition: a.labelModel.get('position') || b, textRotation: null == S ? -m : M, textOrigin: 'center', verticalAlign: 'middle' });
    }!(function (t, e, i, n, o, a, r, s, l) {
      const u = l.edgeShape; let h = n.__edge;if ('curve' === u)e.parentNode && e.parentNode !== i && cl(h = h || (n.__edge = new ds({ shape: Wx(l, o, o), style: D({ opacity: 0, strokeNoScale: !0 }, l.lineStyle) })), { shape: Wx(l, a, r), style: D({ opacity: 1 }, l.lineStyle) }, t);else if ('polyline' === u && 'orthogonal' === l.layout && e !== i && e.children && 0 !== e.children.length && !0 === e.isExpand) {
        for (var c = e.children, d = [], f = 0;f < c.length;f++) {
          const p = c[f].getLayout();d.push([p.x, p.y]);
        }cl(h = h || (n.__edge = new zx({ shape: { parentPoint: [r.x, r.y], childPoints: [[r.x, r.y]], orient: l.orient, forkPosition: l.edgeForkPosition }, style: D({ opacity: 0, strokeNoScale: !0 }, l.lineStyle) })), { shape: { parentPoint: [r.x, r.y], childPoints: d }, style: D({ opacity: 1 }, l.lineStyle) }, t);
      }s.add(h);
    }(o, s, u, i, f, d, p, n, a));
  } function Fx(t, e, i, n, o, a) {
    for (var r, s = t.tree.getNodeByDataIndex(e), l = t.tree.root, u = s.getModel(), h = (a = Vx(s, u, a), s.parentNode === l ? s : s.parentNode || s), c = a.edgeShape;null == (r = h.getLayout());)h = h.parentNode === l ? h : h.parentNode || h;cl(i, { position: [r.x + 1, r.y + 1] }, o, () => {
      n.remove(i), t.setItemGraphicEl(e, null);
    }), i.fadeOut(null, { keepLabel: !0 });const d = t.getItemGraphicEl(h.dataIndex).__edge; const f = i.__edge || (!1 === h.isExpand || 1 === h.children.length ? d : void 0);c = a.edgeShape;f && ('curve' === c ? cl(f, { shape: Wx(a, r, r), style: { opacity: 0 } }, o, () => {
      n.remove(f);
    }) : 'polyline' === c && 'orthogonal' === a.layout && cl(f, { shape: { parentPoint: [r.x, r.y], childPoints: [[r.x, r.y]] }, style: { opacity: 0 } }, o, () => {
      n.remove(f);
    }));
  } function Wx(t, e, i) {
    let n; let o; let a; let r; let s; let l; let u; let h; const c = t.orient;if ('radial' !== t.layout) return s = e.x, u = e.y, l = i.x, h = i.y, 'LR' !== c && 'RL' !== c || (n = s + (l - s) * t.curvature, o = u, a = l + (s - l) * t.curvature, r = h), 'TB' !== c && 'BT' !== c || (n = s, o = u + (h - u) * t.curvature, a = l, r = h + (u - h) * t.curvature), { x1: s, y1: u, x2: l, y2: h, cpx1: n, cpy1: o, cpx2: a, cpy2: r };s = e.rawX, u = e.rawY, l = i.rawX, h = i.rawY;const d = Px(s, u); const f = Px(s, u + (h - u) * t.curvature); const p = Px(l, h + (u - h) * t.curvature); const g = Px(l, h);return { x1: d.x, y1: d.y, x2: g.x, y2: g.y, cpx1: f.x, cpy1: f.y, cpx2: p.x, cpy2: p.y };
  } function Hx(t, e) {
    for (var i, n = [t];i = n.pop();) if (e(i), i.isExpand) {
      const o = i.children;if (o.length) for (let a = o.length - 1;0 <= a;a--)n.push(o[a]);
    }
  }Cf({ type: 'tree', init(t, e) {
    this._oldTree, this._mainGroup = new Ci, this._controller = new Vy(e.getZr()), this._controllerHost = { target: this.group }, this.group.add(this._mainGroup);
  }, render(n, t, i, e) {
    const o = n.getData(); const a = n.layoutInfo; const r = this._mainGroup; const s = n.get('layout');'radial' === s ? r.attr('position', [a.x + a.width / 2, a.y + a.height / 2]) : r.attr('position', [a.x, a.y]), this._updateViewCoordSys(n, a, s), this._updateController(n, t, i);const l = this._data; const u = { expandAndCollapse: n.get('expandAndCollapse'), layout: s, edgeShape: n.get('edgeShape'), edgeForkPosition: n.get('edgeForkPosition'), orient: n.getOrient(), curvature: n.get('lineStyle.curveness'), symbolRotate: n.get('symbolRotate'), symbolOffset: n.get('symbolOffset'), hoverAnimation: n.get('hoverAnimation'), useNameLabel: !0, fadeIn: !0 };o.diff(l).add((t) => {
      Bx(o, t) && Gx(o, t, null, r, n, u);
    })
      .update((t, e) => {
        const i = l.getItemGraphicEl(e);Bx(o, t) ? Gx(o, t, i, r, n, u) : i && Fx(l, e, i, r, n, u);
      })
      .remove((t) => {
        const e = l.getItemGraphicEl(t);e && Fx(l, t, e, r, n, u);
      })
      .execute(), this._nodeScaleRatio = n.get('nodeScaleRatio'), this._updateNodeAndLinkScale(n), !0 === u.expandAndCollapse && o.eachItemGraphicEl((t, e) => {
      t.off('click').on('click', () => {
        i.dispatchAction({ type: 'treeExpandAndCollapse', seriesId: n.id, dataIndex: e });
      });
    }), this._data = o;
  }, _updateViewCoordSys(t) {
    const i = t.getData(); const n = [];i.each((t) => {
      const e = i.getItemLayout(t);!e || isNaN(e.x) || isNaN(e.y) || n.push([+e.x, +e.y]);
    });const e = []; const o = [];Wa(n, e, o);const a = this._min; const r = this._max;o[0] - e[0] == 0 && (e[0] = a ? a[0] : e[0] - 1, o[0] = r ? r[0] : o[0] + 1), o[1] - e[1] == 0 && (e[1] = a ? a[1] : e[1] - 1, o[1] = r ? r[1] : o[1] + 1);const s = t.coordinateSystem = new lx;s.zoomLimit = t.get('scaleLimit'), s.setBoundingRect(e[0], e[1], o[0] - e[0], o[1] - e[1]), s.setCenter(t.get('center')), s.setZoom(t.get('zoom')), this.group.attr({ position: s.position, scale: s.scale }), this._viewCoordSys = s, this._min = e, this._max = o;
  }, _updateController(o, t, a) {
    const e = this._controller; const i = this._controllerHost; const r = this.group;e.setPointerChecker((t, e, i) => {
      const n = r.getBoundingRect();return n.applyTransform(r.transform), n.contain(e, i) && !$y(t, a, o);
    }), e.enable(o.get('roam')), i.zoomLimit = o.get('scaleLimit'), i.zoom = o.coordinateSystem.getZoom(), e.off('pan').off('zoom')
      .on('pan', (t) => {
        jy(i, t.dx, t.dy), a.dispatchAction({ seriesId: o.id, type: 'treeRoam', dx: t.dx, dy: t.dy });
      }, this)
      .on('zoom', function (t) {
        qy(i, t.scale, t.originX, t.originY), a.dispatchAction({ seriesId: o.id, type: 'treeRoam', zoom: t.scale, originX: t.originX, originY: t.originY }), this._updateNodeAndLinkScale(o);
      }, this);
  }, _updateNodeAndLinkScale(t) {
    const e = t.getData(); const i = this._getNodeGlobalScale(t); const n = [i, i];e.eachItemGraphicEl((t, e) => {
      t.attr('scale', n);
    });
  }, _getNodeGlobalScale(t) {
    const e = t.coordinateSystem;if ('view' !== e.type) return 1;const i = this._nodeScaleRatio; const n = e.scale; const o = n && n[0] || 1;return ((e.getZoom() - 1) * i + 1) / o;
  }, dispose() {
    this._controller && this._controller.dispose(), this._controllerHost = {};
  }, remove() {
    this._mainGroup.removeAll(), this._data = null;
  } }), _f({ type: 'treeExpandAndCollapse', event: 'treeExpandAndCollapse', update: 'update' }, (n, t) => {
    t.eachComponent({ mainType: 'series', subType: 'tree', query: n }, (t) => {
      const e = n.dataIndex; const i = t.getData().tree.getNodeByDataIndex(e);i.isExpand = !i.isExpand;
    });
  }), _f({ type: 'treeRoam', event: 'treeRoam', update: 'none' }, (i, t) => {
    t.eachComponent({ mainType: 'series', subType: 'tree', query: i }, (t) => {
      const e = ax(t.coordinateSystem, i);t.setCenter && t.setCenter(e.center), t.setZoom && t.setZoom(e.zoom);
    });
  });function Zx(t, e, i) {
    if (t && 0 <= _(e, t.type)) {
      const n = i.getData().tree.root; let o = t.targetNode;if ('string' === typeof o && (o = n.getNodeById(o)), o && n.contains(o)) return { node: o };const a = t.targetNodeId;if (null != a && (o = n.getNodeById(a))) return { node: o };
    }
  } function Ux(t) {
    for (var e = [];t;)(t = t.parentNode) && e.push(t);return e.reverse();
  } function Xx(t, e) {
    return 0 <= _(Ux(t), e);
  } function Yx(t, e) {
    for (var i = [];t;) {
      const n = t.dataIndex;i.push({ name: t.name, dataIndex: n, value: e.getRawValue(n) }), t = t.parentNode;
    } return i.reverse(), i;
  }Sf(Lm('tree', 'circle')), bf((t, e) => {
    t.eachSeriesByType('tree', (t) => {
      !(function (t, e) {
        const i = (function (t, e) {
          return bu(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() });
        }(t, e));t.layoutInfo = i;const n = t.get('layout'); let o = 0; let a = 0; let r = null;r = 'radial' === n ? (o = 2 * Math.PI, a = Math.min(i.height, i.width) / 2, kx((t, e) => (t.parentNode === e.parentNode ? 1 : 2) / t.depth)) : (o = i.width, a = i.height, kx());const s = t.getData().tree.root; const l = s.children[0];if (l) {
          !(function (t) {
            t.hierNode = { defaultAncestor: null, ancestor: t, prelim: 0, modifier: 0, change: 0, shift: 0, i: 0, thread: null };for (var e, i, n = [t];e = n.pop();) if (i = e.children, e.isExpand && i.length) for (let o = i.length - 1;0 <= o;o--) {
              const a = i[o];a.hierNode = { defaultAncestor: null, ancestor: a, prelim: 0, modifier: 0, change: 0, shift: 0, i: o, thread: null }, n.push(a);
            }
          }(s)), (function (t, e, i) {
            for (var n, o = [t], a = [];n = o.pop();) if (a.push(n), n.isExpand) {
              const r = n.children;if (r.length) for (let s = 0;s < r.length;s++)o.push(r[s]);
            } for (;n = a.pop();)e(n, i);
          }(l, Cx, r)), s.hierNode.modifier = -l.hierNode.prelim, Hx(l, Lx);let u = l; let h = l; let c = l;Hx(l, (t) => {
            const e = t.getLayout().x;e < u.getLayout().x && (u = t), e > h.getLayout().x && (h = t), t.depth > c.depth && (c = t);
          });const d = u === h ? 1 : r(u, h) / 2; const f = d - u.getLayout().x; let p = 0; let g = 0; let m = 0; let v = 0;if ('radial' === n)p = o / (h.getLayout().x + d + f), g = a / (c.depth - 1 || 1), Hx(l, (t) => {
            m = (t.getLayout().x + f) * p, v = (t.depth - 1) * g;const e = Px(m, v);t.setLayout({ x: e.x, y: e.y, rawX: m, rawY: v }, !0);
          });else {
            const y = t.getOrient();'RL' === y || 'LR' === y ? (g = a / (h.getLayout().x + d + f), p = o / (c.depth - 1 || 1), Hx(l, (t) => {
              v = (t.getLayout().x + f) * g, m = 'LR' === y ? (t.depth - 1) * p : o - (t.depth - 1) * p, t.setLayout({ x: m, y: v }, !0);
            })) : 'TB' !== y && 'BT' !== y || (p = o / (h.getLayout().x + d + f), g = a / (c.depth - 1 || 1), Hx(l, (t) => {
              m = (t.getLayout().x + f) * p, v = 'TB' === y ? (t.depth - 1) * g : a - (t.depth - 1) * g, t.setLayout({ x: m, y: v }, !0);
            }));
          }
        }
      }(t, e));
    });
  }), sc.extend({ type: 'series.treemap', layoutMode: 'box', dependencies: ['grid', 'polar'], preventUsingHoverLayer: !0, _viewRoot: null, defaultOption: { progressive: 0, left: 'center', top: 'middle', right: null, bottom: null, width: '80%', height: '80%', sort: !0, clipWindow: 'origin', squareRatio: .5 * (1 + Math.sqrt(5)), leafDepth: null, drillDownIcon: '▶', zoomToNodeRatio: .1024, roam: !0, nodeClick: 'zoomToNode', animation: !0, animationDurationUpdate: 900, animationEasing: 'quinticInOut', breadcrumb: { show: !0, height: 22, left: 'center', top: 'bottom', emptyItemWidth: 25, itemStyle: { color: 'rgba(0,0,0,0.7)', borderColor: 'rgba(255,255,255,0.7)', borderWidth: 1, shadowColor: 'rgba(150,150,150,1)', shadowBlur: 3, shadowOffsetX: 0, shadowOffsetY: 0, textStyle: { color: '#fff' } }, emphasis: { textStyle: {} } }, label: { show: !0, distance: 0, padding: 5, position: 'inside', color: '#fff', ellipsis: !0 }, upperLabel: { show: !1, position: [0, '50%'], height: 20, color: '#fff', ellipsis: !0, verticalAlign: 'middle' }, itemStyle: { color: null, colorAlpha: null, colorSaturation: null, borderWidth: 0, gapWidth: 0, borderColor: '#fff', borderColorSaturation: null }, emphasis: { upperLabel: { show: !0, position: [0, '50%'], color: '#fff', ellipsis: !0, verticalAlign: 'middle' } }, visualDimension: 0, visualMin: null, visualMax: null, color: [], colorAlpha: null, colorSaturation: null, colorMappingBy: 'index', visibleMin: 10, childrenVisibleMin: null, levels: [] }, getInitialData(t, e) {
    const i = { name: t.name, children: t.data };!(function i(t) {
      let n = 0;R(t.children, (t) => {
        i(t);let e = t.value;L(e) && (e = e[0]), n += e;
      });let e = t.value;L(e) && (e = e[0]);null != e && !isNaN(e) || (e = n);e < 0 && (e = 0);L(t.value) ? t.value[0] = e : t.value = e;
    }(i));let n = t.levels || []; const o = new Cl({ itemStyle: this.designatedVisualItemStyle = {} }, this, e); const a = O((n = t.levels = (function (t, e) {
      let n; const i = e.get('color');if (!i) return;if (R(t = t || [], (t) => {
        const e = new Cl(t); const i = e.get('color');(e.get('itemStyle.color') || i && 'none' !== i) && (n = !0);
      }), !n) {
        (t[0] || (t[0] = {})).color = i.slice();
      } return t;
    }(n, e))) || [], t => new Cl(t, o, e), this); var r = Ax.createTree(i, this, (t) => {
      t.wrapMethod('getItemModel', (t, e) => {
        const i = r.getNodeByDataIndex(e); const n = a[i.depth];return t.parentModel = n || o, t;
      });
    });return r.data;
  }, optionUpdated() {
    this.resetViewRoot();
  }, formatTooltip(t) {
    const e = this.getData(); const i = this.getRawValue(t); const n = L(i) ? tu(i[0]) : tu(i);return au(`${e.getName(t)}: ${n}`);
  }, getDataParams(t) {
    const e = sc.prototype.getDataParams.apply(this, arguments); const i = this.getData().tree.getNodeByDataIndex(t);return e.treePathInfo = Yx(i, this), e;
  }, setLayoutInfo(t) {
    this.layoutInfo = this.layoutInfo || {}, P(this.layoutInfo, t);
  }, mapIdToIndex(t) {
    let e = this._idIndexMap;e || (e = this._idIndexMap = Q(), this._idIndexMapCount = 0);let i = e.get(t);return null == i && e.set(t, i = this._idIndexMapCount++), i;
  }, getViewRoot() {
    return this._viewRoot;
  }, resetViewRoot(t) {
    t ? this._viewRoot = t : t = this._viewRoot;const e = this.getRawData().tree.root;t && (t === e || e.contains(t)) || (this._viewRoot = e);
  } });const jx = 5;function qx(t) {
    this.group = new Ci, t.add(this.group);
  } function Kx(t, e, i, n, o, a) {
    const r = [[o ? t : t - jx, e], [t + i, e], [t + i, e + n], [o ? t : t - jx, e + n]];return a || r.splice(2, 0, [t + i + jx, e + n / 2]), o || r.push([t, e + n / 2]), r;
  }qx.prototype = { constructor: qx, render(t, e, i, n) {
    const o = t.getModel('breadcrumb'); const a = this.group;if (a.removeAll(), o.get('show') && i) {
      const r = o.getModel('itemStyle'); const s = r.getModel('textStyle'); const l = { pos: { left: o.get('left'), right: o.get('right'), top: o.get('top'), bottom: o.get('bottom') }, box: { width: e.getWidth(), height: e.getHeight() }, emptyItemWidth: o.get('emptyItemWidth'), totalWidth: 0, renderList: [] };this._prepare(i, l, s), this._renderContent(t, l, r, s, n), Su(a, l.pos, l.box);
    }
  }, _prepare(t, e, i) {
    for (let n = t;n;n = n.parentNode) {
      const o = n.getModel().get('name'); const a = i.getTextRect(o); const r = Math.max(a.width + 16, e.emptyItemWidth);e.totalWidth += r + 8, e.renderList.push({ node: n, text: o, width: r });
    }
  }, _renderContent(t, e, i, n, o) {
    for (var a, r, s = 0, l = e.emptyItemWidth, u = t.get('breadcrumb.height'), h = (function (t, e, i) {
        const n = e.width; const o = e.height; let a = El(t.x, n); let r = El(t.y, o); let s = El(t.x2, n); let l = El(t.y2, o);return (isNaN(a) || isNaN(parseFloat(t.x))) && (a = 0), (isNaN(s) || isNaN(parseFloat(t.x2))) && (s = n), (isNaN(r) || isNaN(parseFloat(t.y))) && (r = 0), (isNaN(l) || isNaN(parseFloat(t.y2))) && (l = o), i = iu(i || 0), { width: Math.max(s - a - i[1] - i[3], 0), height: Math.max(l - r - i[0] - i[2], 0) };
      }(e.pos, e.box)), c = e.totalWidth, d = e.renderList, f = d.length - 1;0 <= f;f--) {
      const p = d[f]; const g = p.node; let m = p.width; let v = p.text;c > h.width && (c -= m - l, m = l, v = null);const y = new Qr({ shape: { points: Kx(s, 0, m, u, f === d.length - 1, 0 === f) }, style: D(i.getItemStyle(), { lineJoin: 'bevel', text: v, textFill: n.getTextColor(), textFont: n.getFont() }), z: 10, onclick: T(o, g) });this.group.add(y), a = t, r = g, y.eventData = { componentType: 'series', componentSubType: 'treemap', componentIndex: a.componentIndex, seriesIndex: a.componentIndex, seriesName: a.name, seriesType: 'treemap', selfType: 'breadcrumb', nodeData: { dataIndex: r && r.dataIndex, name: r && r.name }, treePathInfo: r && Yx(r, a) }, s += m + 8;
    }
  }, remove() {
    this.group.removeAll();
  } };function $x(t) {
    const e = s_(t);return e.stroke = e.fill = e.lineWidth = null, e;
  } const Jx = A; const Qx = Ci; const t_ = rs; const e_ = R; const i_ = ['label']; const n_ = ['emphasis', 'label']; const o_ = ['upperLabel']; const a_ = ['emphasis', 'upperLabel']; const r_ = 10; var s_ = ha([['fill', 'color'], ['stroke', 'strokeColor'], ['lineWidth', 'strokeWidth'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);function l_(h, r, s, l, u, e, c, t, i, n) {
    if (c) {
      var d = c.getLayout(); const o = h.getData();if (o.setItemGraphicEl(c.dataIndex, null), d && d.isInView) {
        const f = d.width; const p = d.height; const g = d.borderWidth; var m = d.invisible; var v = c.getRawIndex(); var y = t && t.getRawIndex(); const a = c.viewChildren; const x = d.upperHeight; const _ = a && a.length; const w = c.getModel('itemStyle'); const b = c.getModel('emphasis.itemStyle'); const S = L('nodeGroup', Qx);if (S) {
          if (i.add(S), S.attr('position', [d.x || 0, d.y || 0]), S.__tmNodeWidth = f, S.__tmNodeHeight = p, d.isAboveViewRoot) return S;var M = c.getModel(); const I = L('background', t_, n, 1);if (I && (function (t, e, i) {
            if (e.dataIndex = c.dataIndex, e.seriesIndex = h.seriesIndex, e.setShape({ x: 0, y: 0, width: f, height: p }), m)A(e);else {
              e.invisible = !1;const n = c.getVisual('borderColor', !0); const o = b.get('borderColor'); const a = $x(w);a.fill = n;const r = s_(b);if (r.fill = o, i) {
                const s = f - 2 * g;D(a, r, n, s, x, { x: g, y: 0, width: s, height: x });
              } else a.text = r.text = null;e.setStyle(a), Us(e, r);
            }t.add(e);
          }(S, I, _ && d.upperLabelHeight)), _)Qs(S) && Js(S, !1), I && (Js(I, !0), o.setItemGraphicEl(c.dataIndex, I));else {
            const T = L('content', t_, n, 2);T && (function (t, e) {
              e.dataIndex = c.dataIndex, e.seriesIndex = h.seriesIndex;const i = Math.max(f - 2 * g, 0); const n = Math.max(p - 2 * g, 0);if (e.culling = !0, e.setShape({ x: g, y: g, width: i, height: n }), m)A(e);else {
                e.invisible = !1;const o = c.getVisual('color', !0); const a = $x(w);a.fill = o;const r = s_(b);D(a, r, o, i, n), e.setStyle(a), Us(e, r);
              }t.add(e);
            }(S, T)), I && Qs(I) && Js(I, !1), Js(S, !0), o.setItemGraphicEl(c.dataIndex, S);
          } return S;
        }
      }
    } function A(t) {
      t.invisible || e.push(t);
    } function D(t, e, i, n, o, a) {
      const r = M.get('name'); const s = M.getModel(a ? o_ : i_); const l = M.getModel(a ? a_ : n_); const u = s.getShallow('show');el(t, e, s, l, { defaultText: u ? r : null, autoColor: i, isRectText: !0, labelFetcher: h, labelDataIndex: c.dataIndex, labelProp: a ? 'upperLabel' : 'label' }), C(t, a, d), C(e, a, d), a && (t.textRect = k(a)), t.truncate = u && s.get('ellipsis') ? { outerWidth: n, outerHeight: o, minChar: 2 } : null;
    } function C(t, e, i) {
      const n = t.text;if (!e && i.isLeafRoot && null != n) {
        const o = h.get('drillDownIcon', !0);t.text = o ? `${o} ${n}` : n;
      }
    } function L(t, e, i, n) {
      let o = null != y && s[t][y]; const a = u[t];return o ? (s[t][y] = null, (function (t, e, i) {
        (t[v] = {}).old = 'nodeGroup' === i ? e.position.slice() : P({}, e.shape);
      }(a, o, t))) : m || ((o = new e({ z: (function (t, e) {
        const i = t * r_ + e;return (i - 1) / i;
      }(i, n)) })).__tmDepth = i, (function (t, e, i) {
        const n = t[v] = {}; const o = c.parentNode;if (o && (!l || 'drillDown' === l.direction)) {
          let a = 0; let r = 0; const s = u.background[o.getRawIndex()];!l && s && s.old && (a = s.old.width, r = s.old.height), n.old = 'nodeGroup' === i ? [0, r] : { x: a, y: r, width: 0, height: 0 };
        }n.fadein = 'nodeGroup' !== i;
      }(a, 0, o.__tmStorageName = t))), r[t][v] = o;
    }
  }Cf({ type: 'treemap', init(t, e) {
    this._containerGroup, this._storage = { nodeGroup: [], background: [], content: [] }, this._oldTree, this._breadcrumb, this._controller, this._state = 'ready';
  }, render(t, e, i, n) {
    if (!(_(e.findComponents({ mainType: 'series', subType: 'treemap', query: n }), t) < 0)) {
      this.seriesModel = t, this.api = i, this.ecModel = e;const o = Zx(n, ['treemapZoomToNode', 'treemapRootToNode'], t); const a = n && n.type; const r = t.layoutInfo; const s = !this._oldTree; const l = this._storage; const u = 'treemapRootToNode' === a && o && l ? { rootNodeGroup: l.nodeGroup[o.node.getRawIndex()], direction: n.direction } : null; const h = this._giveContainerGroup(r); const c = this._doRender(h, t, u);s || a && 'treemapZoomToNode' !== a && 'treemapRootToNode' !== a ? c.renderFinally() : this._doAnimation(h, c, t, u), this._resetController(i), this._renderBreadcrumb(t, i, o);
    }
  }, _giveContainerGroup(t) {
    let e = this._containerGroup;return e || (e = this._containerGroup = new Qx, this._initEvents(e), this.group.add(e)), e.attr('position', [t.x, t.y]), e;
  }, _doRender(t, e, i) {
    const n = e.getData().tree; const o = this._oldTree; const a = { nodeGroup: [], background: [], content: [] }; const r = { nodeGroup: [], background: [], content: [] }; const s = this._storage; const l = []; const c = T(l_, e, r, s, i, a, l);!(function a(r, s, l, u, h) {
      u ? e_(s = r, (t, e) => {
        t.isRemoved() || i(e, e);
      }) : new kf(s, r, t, t).add(i)
        .update(i)
        .remove(T(i, null))
        .execute();function t(t) {
        return t.getId();
      } function i(t, e) {
        const i = null != t ? r[t] : null; const n = null != e ? s[e] : null; const o = c(i, n, l, h);o && a(i && i.viewChildren || [], n && n.viewChildren || [], o, u, h + 1);
      }
    }(n.root ? [n.root] : [], o && o.root ? [o.root] : [], t, n === o || !o, 0));let u; let h; const d = (h = { nodeGroup: [], background: [], content: [] }, (u = s) && e_(u, (t, e) => {
      const i = h[e];e_(t, (t) => {
        t && (i.push(t), t.__tmWillDelete = 1);
      });
    }), h);return this._oldTree = n, this._storage = r, { lastsForAnimation: a, willDeleteEls: d, renderFinally() {
      e_(d, (t) => {
        e_(t, (t) => {
          t.parent && t.parent.remove(t);
        });
      }), e_(l, (t) => {
        t.invisible = !0, t.dirty();
      });
    } };
  }, _doAnimation(t, a, e, s) {
    if (e.get('animation')) {
      const l = e.get('animationDurationUpdate'); const u = e.get('animationEasing'); const h = (function () {
        let a; const r = []; let s = {};return { add(t, e, i, n, o) {
          return E(n) && (o = n, n = 0), !s[t.id] && (s[t.id] = 1, r.push({ el: t, target: e, time: i, delay: n, easing: o }), !0);
        }, done(t) {
          return a = t, this;
        }, start() {
          for (var t = r.length, e = 0, i = r.length;e < i;e++) {
            const n = r[e];n.el.animateTo(n.target, n.time, n.delay, n.easing, o);
          } return this;function o() {
            --t || (r.length = 0, s = {}, a && a());
          }
        } };
      }());e_(a.willDeleteEls, (t, r) => {
        e_(t, (t, e) => {
          if (!t.invisible) {
            let i; const n = t.parent;if (s && 'drillDown' === s.direction)i = n === s.rootNodeGroup ? { shape: { x: 0, y: 0, width: n.__tmNodeWidth, height: n.__tmNodeHeight }, style: { opacity: 0 } } : { style: { opacity: 0 } };else {
              let o = 0; let a = 0;n.__tmWillDelete || (o = n.__tmNodeWidth / 2, a = n.__tmNodeHeight / 2), i = 'nodeGroup' === r ? { position: [o, a], style: { opacity: 0 } } : { shape: { x: o, y: a, width: 0, height: 0 }, style: { opacity: 0 } };
            }i && h.add(t, i, l, u);
          }
        });
      }), e_(this._storage, (t, o) => {
        e_(t, (t, e) => {
          const i = a.lastsForAnimation[o][e]; const n = {};i && ('nodeGroup' === o ? i.old && (n.position = t.position.slice(), t.attr('position', i.old)) : (i.old && (n.shape = P({}, t.shape), t.setShape(i.old)), i.fadein ? (t.setStyle('opacity', 0), n.style = { opacity: 1 }) : 1 !== t.style.opacity && (n.style = { opacity: 1 })), h.add(t, n, l, u));
        });
      }, this), this._state = 'animating', h.done(Jx(function () {
        this._state = 'ready', a.renderFinally();
      }, this)).start();
    }
  }, _resetController(t) {
    let e = this._controller;e || ((e = this._controller = new Vy(t.getZr())).enable(this.seriesModel.get('roam')), e.on('pan', Jx(this._onPan, this)), e.on('zoom', Jx(this._onZoom, this)));const n = new Di(0, 0, t.getWidth(), t.getHeight());e.setPointerChecker((t, e, i) => n.contain(e, i));
  }, _clearController() {
    let t = this._controller;t && (t.dispose(), t = null);
  }, _onPan(t) {
    if ('animating' !== this._state && (3 < Math.abs(t.dx) || 3 < Math.abs(t.dy))) {
      const e = this.seriesModel.getData().tree.root;if (!e) return;const i = e.getLayout();if (!i) return;this.api.dispatchAction({ type: 'treemapMove', from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: i.x + t.dx, y: i.y + t.dy, width: i.width, height: i.height } });
    }
  }, _onZoom(t) {
    let e = t.originX; let i = t.originY;if ('animating' !== this._state) {
      const n = this.seriesModel.getData().tree.root;if (!n) return;const o = n.getLayout();if (!o) return;const a = new Di(o.x, o.y, o.width, o.height); const r = this.seriesModel.layoutInfo;e -= r.x, i -= r.y;const s = ae();ue(s, s, [-e, -i]), ce(s, s, [t.scale, t.scale]), ue(s, s, [e, i]), a.applyTransform(s), this.api.dispatchAction({ type: 'treemapRender', from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: a.x, y: a.y, width: a.width, height: a.height } });
    }
  }, _initEvents(t) {
    t.on('click', function (t) {
      if ('ready' === this._state) {
        const e = this.seriesModel.get('nodeClick', !0);if (e) {
          const i = this.findTarget(t.offsetX, t.offsetY);if (i) {
            const n = i.node;if (n.getLayout().isLeafRoot) this._rootToNode(i);else if ('zoomToNode' === e) this._zoomToNode(i);else if ('link' === e) {
              const o = n.hostTree.data.getItemModel(n.dataIndex); const a = o.get('link', !0); const r = o.get('target', !0) || 'blank';a && gu(a, r);
            }
          }
        }
      }
    }, this);
  }, _renderBreadcrumb(e, t, i) {
    i = i || ((i = null != e.get('leafDepth', !0) ? { node: e.getViewRoot() } : this.findTarget(t.getWidth() / 2, t.getHeight() / 2)) || { node: e.getData().tree.root }), (this._breadcrumb || (this._breadcrumb = new qx(this.group))).render(e, t, i.node, Jx(function (t) {
      'animating' !== this._state && (Xx(e.getViewRoot(), t) ? this._rootToNode({ node: t }) : this._zoomToNode({ node: t }));
    }, this));
  }, remove() {
    this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = { nodeGroup: [], background: [], content: [] }, this._state = 'ready', this._breadcrumb && this._breadcrumb.remove();
  }, dispose() {
    this._clearController();
  }, _zoomToNode(t) {
    this.api.dispatchAction({ type: 'treemapZoomToNode', from: this.uid, seriesId: this.seriesModel.id, targetNode: t.node });
  }, _rootToNode(t) {
    this.api.dispatchAction({ type: 'treemapRootToNode', from: this.uid, seriesId: this.seriesModel.id, targetNode: t.node });
  }, findTarget(o, a) {
    let r;return this.seriesModel.getViewRoot().eachNode({ attr: 'viewChildren', order: 'preorder' }, function (t) {
      const e = this._storage.background[t.getRawIndex()];if (e) {
        const i = e.transformCoordToLocal(o, a); const n = e.shape;if (!(n.x <= i[0] && i[0] <= n.x + n.width && n.y <= i[1] && i[1] <= n.y + n.height)) return !1;r = { node: t, offsetX: i[0], offsetY: i[1] };
      }
    }, this), r;
  } });for (let u_ = function () {}, h_ = ['treemapZoomToNode', 'treemapRender', 'treemapMove'], c_ = 0;c_ < h_.length;c_++)_f({ type: h_[c_], update: 'updateView' }, u_);_f({ type: 'treemapRootToNode', update: 'updateView' }, (o, t) => {
    t.eachComponent({ mainType: 'series', subType: 'treemap', query: o }, (t, e) => {
      const i = Zx(o, ['treemapZoomToNode', 'treemapRootToNode'], t);if (i) {
        const n = t.getViewRoot();n && (o.direction = Xx(n, i.node) ? 'rollUp' : 'drillDown'), t.resetViewRoot(i.node);
      }
    });
  });const d_ = R; const f_ = z; const p_ = -1; const g_ = function (t) {
    const e = t.mappingMethod; const i = t.type; const n = this.option = k(t);this.type = i, this.mappingMethod = e, this._normalizeData = T_[e];const o = m_[i];this.applyVisual = o.applyVisual, this.getColorMapper = o.getColorMapper, this._doMap = o._doMap[e], 'piecewise' === e ? (v_(n), (function (i) {
      const t = i.pieceList;i.hasSpecialVisual = !1, R(t, (t, e) => {
        t.originIndex = e, null != t.visual && (i.hasSpecialVisual = !0);
      });
    }(n))) : 'category' === e ? n.categories ? (function (t) {
      const e = t.categories; let i = t.visual; const n = t.categoryMap = {};if (d_(e, (t, e) => {
        n[t] = e;
      }), !L(i)) {
        const o = [];z(i) ? d_(i, (t, e) => {
          const i = n[e];o[null != i ? i : p_] = t;
        }) : o[p_] = i, i = I_(t, o);
      } for (let a = e.length - 1;0 <= a;a--)null == i[a] && (delete n[e[a]], e.pop());
    }(n)) : v_(n, !0) : (Y('linear' !== e || n.dataExtent), v_(n));
  };g_.prototype = { constructor: g_, mapValueToVisual(t) {
    const e = this._normalizeData(t);return this._doMap(e, t);
  }, getNormalizer() {
    return A(this._normalizeData, this);
  } };var m_ = g_.visualHandlers = { color: { applyVisual: __('color'), getColorMapper() {
    const o = this.option;return A('category' === o.mappingMethod ? function (t, e) {
      return e || (t = this._normalizeData(t)), w_.call(this, t);
    } : function (t, e, i) {
      const n = !!i;return e || (t = this._normalizeData(t)), i = Ue(t, o.parsedVisual, i), n ? i : $e(i, 'rgba');
    }, this);
  }, _doMap: { linear(t) {
    return $e(Ue(t, this.option.parsedVisual), 'rgba');
  }, category: w_, piecewise(t, e) {
    let i = M_.call(this, e);return null == i && (i = $e(Ue(t, this.option.parsedVisual), 'rgba')), i;
  }, fixed: b_ } }, colorHue: y_((t, e) => qe(t, e)), colorSaturation: y_((t, e) => qe(t, null, e)), colorLightness: y_((t, e) => qe(t, null, null, e)), colorAlpha: y_((t, e) => Ke(t, e)), opacity: { applyVisual: __('opacity'), _doMap: S_([0, 1]) }, liftZ: { applyVisual: __('liftZ'), _doMap: { linear: b_, category: b_, piecewise: b_, fixed: b_ } }, symbol: { applyVisual(t, e, i) {
    const n = this.mapValueToVisual(t);if (E(n))i('symbol', n);else if (f_(n)) for (const o in n)n.hasOwnProperty(o) && i(o, n[o]);
  }, _doMap: { linear: x_, category: w_, piecewise(t, e) {
    let i = M_.call(this, e);return null == i && (i = x_.call(this, t)), i;
  }, fixed: b_ } }, symbolSize: { applyVisual: __('symbolSize'), _doMap: S_([0, 1]) } };function v_(t, e) {
    const i = t.visual; const n = [];z(i) ? d_(i, (t) => {
      n.push(t);
    }) : null != i && n.push(i);e || 1 !== n.length || { color: 1, symbol: 1 }.hasOwnProperty(t.type) || (n[1] = n[0]), I_(t, n);
  } function y_(n) {
    return { applyVisual(t, e, i) {
      t = this.mapValueToVisual(t), i('color', n(e('color'), t));
    }, _doMap: S_([0, 1]) };
  } function x_(t) {
    const e = this.option.visual;return e[Math.round(Rl(t, [0, 1], [0, e.length - 1], !0))] || {};
  } function __(n) {
    return function (t, e, i) {
      i(n, this.mapValueToVisual(t));
    };
  } function w_(t) {
    const e = this.option.visual;return e[this.option.loop && t !== p_ ? t % e.length : t];
  } function b_() {
    return this.option.visual[0];
  } function S_(n) {
    return { linear(t) {
      return Rl(t, n, this.option.visual, !0);
    }, category: w_, piecewise(t, e) {
      let i = M_.call(this, e);return null == i && (i = Rl(t, n, this.option.visual, !0)), i;
    }, fixed: b_ };
  } function M_(t) {
    const e = this.option; const i = e.pieceList;if (e.hasSpecialVisual) {
      const n = i[g_.findPieceIndex(t, i)];if (n && n.visual) return n.visual[this.type];
    }
  } function I_(t, e) {
    return t.visual = e, 'color' === t.type && (t.parsedVisual = O(e, t => Fe(t))), e;
  } var T_ = { linear(t) {
    return Rl(t, this.option.dataExtent, [0, 1], !0);
  }, piecewise(t) {
    const e = this.option.pieceList; const i = g_.findPieceIndex(t, e, !0);if (null != i) return Rl(i, [0, e.length - 1], [0, 1], !0);
  }, category(t) {
    const e = this.option.categories ? this.option.categoryMap[t] : t;return null == e ? p_ : e;
  }, fixed: et };function A_(t, e, i) {
    return t ? e <= i : e < i;
  }g_.listVisualTypes = function () {
    const i = [];return R(m_, (t, e) => {
      i.push(e);
    }), i;
  }, g_.addVisualHandler = function (t, e) {
    m_[t] = e;
  }, g_.isValidType = function (t) {
    return m_.hasOwnProperty(t);
  }, g_.eachVisual = function (t, e, i) {
    z(t) ? R(t, e, i) : e.call(i, t);
  }, g_.mapVisual = function (t, n, o) {
    let a; let r = L(t) ? [] : z(t) ? {} : (a = !0, null);return g_.eachVisual(t, (t, e) => {
      const i = n.call(o, t, e);a ? r = i : r[e] = i;
    }), r;
  }, g_.retrieveVisuals = function (i) {
    let n; const o = {};return i && d_(m_, (t, e) => {
      i.hasOwnProperty(e) && (o[e] = i[e], n = !0);
    }), n ? o : null;
  }, g_.prepareVisualTypes = function (t) {
    if (f_(t)) {
      const i = [];d_(t, (t, e) => {
        i.push(e);
      }), t = i;
    } else {
      if (!L(t)) return [];t = t.slice();
    } return t.sort((t, e) => ('color' === e && 'color' !== t && 0 === t.indexOf('color') ? 1 : -1)), t;
  }, g_.dependsOn = function (t, e) {
    return 'color' === e ? !(!t || 0 !== t.indexOf(e)) : t === e;
  }, g_.findPieceIndex = function (n, t, e) {
    for (var o, a = 1 / 0, i = 0, r = t.length;i < r;i++) {
      const s = t[i].value;if (null != s) {
        if (s === n || 'string' === typeof s && s === `${n}`) return i;e && c(s, i);
      }
    } for (i = 0, r = t.length;i < r;i++) {
      const l = t[i]; const u = l.interval; const h = l.close;if (u) {
        if (u[0] === -1 / 0) {
          if (A_(h[1], n, u[1])) return i;
        } else if (u[1] === 1 / 0) {
          if (A_(h[0], u[0], n)) return i;
        } else if (A_(h[0], u[0], n) && A_(h[1], n, u[1])) return i;e && c(u[0], i), e && c(u[1], i);
      }
    } if (e) return n === 1 / 0 ? t.length - 1 : n === -1 / 0 ? 0 : o;function c(t, e) {
      const i = Math.abs(t - n);i < a && (a = i, o = e);
    }
  };const D_ = L; const C_ = 'itemStyle'; const L_ = { seriesType: 'treemap', reset(t, e, i, n) {
    const o = t.getData().tree.root;o.isRemoved() || !(function n(t, e, o, a) {
      const r = t.getModel();const i = t.getLayout();if (!i || i.invisible || !i.isInView) return;const s = t.getModel(C_);const l = k_(s, e, a);let u = s.get('borderColor');const h = s.get('borderColorSaturation');let c;null != h && (c = P_(l), d = h, u = null != (f = c) ? qe(f, null, null, d) : null);let d; let f;t.setVisual('borderColor', u);const p = t.viewChildren;if (p && p.length) {
        const g = O_(t, r, i, s, l, p);R(p, (t, e) => {
          if (t.depth >= o.length || t === o[t.depth]) {
            const i = E_(r, l, t, e, g, a);n(t, i, o, a);
          }
        });
      } else c = P_(l), t.setVisual('color', c);
    }(o, {}, t.getViewRoot().getAncestors(), t));
  } };function k_(i, n, t) {
    const o = P({}, n); const a = t.designatedVisualItemStyle;return R(['color', 'colorAlpha', 'colorSaturation'], (t) => {
      a[t] = n[t];const e = i.get(t);(a[t] = null) != e && (o[t] = e);
    }), o;
  } function P_(t) {
    let e = N_(t, 'color');if (e) {
      const i = N_(t, 'colorAlpha'); const n = N_(t, 'colorSaturation');return n && (e = qe(e, null, null, n)), i && (e = Ke(e, i)), e;
    }
  } function N_(t, e) {
    const i = t[e];if (null != i && 'none' !== i) return i;
  } function O_(t, e, i, n, o, a) {
    if (a && a.length) {
      const r = R_(e, 'color') || null != o.color && 'none' !== o.color && (R_(e, 'colorAlpha') || R_(e, 'colorSaturation'));if (r) {
        const s = e.get('visualMin'); const l = e.get('visualMax'); const u = i.dataExtent.slice();null != s && s < u[0] && (u[0] = s), null != l && l > u[1] && (u[1] = l);const h = e.get('colorMappingBy'); const c = { type: r.name, dataExtent: u, visual: r.range };'color' !== c.type || 'index' !== h && 'id' !== h ? c.mappingMethod = 'linear' : (c.mappingMethod = 'category', c.loop = !0);const d = new g_(c);return d.__drColorMappingBy = h, d;
      }
    }
  } function R_(t, e) {
    const i = t.get(e);return D_(i) && i.length ? { name: e, range: i } : null;
  } function E_(t, e, i, n, o, a) {
    const r = P({}, e);if (o) {
      const s = o.type; const l = 'color' === s && o.__drColorMappingBy; const u = 'index' === l ? n : 'id' === l ? a.mapIdToIndex(i.getId()) : i.getValue(t.get('visualDimension'));r[s] = o.mapValueToVisual(u);
    } return r;
  } const z_ = Math.max; const B_ = Math.min; const V_ = W; const G_ = R; const F_ = ['itemStyle', 'borderWidth']; const W_ = ['itemStyle', 'gapWidth']; const H_ = ['upperLabel', 'show']; const Z_ = ['upperLabel', 'height']; const U_ = { seriesType: 'treemap', reset(t, e, i, n) {
    const o = i.getWidth(); const a = i.getHeight(); const r = t.option; const s = bu(t.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }); const l = r.size || []; const u = El(V_(s.width, l[0]), o); const h = El(V_(s.height, l[1]), a); const c = n && n.type; const d = Zx(n, ['treemapZoomToNode', 'treemapRootToNode'], t); const f = 'treemapRender' === c || 'treemapMove' === c ? n.rootRect : null; const p = t.getViewRoot(); const g = Ux(p);if ('treemapMove' !== c) {
      const m = 'treemapZoomToNode' === c ? (function (t, e, i, n, o) {
        let a; let r = (e || {}).node; const s = [n, o];if (!r || r === i) return s;const l = n * o; let u = l * t.option.zoomToNodeRatio;for (;a = r.parentNode;) {
          for (var h = 0, c = a.children, d = 0, f = c.length;d < f;d++)h += c[d].getValue();const p = r.getValue();if (0 === p) return s;u *= h / p;const g = a.getModel(); const m = g.get(F_); const v = Math.max(m, q_(g));u += 4 * m * m + (3 * m + v) * Math.pow(u, .5), Hl < u && (u = Hl), r = a;
        }u < l && (u = l);const y = Math.pow(u / l, .5);return [n * y, o * y];
      }(t, d, p, u, h)) : f ? [f.width, f.height] : [u, h]; let v = r.sort;v && 'asc' !== v && 'desc' !== v && (v = 'desc');const y = { squareRatio: r.squareRatio, sort: v, leafDepth: r.leafDepth };p.hostTree.clearLayouts();let x = { x: 0, y: 0, width: m[0], height: m[1], area: m[0] * m[1] };p.setLayout(x), (function t(e, i, n, o) {
        let a;let r;if (e.isRemoved()) return;const s = e.getLayout();a = s.width;r = s.height;var l = e.getModel();const u = l.get(F_);const h = l.get(W_) / 2;const c = q_(l);const d = Math.max(u, c);const f = u - h;const p = d - h;var l = e.getModel();e.setLayout({ borderWidth: u, upperHeight: d, upperLabelHeight: c }, !0);a = z_(a - 2 * f, 0);r = z_(r - f - p, 0);const g = a * r;const m = X_(e, l, g, i, n, o);if (!m.length) return;const v = { x: f, y: p, width: a, height: r };let y = B_(a, r);let x = 1 / 0;const _ = [];_.area = 0;for (var w = 0, b = m.length;w < b;) {
          const S = m[w];_.push(S), _.area += S.getLayout().area;const M = Y_(_, y, i.squareRatio);x = M <= x ? (w++, M) : (_.area -= _.pop().getLayout().area, j_(_, y, v, h, !1), y = B_(v.width, v.height), _.length = _.area = 0, 1 / 0);
        }_.length && j_(_, y, v, h, !0);if (!n) {
          const I = l.get('childrenVisibleMin');null != I && g < I && (n = !0);
        } for (var w = 0, b = m.length;w < b;w++)t(m[w], i, n, o + 1);
      }(p, y, !1, 0));x = p.getLayout();G_(g, (t, e) => {
        const i = (g[e + 1] || p).getValue();t.setLayout(P({ dataExtent: [i, i], borderWidth: 0, upperHeight: 0 }, x));
      });
    } const _ = t.getData().tree.root;_.setLayout((function (t, e, i) {
      if (e) return { x: e.x, y: e.y };const n = { x: 0, y: 0 };if (!i) return n;const o = i.node; const a = o.getLayout();if (!a) return n;const r = [a.width / 2, a.height / 2]; let s = o;for (;s;) {
        const l = s.getLayout();r[0] += l.x, r[1] += l.y, s = s.parentNode;
      } return { x: t.width / 2 - r[0], y: t.height / 2 - r[1] };
    }(s, f, d)), !0), t.setLayoutInfo(s), (function e(t, i, n, o, a) {
      const r = t.getLayout();const s = n[a];const l = s && s === t;if (s && !l || a === n.length && t !== o) return;t.setLayout({ isInView: !0, invisible: !l && !i.intersect(r), isAboveViewRoot: l }, !0);const u = new Di(i.x - r.x, i.y - r.y, i.width, i.height);G_(t.viewChildren || [], (t) => {
        e(t, u, n, o, a + 1);
      });
    }(_, new Di(-s.x, -s.y, o, a), g, p, 0));
  } };function X_(t, e, i, n, o, a) {
    let r = t.children || []; let s = n.sort;'asc' !== s && 'desc' !== s && (s = null);const l = null != n.leafDepth && n.leafDepth <= a;if (o && !l) return t.viewChildren = [];!(function (t, n) {
      n && t.sort((t, e) => {
        const i = 'asc' === n ? t.getValue() - e.getValue() : e.getValue() - t.getValue();return 0 == i ? 'asc' === n ? t.dataIndex - e.dataIndex : e.dataIndex - t.dataIndex : i;
      });
    }(r = M(r, t => !t.isRemoved()), s));const u = (function (t, e, i) {
      for (var n = 0, o = 0, a = e.length;o < a;o++)n += e[o].getValue();const r = t.get('visualDimension');if (e && e.length) if ('value' === r && i)s = [e[e.length - 1].getValue(), e[0].getValue()], 'asc' === i && s.reverse();else {
        var s = [1 / 0, -1 / 0];G_(e, (t) => {
          const e = t.getValue(r);e < s[0] && (s[0] = e), e > s[1] && (s[1] = e);
        });
      } else s = [NaN, NaN];return { sum: n, dataExtent: s };
    }(e, r, s));if (0 === u.sum) return t.viewChildren = [];if (u.sum = (function (t, e, i, n, o) {
      if (!n) return i;for (var a = t.get('visibleMin'), r = o.length, s = r, l = r - 1;0 <= l;l--) {
        const u = o['asc' === n ? r - l - 1 : l].getValue();u / i * e < a && (s = l, i -= u);
      } return 'asc' === n ? o.splice(0, r - s) : o.splice(s, r - s), i;
    }(e, i, u.sum, s, r)), 0 === u.sum) return t.viewChildren = [];for (let h = 0, c = r.length;h < c;h++) {
      const d = r[h].getValue() / u.sum * i;r[h].setLayout({ area: d });
    } return l && (r.length && t.setLayout({ isLeafRoot: !0 }, !0), r.length = 0), t.viewChildren = r, t.setLayout({ dataExtent: u.dataExtent }, !0), r;
  } function Y_(t, e, i) {
    for (var n, o = 0, a = 1 / 0, r = 0, s = t.length;r < s;r++)(n = t[r].getLayout().area) && (n < a && (a = n), o < n && (o = n));const l = t.area * t.area; const u = e * e * i;return l ? z_(u * o / l, l / (u * a)) : 1 / 0;
  } function j_(t, e, i, n, o) {
    const a = e === i.width ? 0 : 1; const r = 1 - a; const s = ['x', 'y']; const l = ['width', 'height']; let u = i[s[a]]; let h = e ? t.area / e : 0;(o || h > i[l[r]]) && (h = i[l[r]]);for (let c = 0, d = t.length;c < d;c++) {
      const f = t[c]; const p = {}; const g = h ? f.getLayout().area / h : 0; const m = p[l[r]] = z_(h - 2 * n, 0); const v = i[s[a]] + i[l[a]] - u; const y = c === d - 1 || v < g ? v : g; const x = p[l[a]] = z_(y - 2 * n, 0);p[s[r]] = i[s[r]] + B_(n, m / 2), p[s[a]] = u + B_(n, x / 2), u += y, f.setLayout(p, !0);
    }i[s[r]] += h, i[l[r]] -= h;
  } function q_(t) {
    return t.get(H_) ? t.get(Z_) : 0;
  } function K_(t) {
    return `_EC_${t}`;
  }Sf(L_), bf(U_);function $_(t) {
    this._directed = t || !1, this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this.data, this.edgeData;
  } const J_ = $_.prototype;function Q_(t, e) {
    this.id = null == t ? '' : t, this.inEdges = [], this.outEdges = [], this.edges = [], this.hostGraph, this.dataIndex = null == e ? -1 : e;
  } function tw(t, e, i) {
    this.node1 = t, this.node2 = e, this.dataIndex = null == i ? -1 : i;
  }J_.type = 'graph', J_.isDirected = function () {
    return this._directed;
  }, J_.addNode = function (t, e) {
    t = null == t ? `${e}` : `${t}`;const i = this._nodesMap;if (!i[K_(t)]) {
      const n = new Q_(t, e);return (n.hostGraph = this).nodes.push(n), i[K_(t)] = n;
    }
  }, J_.getNodeByIndex = function (t) {
    const e = this.data.getRawIndex(t);return this.nodes[e];
  }, J_.getNodeById = function (t) {
    return this._nodesMap[K_(t)];
  }, J_.addEdge = function (t, e, i) {
    const n = this._nodesMap; const o = this._edgesMap;if ('number' === typeof t && (t = this.nodes[t]), 'number' === typeof e && (e = this.nodes[e]), Q_.isInstance(t) || (t = n[K_(t)]), Q_.isInstance(e) || (e = n[K_(e)]), t && e) {
      const a = `${t.id}-${e.id}`; const r = new tw(t, e, i);return (r.hostGraph = this)._directed && (t.outEdges.push(r), e.inEdges.push(r)), t.edges.push(r), t !== e && e.edges.push(r), this.edges.push(r), o[a] = r;
    }
  }, J_.getEdgeByIndex = function (t) {
    const e = this.edgeData.getRawIndex(t);return this.edges[e];
  }, J_.getEdge = function (t, e) {
    Q_.isInstance(t) && (t = t.id), Q_.isInstance(e) && (e = e.id);const i = this._edgesMap;return this._directed ? i[`${t}-${e}`] : i[`${t}-${e}`] || i[`${e}-${t}`];
  }, J_.eachNode = function (t, e) {
    for (let i = this.nodes, n = i.length, o = 0;o < n;o++)0 <= i[o].dataIndex && t.call(e, i[o], o);
  }, J_.eachEdge = function (t, e) {
    for (let i = this.edges, n = i.length, o = 0;o < n;o++)0 <= i[o].dataIndex && 0 <= i[o].node1.dataIndex && 0 <= i[o].node2.dataIndex && t.call(e, i[o], o);
  }, J_.breadthFirstTraverse = function (t, e, i, n) {
    if (Q_.isInstance(e) || (e = this._nodesMap[K_(e)]), e) {
      for (var o = 'out' === i ? 'outEdges' : 'in' === i ? 'inEdges' : 'edges', a = 0;a < this.nodes.length;a++) this.nodes[a].__visited = !1;if (!t.call(n, e, null)) for (let r = [e];r.length;) {
        const s = r.shift(); const l = s[o];for (a = 0;a < l.length;a++) {
          const u = l[a]; const h = u.node1 === s ? u.node2 : u.node1;if (!h.__visited) {
            if (t.call(n, h, s)) return;r.push(h), h.__visited = !0;
          }
        }
      }
    }
  }, J_.update = function () {
    for (var t = this.data, i = this.edgeData, e = this.nodes, n = this.edges, o = 0, a = e.length;o < a;o++)e[o].dataIndex = -1;for (o = 0, a = t.count();o < a;o++)e[t.getRawIndex(o)].dataIndex = o;i.filterSelf((t) => {
      const e = n[i.getRawIndex(t)];return 0 <= e.node1.dataIndex && 0 <= e.node2.dataIndex;
    });for (o = 0, a = n.length;o < a;o++)n[o].dataIndex = -1;for (o = 0, a = i.count();o < a;o++)n[i.getRawIndex(o)].dataIndex = o;
  }, J_.clone = function () {
    for (var t = new $_(this._directed), e = this.nodes, i = this.edges, n = 0;n < e.length;n++)t.addNode(e[n].id, e[n].dataIndex);for (n = 0;n < i.length;n++) {
      const o = i[n];t.addEdge(o.node1.id, o.node2.id, o.dataIndex);
    } return t;
  }, Q_.prototype = { constructor: Q_, degree() {
    return this.edges.length;
  }, inDegree() {
    return this.inEdges.length;
  }, outDegree() {
    return this.outEdges.length;
  }, getModel(t) {
    if (!(this.dataIndex < 0)) return this.hostGraph.data.getItemModel(this.dataIndex).getModel(t);
  } }, tw.prototype.getModel = function (t) {
    if (!(this.dataIndex < 0)) return this.hostGraph.edgeData.getItemModel(this.dataIndex).getModel(t);
  };function ew(i, n) {
    return { getValue(t) {
      const e = this[i][n];return e.get(e.getDimension(t || 'value'), this.dataIndex);
    }, setVisual(t, e) {
      0 <= this.dataIndex && this[i][n].setItemVisual(this.dataIndex, t, e);
    }, getVisual(t, e) {
      return this[i][n].getItemVisual(this.dataIndex, t, e);
    }, setLayout(t, e) {
      0 <= this.dataIndex && this[i][n].setItemLayout(this.dataIndex, t, e);
    }, getLayout() {
      return this[i][n].getItemLayout(this.dataIndex);
    }, getGraphicEl() {
      return this[i][n].getItemGraphicEl(this.dataIndex);
    }, getRawIndex() {
      return this[i][n].getRawIndex(this.dataIndex);
    } };
  }b(Q_, ew('hostGraph', 'data')), b(tw, ew('hostGraph', 'edgeData')), $_.Node = Q_, $_.Edge = tw, ra(Q_), ra(tw);function iw(t, e, i, n, o) {
    for (var a = new $_(n), r = 0;r < t.length;r++)a.addNode(W(t[r].id, t[r].name, r), r);const s = []; const l = []; let u = 0;for (r = 0;r < e.length;r++) {
      const h = e[r]; const c = h.source; const d = h.target;a.addEdge(c, d, u) && (l.push(h), s.push(W(h.id, `${c} > ${d}`)), u++);
    } let f; const p = i.get('coordinateSystem');if ('cartesian2d' === p || 'polar' === p)f = gp(t, i);else {
      const g = lh.get(p); const m = g && 'view' !== g.type && g.dimensions || [];_(m, 'value') < 0 && m.concat(['value']);const v = lp(t, { coordDimensions: m });(f = new Yf(v, i)).initData(t);
    } const y = new Yf(['value'], i);return y.initData(l, s), o && o(f, y), yx({ mainData: f, struct: a, structAttr: 'graph', datas: { node: f, edge: y }, datasAttr: { node: 'data', edge: 'edgeData' } }), a.update(), a;
  } const nw = '--\x3e'; const ow = function (t) {
    return t.get('autoCurveness') || null;
  }; const aw = function (t, e) {
    const i = ow(t); let n = 20; let o = [];if ('number' === typeof i)n = i;else if (L(i)) return void(t.__curvenessList = i);n < e && (n = e);const a = n % 2 ? n + 2 : n + 3;o = [];for (let r = 0;r < a;r++)o.push((r % 2 ? r + 1 : r) / 10 * (r % 2 ? -1 : 1));t.__curvenessList = o;
  }; const rw = function (t, e, i) {
    const n = [t.id, t.dataIndex].join('.'); const o = [e.id, e.dataIndex].join('.');return [i.uid, n, o].join(nw);
  }; const sw = function (t) {
    const e = t.split(nw);return [e[0], e[2], e[1]].join(nw);
  }; const lw = function (t, e) {
    const i = rw(t.node1, t.node2, e);return e.__edgeMap[i];
  }; const uw = function (t, e) {
    return hw(rw(t.node1, t.node2, e), e) + hw(rw(t.node2, t.node1, e), e);
  }; var hw = function (t, e) {
    const i = e.__edgeMap;return i[t] ? i[t].length : 0;
  };function cw(t, e, i, n) {
    const o = ow(e); const a = L(o);if (!o) return null;const r = lw(t, e);if (!r) return null;for (var s = -1, l = 0;l < r.length;l++) if (r[l] === i) {
      s = l;break;
    } const u = uw(t, e);aw(e, u), t.lineStyle = t.lineStyle || {};const h = rw(t.node1, t.node2, e); const c = e.__curvenessList; const d = a ? 0 : u % 2 ? 0 : 1;if (r.isForward) return c[d + s];const f = sw(h); const p = hw(f, e); const g = c[s + p + d];return n ? a ? o && 0 === o[0] ? (p + d) % 2 ? g : -g : ((p % 2 ? 0 : 1) + d) % 2 ? g : -g : (p + d) % 2 ? g : -g : c[s + p + d];
  } var dw = Df({ type: 'series.graph', init(t) {
    dw.superApply(this, 'init', arguments);const e = this;function i() {
      return e._categoriesData;
    } this.legendVisualProvider = new qv(i, i), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
  }, mergeOption(t) {
    dw.superApply(this, 'mergeOption', arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
  }, mergeDefaultAndTheme(t) {
    dw.superApply(this, 'mergeDefaultAndTheme', arguments), Go(t, ['edgeLabel'], ['show']);
  }, getInitialData(t, s) {
    const e = t.edges || t.links || []; const i = t.data || t.nodes || []; const l = this;if (i && e) {
      !(function (t) {
        ow(t) && (t.__curvenessList = [], t.__edgeMap = {}, aw(t));
      }(this));const n = iw(i, e, this, !0, (t, e) => {
        t.wrapMethod('getItemModel', (t) => {
          const e = l._categoriesModels[t.getShallow('category')];return e && (e.parentModel = t.parentModel, t.parentModel = e), t;
        });const i = l.getModel('edgeLabel'); const n = new Cl({ label: i.option }, i.parentModel, s); const o = l.getModel('emphasis.edgeLabel'); const a = new Cl({ emphasis: { label: o.option } }, o.parentModel, s);function r(t) {
          return (t = this.parsePath(t)) && 'label' === t[0] ? n : t && 'emphasis' === t[0] && 'label' === t[1] ? a : this.parentModel;
        }e.wrapMethod('getItemModel', t => (t.customizeGetParent(r), t));
      });return R(n.edges, function (t) {
        !(function (t, e, i, n) {
          if (ow(i)) {
            const o = rw(t, e, i); const a = i.__edgeMap; const r = a[sw(o)];a[o] && !r ? a[o].isForward = !0 : r && a[o] && (r.isForward = !0, a[o].isForward = !1), a[o] = a[o] || [], a[o].push(n);
          }
        }(t.node1, t.node2, this, t.dataIndex));
      }, this), n.data;
    }
  }, getGraph() {
    return this.getData().graph;
  }, getEdgeData() {
    return this.getGraph().edgeData;
  }, getCategoriesData() {
    return this._categoriesData;
  }, formatTooltip(t, e, i) {
    if ('edge' !== i) return dw.superApply(this, 'formatTooltip', arguments);const n = this.getData(); const o = this.getDataParams(t, i); const a = n.graph.getEdgeByIndex(t); const r = n.getName(a.node1.dataIndex); const s = n.getName(a.node2.dataIndex); let l = [];return null != r && l.push(r), null != s && l.push(s), l = au(l.join(' > ')), o.value && (l += ` : ${au(o.value)}`), l;
  }, _updateCategoriesData() {
    const t = O(this.option.categories || [], t => (null != t.value ? t : P({ value: 0 }, t))); const e = new Yf(['value'], this);e.initData(t), this._categoriesData = e, this._categoriesModels = e.mapArray(t => e.getItemModel(t, !0));
  }, setZoom(t) {
    this.option.zoom = t;
  }, setCenter(t) {
    this.option.center = t;
  }, isAnimationEnabled() {
    return dw.superCall(this, 'isAnimationEnabled') && !('force' === this.get('layout') && this.get('force.layoutAnimation'));
  }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: 'view', legendHoverLink: !0, hoverAnimation: !0, layout: null, focusNodeAdjacency: !1, circular: { rotateLabel: !1 }, force: { initLayout: null, repulsion: [0, 50], gravity: .1, friction: .6, edgeLength: 30, layoutAnimation: !0 }, left: 'center', top: 'center', symbol: 'circle', symbolSize: 10, edgeSymbol: ['none', 'none'], edgeSymbolSize: 10, edgeLabel: { position: 'middle', distance: 5 }, draggable: !1, roam: !1, center: null, zoom: 1, nodeScaleRatio: .6, label: { show: !1, formatter: '{b}' }, itemStyle: {}, lineStyle: { color: '#aaa', width: 1, opacity: .5 }, emphasis: { label: { show: !0 } } } }); const fw = ls.prototype; const pw = ds.prototype;function gw(t) {
    return isNaN(+t.cpx1) || isNaN(+t.cpy1);
  } const mw = Cs({ type: 'ec-line', style: { stroke: '#000', fill: null }, shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1, cpx1: null, cpy1: null }, buildPath(t, e) {
    this[gw(e) ? '_buildPathLine' : '_buildPathCurve'](t, e);
  }, _buildPathLine: fw.buildPath, _buildPathCurve: pw.buildPath, pointAt(t) {
    return this[gw(this.shape) ? '_pointAtLine' : '_pointAtCurve'](t);
  }, _pointAtLine: fw.pointAt, _pointAtCurve: pw.pointAt, tangentAt(t) {
    const e = this.shape; const i = gw(e) ? [e.x2 - e.x1, e.y2 - e.y1] : this._tangentAtCurve(t);return mt(i, i);
  }, _tangentAtCurve: pw.tangentAt }); const vw = ['fromSymbol', 'toSymbol'];function yw(t) {
    return `_${t}Type`;
  } function xw(t, e, i) {
    const n = e.getItemVisual(i, t);if (n && 'none' !== n) {
      const o = e.getItemVisual(i, 'color'); let a = e.getItemVisual(i, `${t}Size`); const r = e.getItemVisual(i, `${t}Rotate`);L(a) || (a = [a, a]);const s = wg(n, -a[0] / 2, -a[1] / 2, a[0], a[1], o);return s.__specifiedRotation = null == r || isNaN(r) ? void 0 : +r * Math.PI / 180 || 0, s.name = t, s;
    }
  } function _w(t, e) {
    t.x1 = e[0][0], t.y1 = e[0][1], t.x2 = e[1][0], t.y2 = e[1][1], t.percent = 1;const i = e[2];i ? (t.cpx1 = i[0], t.cpy1 = i[1]) : (t.cpx1 = NaN, t.cpy1 = NaN);
  } function ww(t, e, i) {
    Ci.call(this), this._createLine(t, e, i);
  } const bw = ww.prototype;function Sw(t) {
    this._ctor = t || ww, this.group = new Ci;
  }bw.beforeUpdate = function () {
    const t = this.childOfName('fromSymbol'); const e = this.childOfName('toSymbol'); const i = this.childOfName('label');if (t || e || !i.ignore) {
      for (var n = 1, o = this.parent;o;)o.scale && (n /= o.scale[0]), o = o.parent;const a = this.childOfName('line');if (this.__dirty || a.__dirty) {
        const r = a.shape.percent; const s = a.pointAt(0); const l = a.pointAt(r); const u = ht([], l, s);if (mt(u, u), t) {
          if (t.attr('position', s), null == (c = t.__specifiedRotation)) {
            var h = a.tangentAt(0);t.attr('rotation', Math.PI / 2 - Math.atan2(h[1], h[0]));
          } else t.attr('rotation', c);t.attr('scale', [n * r, n * r]);
        } if (e) {
          var c;if (e.attr('position', l), null == (c = e.__specifiedRotation)) {
            h = a.tangentAt(1);e.attr('rotation', -Math.PI / 2 - Math.atan2(h[1], h[0]));
          } else e.attr('rotation', c);e.attr('scale', [n * r, n * r]);
        } if (!i.ignore) {
          let d; let f; let p; let g;i.attr('position', l);const m = i.__labelDistance; const v = m[0] * n; const y = m[1] * n; const x = r / 2; const _ = [(h = a.tangentAt(x))[1], -h[0]]; const w = a.pointAt(x);0 < _[1] && (_[0] = -_[0], _[1] = -_[1]);let b; const S = h[0] < 0 ? -1 : 1;if ('start' !== i.__position && 'end' !== i.__position) {
            let M = -Math.atan2(h[1], h[0]);l[0] < s[0] && (M = Math.PI + M), i.attr('rotation', M);
          } switch (i.__position) {
            case 'insideStartTop':case 'insideMiddleTop':case 'insideEndTop':case 'middle':b = -y, p = 'bottom';break;case 'insideStartBottom':case 'insideMiddleBottom':case 'insideEndBottom':b = y, p = 'top';break;default:b = 0, p = 'middle';
          } switch (i.__position) {
            case 'end':d = [u[0] * v + l[0], u[1] * y + l[1]], f = .8 < u[0] ? 'left' : u[0] < -.8 ? 'right' : 'center', p = .8 < u[1] ? 'top' : u[1] < -.8 ? 'bottom' : 'middle';break;case 'start':d = [-u[0] * v + s[0], -u[1] * y + s[1]], f = .8 < u[0] ? 'right' : u[0] < -.8 ? 'left' : 'center', p = .8 < u[1] ? 'bottom' : u[1] < -.8 ? 'top' : 'middle';break;case 'insideStartTop':case 'insideStart':case 'insideStartBottom':d = [v * S + s[0], s[1] + b], f = h[0] < 0 ? 'right' : 'left', g = [-v * S, -b];break;case 'insideMiddleTop':case 'insideMiddle':case 'insideMiddleBottom':case 'middle':d = [w[0], w[1] + b], f = 'center', g = [0, -b];break;case 'insideEndTop':case 'insideEnd':case 'insideEndBottom':d = [-v * S + l[0], l[1] + b], f = 0 <= h[0] ? 'right' : 'left', g = [v * S, -b];
          }i.attr({ style: { textVerticalAlign: i.__verticalAlign || p, textAlign: i.__textAlign || f }, position: d, scale: [n, n], origin: g });
        }
      }
    }
  }, bw._createLine = function (i, n, t) {
    const e = i.hostModel; const o = (function (t) {
      const e = new mw({ name: 'line', subPixelOptimize: !0 });return _w(e.shape, t), e;
    }(i.getItemLayout(n)));o.shape.percent = 0, dl(o, { shape: { percent: 1 } }, e, n), this.add(o);const a = new Ur({ name: 'label', lineLabelOriginalOpacity: 1 });this.add(a), R(vw, function (t) {
      const e = xw(t, i, n);this.add(e), this[yw(t)] = i.getItemVisual(n, t);
    }, this), this._updateCommonStl(i, n, t);
  }, bw.updateData = function (o, a, t) {
    const e = o.hostModel; const i = this.childOfName('line'); const n = o.getItemLayout(a); const r = { shape: {} };_w(r.shape, n), cl(i, r, e, a), R(vw, function (t) {
      const e = o.getItemVisual(a, t); const i = yw(t);if (this[i] !== e) {
        this.remove(this.childOfName(t));const n = xw(t, o, a);this.add(n);
      } this[i] = e;
    }, this), this._updateCommonStl(o, a, t);
  }, bw._updateCommonStl = function (t, e, i) {
    const n = t.hostModel; const o = this.childOfName('line'); let a = i && i.lineStyle; let r = i && i.hoverLineStyle; let s = i && i.labelModel; let l = i && i.hoverLabelModel;if (!i || t.hasItemOption) {
      const u = t.getItemModel(e);a = u.getModel('lineStyle').getLineStyle(), r = u.getModel('emphasis.lineStyle').getLineStyle(), s = u.getModel('label'), l = u.getModel('emphasis.label');
    } const h = t.getItemVisual(e, 'color'); const c = Z(t.getItemVisual(e, 'opacity'), a.opacity, 1);o.useStyle(D({ strokeNoScale: !0, fill: 'none', stroke: h, opacity: c }, a)), o.hoverStyle = r, R(vw, function (t) {
      const e = this.childOfName(t);e && (e.setColor(h), e.setStyle({ opacity: c }));
    }, this);let d; let f; const p = s.getShallow('show'); const g = l.getShallow('show'); const m = this.childOfName('label');if ((p || g) && (d = h || '#000', null == (f = n.getFormattedLabel(e, 'normal', t.dataType)))) {
      const v = n.getRawValue(e);f = null == v ? t.getName(e) : isFinite(v) ? zl(v) : v;
    } const y = p ? f : null; const x = g ? H(n.getFormattedLabel(e, 'emphasis', t.dataType), f) : null; const _ = m.style;if (null != y || null != x) {
      nl(m.style, s, { text: y }, { autoColor: d }), m.__textAlign = _.textAlign, m.__verticalAlign = _.textVerticalAlign, m.__position = s.get('position') || 'middle';let w = s.get('distance');L(w) || (w = [w, w]), m.__labelDistance = w;
    }m.hoverStyle = null != x ? { text: x, textFill: l.getTextColor(!0), fontStyle: l.getShallow('fontStyle'), fontWeight: l.getShallow('fontWeight'), fontSize: l.getShallow('fontSize'), fontFamily: l.getShallow('fontFamily') } : { text: null }, m.ignore = !p && !g, $s(this);
  }, bw.highlight = function () {
    this.trigger('emphasis');
  }, bw.downplay = function () {
    this.trigger('normal');
  }, bw.updateLayout = function (t, e) {
    this.setLinePoints(t.getItemLayout(e));
  }, bw.setLinePoints = function (t) {
    const e = this.childOfName('line');_w(e.shape, t), e.dirty();
  }, w(ww, Ci);const Mw = Sw.prototype;function Iw(t) {
    const e = t.hostModel;return { lineStyle: e.getModel('lineStyle').getLineStyle(), hoverLineStyle: e.getModel('emphasis.lineStyle').getLineStyle(), labelModel: e.getModel('label'), hoverLabelModel: e.getModel('emphasis.label') };
  } function Tw(t) {
    return isNaN(t[0]) || isNaN(t[1]);
  } function Aw(t) {
    return !Tw(t[0]) && !Tw(t[1]);
  } function Dw(t) {
    const e = t.coordinateSystem;if ('view' !== e.type) return 1;const i = t.option.nodeScaleRatio; const n = e.scale; const o = n && n[0] || 1;return ((e.getZoom() - 1) * i + 1) / o;
  } function Cw(t) {
    let e = t.getVisual('symbolSize');return e instanceof Array && (e = (e[0] + e[1]) / 2), +e;
  }Mw.isPersistent = function () {
    return !0;
  }, Mw.updateData = function (i) {
    const n = this; const e = n.group; const o = n._lineData;n._lineData = i, o || e.removeAll();const a = Iw(i);i.diff(o).add((t) => {
      !(function (t, e, i, n) {
        if (!Aw(e.getItemLayout(i))) return;const o = new t._ctor(e, i, n);e.setItemGraphicEl(i, o), t.group.add(o);
      }(n, i, t, a));
    })
      .update((t, e) => {
        !(function (t, e, i, n, o, a) {
          let r = e.getItemGraphicEl(n);if (!Aw(i.getItemLayout(o))) return t.group.remove(r);r ? r.updateData(i, o, a) : r = new t._ctor(i, o, a);i.setItemGraphicEl(o, r), t.group.add(r);
        }(n, o, i, e, t, a));
      })
      .remove((t) => {
        e.remove(o.getItemGraphicEl(t));
      })
      .execute();
  }, Mw.updateLayout = function () {
    const i = this._lineData;i && i.eachItemGraphicEl((t, e) => {
      t.updateLayout(i, e);
    }, this);
  }, Mw.incrementalPrepareUpdate = function (t) {
    this._seriesScope = Iw(t), this._lineData = null, this.group.removeAll();
  }, Mw.incrementalUpdate = function (t, e) {
    function i(t) {
      t.isGroup || (function (t) {
        return t.animators && 0 < t.animators.length;
      }(t)) || (t.incremental = t.useHoverLayer = !0);
    } for (let n = t.start;n < t.end;n++) {
      if (Aw(e.getItemLayout(n))) {
        const o = new this._ctor(e, n, this._seriesScope);o.traverse(i), this.group.add(o), e.setItemGraphicEl(n, o);
      }
    }
  }, Mw.remove = function () {
    this._clearIncremental(), this._incremental = null, this.group.removeAll();
  }, Mw._clearIncremental = function () {
    const t = this._incremental;t && t.clearDisplaybles();
  };const Lw = []; const kw = []; const Pw = []; const Nw = La; const Ow = _t; const Rw = Math.abs;function Ew(t, e, i) {
    for (var n, o = t[0], a = t[1], r = t[2], s = 1 / 0, l = i * i, u = .1, h = .1;h <= .9;h += .1) {
      Lw[0] = Nw(o[0], a[0], r[0], h), Lw[1] = Nw(o[1], a[1], r[1], h), (f = Rw(Ow(Lw, e) - l)) < s && (s = f, n = h);
    } for (let c = 0;c < 32;c++) {
      const d = n + u;kw[0] = Nw(o[0], a[0], r[0], n), kw[1] = Nw(o[1], a[1], r[1], n), Pw[0] = Nw(o[0], a[0], r[0], d), Pw[1] = Nw(o[1], a[1], r[1], d);var f = Ow(kw, e) - l;if (Rw(f) < .01) break;const p = Ow(Pw, e) - l;u /= 2, f < 0 ? 0 <= p ? n += u : n -= u : 0 <= p ? n -= u : n += u;
    } return n;
  } function zw(t, l) {
    const u = []; const h = Na; const c = [[], [], []]; const d = [[], []]; const f = [];l /= 2, t.eachEdge((t, e) => {
      const i = t.getLayout(); const n = t.getVisual('fromSymbol'); const o = t.getVisual('toSymbol');i.__original || (i.__original = [rt(i[0]), rt(i[1])], i[2] && i.__original.push(rt(i[2])));const a = i.__original;if (null != i[2]) {
        if (at(c[0], a[0]), at(c[1], a[2]), at(c[2], a[1]), n && 'none' !== n) {
          var r = Cw(t.node1); var s = Ew(c, a[0], r * l);h(c[0][0], c[1][0], c[2][0], s, u), c[0][0] = u[3], c[1][0] = u[4], h(c[0][1], c[1][1], c[2][1], s, u), c[0][1] = u[3], c[1][1] = u[4];
        } if (o && 'none' !== o) {
          r = Cw(t.node2), s = Ew(c, a[1], r * l);h(c[0][0], c[1][0], c[2][0], s, u), c[1][0] = u[1], c[2][0] = u[2], h(c[0][1], c[1][1], c[2][1], s, u), c[1][1] = u[1], c[2][1] = u[2];
        }at(i[0], c[0]), at(i[1], c[2]), at(i[2], c[1]);
      } else {
        if (at(d[0], a[0]), at(d[1], a[1]), ht(f, d[1], d[0]), mt(f, f), n && 'none' !== n) {
          r = Cw(t.node1);ut(d[0], d[0], f, r * l);
        } if (o && 'none' !== o) {
          r = Cw(t.node2);ut(d[1], d[1], f, -r * l);
        }at(i[0], d[0]), at(i[1], d[1]);
      }
    });
  } const Bw = '__focusNodeAdjacency'; const Vw = '__unfocusNodeAdjacency'; const Gw = ['itemStyle', 'opacity']; const Fw = ['lineStyle', 'opacity'];function Ww(t, e) {
    const i = t.getVisual('opacity');return null != i ? i : t.getModel().get(e);
  } function Hw(t, e, i) {
    const n = t.getGraphicEl(); let o = Ww(t, e);null != i && (null == o && (o = 1), o *= i), n.downplay && n.downplay(), n.traverse((t) => {
      if (!t.isGroup) {
        let e = t.lineLabelOriginalOpacity;null != e && null == i || (e = o), t.setStyle('opacity', e);
      }
    });
  } function Zw(t, e) {
    const i = Ww(t, e); const n = t.getGraphicEl();n.traverse((t) => {
      t.isGroup || t.setStyle('opacity', i);
    }), n.highlight && n.highlight();
  }Cf({ type: 'graph', init(t, e) {
    const i = new im; const n = new Sw; const o = this.group;this._controller = new Vy(e.getZr()), this._controllerHost = { target: o }, o.add(i.group), o.add(n.group), this._symbolDraw = i, this._lineDraw = n, this._firstRender = !0;
  }, render(o, t, a) {
    const r = this; const e = o.coordinateSystem;this._model = o;const i = this._symbolDraw; const n = this._lineDraw; const s = this.group;if ('view' === e.type) {
      const l = { position: e.position, scale: e.scale };this._firstRender ? s.attr(l) : cl(s, l, o);
    }zw(o.getGraph(), Dw(o));const u = o.getData();i.updateData(u);const h = o.getEdgeData();n.updateData(h), this._updateNodeAndLinkScale(), this._updateController(o, t, a), clearTimeout(this._layoutTimeout);const c = o.forceLayout; const d = o.get('force.layoutAnimation');c && this._startForceLayoutIteration(c, d), u.eachItemGraphicEl(function (t, e) {
      const i = u.getItemModel(e);t.off('drag').off('dragend');const n = i.get('draggable');n && t.on('drag', function () {
        c && (c.warmUp(), this._layouting || this._startForceLayoutIteration(c, d), c.setFixed(e), u.setItemLayout(e, t.position));
      }, this).on('dragend', () => {
        c && c.setUnfixed(e);
      }, this), t.setDraggable(n && c), t[Bw] && t.off('mouseover', t[Bw]), t[Vw] && t.off('mouseout', t[Vw]), i.get('focusNodeAdjacency') && (t.on('mouseover', t[Bw] = function () {
        r._clearTimer(), a.dispatchAction({ type: 'focusNodeAdjacency', seriesId: o.id, dataIndex: t.dataIndex });
      }), t.on('mouseout', t[Vw] = function () {
        r._dispatchUnfocus(a);
      }));
    }, this), u.graph.eachEdge((t) => {
      const e = t.getGraphicEl();e[Bw] && e.off('mouseover', e[Bw]), e[Vw] && e.off('mouseout', e[Vw]), t.getModel().get('focusNodeAdjacency') && (e.on('mouseover', e[Bw] = function () {
        r._clearTimer(), a.dispatchAction({ type: 'focusNodeAdjacency', seriesId: o.id, edgeDataIndex: t.dataIndex });
      }), e.on('mouseout', e[Vw] = function () {
        r._dispatchUnfocus(a);
      }));
    });const f = 'circular' === o.get('layout') && o.get('circular.rotateLabel'); const p = u.getLayout('cx'); const g = u.getLayout('cy');u.eachItemGraphicEl((t, e) => {
      let i = u.getItemModel(e).get('label.rotate') || 0; const n = t.getSymbolPath();if (f) {
        const o = u.getItemLayout(e); let a = Math.atan2(o[1] - g, o[0] - p);a < 0 && (a = 2 * Math.PI + a);const r = o[0] < p;r && (a -= Math.PI);const s = r ? 'left' : 'right';il(n, { textRotation: -a, textPosition: s, textOrigin: 'center' }, { textPosition: s });
      } else il(n, { textRotation: i *= Math.PI / 180 });
    }), this._firstRender = !1;
  }, dispose() {
    this._controller && this._controller.dispose(), this._controllerHost = {}, this._clearTimer();
  }, _dispatchUnfocus(t, e) {
    const i = this;this._clearTimer(), this._unfocusDelayTimer = setTimeout(() => {
      i._unfocusDelayTimer = null, t.dispatchAction({ type: 'unfocusNodeAdjacency', seriesId: i._model.id });
    }, 500);
  }, _clearTimer() {
    this._unfocusDelayTimer && (clearTimeout(this._unfocusDelayTimer), this._unfocusDelayTimer = null);
  }, focusNodeAdjacency(t, e, i, n) {
    const o = t.getData().graph; const a = n.dataIndex; const r = n.edgeDataIndex; const s = o.getNodeByIndex(a); const l = o.getEdgeByIndex(r);(s || l) && (o.eachNode((t) => {
      Hw(t, Gw, .1);
    }), o.eachEdge((t) => {
      Hw(t, Fw, .1);
    }), s && (Zw(s, Gw), R(s.edges, (t) => {
      t.dataIndex < 0 || (Zw(t, Fw), Zw(t.node1, Gw), Zw(t.node2, Gw));
    })), l && (Zw(l, Fw), Zw(l.node1, Gw), Zw(l.node2, Gw)));
  }, unfocusNodeAdjacency(t, e, i, n) {
    const o = t.getData().graph;o.eachNode((t) => {
      Hw(t, Gw);
    }), o.eachEdge((t) => {
      Hw(t, Fw);
    });
  }, _startForceLayoutIteration(t, i) {
    const n = this;!(function e() {
      t.step((t) => {
        n.updateLayout(n._model), (n._layouting = !t) && (i ? n._layoutTimeout = setTimeout(e, 16) : e());
      });
    }());
  }, _updateController(o, t, a) {
    const e = this._controller; const i = this._controllerHost; const r = this.group;e.setPointerChecker((t, e, i) => {
      const n = r.getBoundingRect();return n.applyTransform(r.transform), n.contain(e, i) && !$y(t, a, o);
    }), 'view' === o.coordinateSystem.type ? (e.enable(o.get('roam')), i.zoomLimit = o.get('scaleLimit'), i.zoom = o.coordinateSystem.getZoom(), e.off('pan').off('zoom')
      .on('pan', (t) => {
        jy(i, t.dx, t.dy), a.dispatchAction({ seriesId: o.id, type: 'graphRoam', dx: t.dx, dy: t.dy });
      })
      .on('zoom', function (t) {
        qy(i, t.scale, t.originX, t.originY), a.dispatchAction({ seriesId: o.id, type: 'graphRoam', zoom: t.scale, originX: t.originX, originY: t.originY }), this._updateNodeAndLinkScale(), zw(o.getGraph(), Dw(o)), this._lineDraw.updateLayout();
      }, this)) : e.disable();
  }, _updateNodeAndLinkScale() {
    const t = this._model; const e = t.getData(); const i = Dw(t); const n = [i, i];e.eachItemGraphicEl((t, e) => {
      t.attr('scale', n);
    });
  }, updateLayout(t) {
    zw(t.getGraph(), Dw(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
  }, remove(t, e) {
    this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
  } }), _f({ type: 'focusNodeAdjacency', event: 'focusNodeAdjacency', update: 'series:focusNodeAdjacency' }, () => {}), _f({ type: 'unfocusNodeAdjacency', event: 'unfocusNodeAdjacency', update: 'series:unfocusNodeAdjacency' }, () => {});_f({ type: 'graphRoam', event: 'graphRoam', update: 'none' }, (i, t) => {
    t.eachComponent({ mainType: 'series', query: i }, (t) => {
      const e = ax(t.coordinateSystem, i);t.setCenter && t.setCenter(e.center), t.setZoom && t.setZoom(e.zoom);
    });
  });function Uw(t) {
    return t instanceof Array || (t = [t, t]), t;
  } function Xw(t) {
    const e = t.coordinateSystem;if (!e || 'view' === e.type) {
      const i = t.getGraph();i.eachNode((t) => {
        const e = t.getModel();t.setLayout([+e.get('x'), +e.get('y')]);
      }), Yw(i, t);
    }
  } function Yw(t, r) {
    t.eachEdge((t, e) => {
      const i = Z(t.getModel().get('lineStyle.curveness'), -cw(t, r, e, !0), 0); const n = rt(t.node1.getLayout()); const o = rt(t.node2.getLayout()); const a = [n, o];+i && a.push([(n[0] + o[0]) / 2 - (n[1] - o[1]) * i, (n[1] + o[1]) / 2 - (o[0] - n[0]) * i]), t.setLayout(a);
    });
  } const jw = Math.PI; const qw = [];function Kw(l, t) {
    const e = l.coordinateSystem;if (!e || 'view' === e.type) {
      const i = e.getBoundingRect(); const n = l.getData(); const o = n.graph; const u = i.width / 2 + i.x; const h = i.height / 2 + i.y; const a = Math.min(i.width, i.height) / 2; const r = n.count();n.setLayout({ cx: u, cy: h }), r && ($w[t](l, e, o, n, a, u, h, r), o.eachEdge((t, e) => {
        let i; let n = Z(t.getModel().get('lineStyle.curveness'), cw(t, l, e), 0); const o = rt(t.node1.getLayout()); const a = rt(t.node2.getLayout()); const r = (o[0] + a[0]) / 2; const s = (o[1] + a[1]) / 2;+n && (i = [u * (n *= 3) + r * (1 - n), h * n + s * (1 - n)]), t.setLayout([o, a, i]);
      }));
    }
  } var $w = { value(t, e, i, n, o, a, r, s) {
    let l = 0; const u = n.getSum('value'); const h = 2 * Math.PI / (u || s);i.eachNode((t) => {
      const e = t.getValue('value'); const i = h * (u ? e : 1) / 2;l += i, t.setLayout([o * Math.cos(l) + a, o * Math.sin(l) + r]), l += i;
    });
  }, symbolSize(t, e, i, n, o, a, r, s) {
    let l = 0;qw.length = s;const u = Dw(t);i.eachNode((t) => {
      let e = Cw(t);isNaN(e) && (e = 2), e < 0 && (e = 0), e *= u;let i = Math.asin(e / 2 / o);isNaN(i) && (i = jw / 2), qw[t.dataIndex] = i, l += 2 * i;
    });const h = (2 * jw - l) / s / 2; let c = 0;i.eachNode((t) => {
      const e = h + qw[t.dataIndex];c += e, t.setLayout([o * Math.cos(c) + a, o * Math.sin(c) + r]), c += e;
    });
  } }; const Jw = ut;xf(function (t) {
    const a = t.findComponents({ mainType: 'legend' });a && a.length && t.eachSeriesByType('graph', (t) => {
      const e = t.getCategoriesData(); const n = t.getGraph().data; const o = e.mapArray(e.getName);n.filterSelf((t) => {
        let e = n.getItemModel(t).getShallow('category');if (null != e) {
          'number' === typeof e && (e = o[e]);for (let i = 0;i < a.length;i++) if (!a[i].isSelected(e)) return !1;
        } return !0;
      });
    }, this);
  }), Sf(Lm('graph', 'circle', null)), Sf((t) => {
    const h = {};t.eachSeriesByType('graph', (s) => {
      const l = s.getCategoriesData(); const o = s.getData(); const u = {};l.each((t) => {
        const e = l.getName(t);u[`ec-${e}`] = t;const i = l.getItemModel(t); const n = i.get('itemStyle.color') || s.getColorFromPalette(e, h);l.setItemVisual(t, 'color', n);for (let o = ['opacity', 'symbol', 'symbolSize', 'symbolKeepAspect'], a = 0;a < o.length;a++) {
          const r = i.getShallow(o[a], !0);null != r && l.setItemVisual(t, o[a], r);
        }
      }), l.count() && o.each((t) => {
        let e = o.getItemModel(t).getShallow('category');if (null != e) {
          'string' === typeof e && (e = u[`ec-${e}`]);for (let i = ['color', 'opacity', 'symbol', 'symbolSize', 'symbolKeepAspect'], n = 0;n < i.length;n++)null == o.getItemVisual(t, i[n], !0) && o.setItemVisual(t, i[n], l.getItemVisual(e, i[n]));
        }
      });
    });
  }), Sf((t) => {
    t.eachSeriesByType('graph', (t) => {
      const s = t.getGraph(); const l = t.getEdgeData(); const e = Uw(t.get('edgeSymbol')); const i = Uw(t.get('edgeSymbolSize')); const u = 'lineStyle.color'.split('.'); const h = 'lineStyle.opacity'.split('.');l.setVisual('fromSymbol', e && e[0]), l.setVisual('toSymbol', e && e[1]), l.setVisual('fromSymbolSize', i && i[0]), l.setVisual('toSymbolSize', i && i[1]), l.setVisual('color', t.get(u)), l.setVisual('opacity', t.get(h)), l.each((t) => {
        const e = l.getItemModel(t); const i = s.getEdgeByIndex(t); const n = Uw(e.getShallow('symbol', !0)); const o = Uw(e.getShallow('symbolSize', !0)); let a = e.get(u); const r = e.get(h);switch (a) {
          case 'source':a = i.node1.getVisual('color');break;case 'target':a = i.node2.getVisual('color');
        }n[0] && i.setVisual('fromSymbol', n[0]), n[1] && i.setVisual('toSymbol', n[1]), o[0] && i.setVisual('fromSymbolSize', o[0]), o[1] && i.setVisual('toSymbolSize', o[1]), i.setVisual('color', a), i.setVisual('opacity', r);
      });
    });
  }), bf((t, e) => {
    t.eachSeriesByType('graph', (t) => {
      const e = t.get('layout'); const i = t.coordinateSystem;if (i && 'view' !== i.type) {
        const n = t.getData(); let o = [];R(i.dimensions, (t) => {
          o = o.concat(n.mapDimension(t, !0));
        });for (let a = 0;a < n.count();a++) {
          for (var r = [], s = !1, l = 0;l < o.length;l++) {
            const u = n.get(o[l], a);isNaN(u) || (s = !0), r.push(u);
          }s ? n.setItemLayout(a, i.dataToPoint(r)) : n.setItemLayout(a, [NaN, NaN]);
        }Yw(n.graph, t);
      } else e && 'none' !== e || Xw(t);
    });
  }), bf(Ld.VISUAL.POST_CHART_LAYOUT, (t) => {
    t.eachSeriesByType('graph', (t) => {
      'circular' === t.get('layout') && Kw(t, 'symbolSize');
    });
  }), bf((t) => {
    t.eachSeriesByType('graph', (r) => {
      if (!(n = r.coordinateSystem) || 'view' === n.type) if ('force' === r.get('layout')) {
        const c = r.preservedPoints || {}; const d = r.getGraph(); const f = d.data; const t = d.edgeData; const e = r.getModel('force'); const i = e.get('initLayout');r.preservedPoints ? f.each((t) => {
          const e = f.getId(t);f.setItemLayout(t, c[e] || [NaN, NaN]);
        }) : i && 'none' !== i ? 'circular' === i && Kw(r, 'value') : Xw(r);const o = f.getDataExtent('value'); const s = t.getDataExtent('value'); let a = e.get('repulsion'); let l = e.get('edgeLength');L(a) || (a = [a, a]), L(l) || (l = [l, l]), l = [l[1], l[0]];var n; const u = f.mapArray('value', (t, e) => {
          const i = f.getItemLayout(e); let n = Rl(t, o, a);return isNaN(n) && (n = (a[0] + a[1]) / 2), { w: n, rep: n, fixed: f.getItemModel(e).get('fixed'), p: !i || isNaN(i[0]) || isNaN(i[1]) ? null : i };
        }); const h = t.mapArray('value', (t, e) => {
          const i = d.getEdgeByIndex(e); let n = Rl(t, s, l);isNaN(n) && (n = (l[0] + l[1]) / 2);const o = i.getModel(); const a = Z(o.get('lineStyle.curveness'), -cw(i, r, e, !0), 0);return { n1: u[i.node1.dataIndex], n2: u[i.node2.dataIndex], d: n, curveness: a, ignoreForceLayout: o.get('ignoreForceLayout') };
        }); const p = (n = r.coordinateSystem).getBoundingRect(); const g = (function (f, p, t) {
          for (var e = t.rect, i = e.width, n = e.height, g = [e.x + i / 2, e.y + n / 2], m = null == t.gravity ? .1 : t.gravity, o = 0;o < f.length;o++) {
            const a = f[o];a.p || (a.p = ot(i * (Math.random() - .5) + g[0], n * (Math.random() - .5) + g[1])), a.pp = rt(a.p), a.edges = null;
          } const r = null == t.friction ? .6 : t.friction; let v = r;return { warmUp() {
            v = .8 * r;
          }, setFixed(t) {
            f[t].fixed = !0;
          }, setUnfixed(t) {
            f[t].fixed = !1;
          }, step(t) {
            for (var e = [], i = f.length, n = 0;n < p.length;n++) {
              const o = p[n];if (!o.ignoreForceLayout) {
                var a = o.n1;ht(e, (u = o.n2).p, a.p);var r = ct(e) - o.d; let s = u.w / (a.w + u.w);isNaN(s) && (s = 0), mt(e, e), a.fixed || Jw(a.p, a.p, e, s * r * v), u.fixed || Jw(u.p, u.p, e, -(1 - s) * r * v);
              }
            } for (n = 0;n < i;n++) {
              (d = f[n]).fixed || (ht(e, g, d.p), Jw(d.p, d.p, e, m * v));
            } for (n = 0;n < i;n++) {
              a = f[n];for (let l = n + 1;l < i;l++) {
                var u;ht(e, (u = f[l]).p, a.p), 0 === (r = ct(e)) && (st(e, Math.random() - .5, Math.random() - .5), r = 1);const h = (a.rep + u.rep) / r / r;a.fixed || Jw(a.pp, a.pp, e, h), u.fixed || Jw(u.pp, u.pp, e, -h);
              }
            } const c = [];for (n = 0;n < i;n++) {
              var d;(d = f[n]).fixed || (ht(c, d.p, d.pp), Jw(d.p, d.p, c, v), at(d.pp, d.p));
            }v *= .992, t && t(f, p, v < .01);
          } };
        }(u, h, { rect: p, gravity: e.get('gravity'), friction: e.get('friction') })); const m = g.step;g.step = function (h) {
          for (let t = 0, e = u.length;t < e;t++)u[t].fixed && at(u[t].p, d.getNodeByIndex(t).getLayout());m((t, e, i) => {
            for (var n = 0, o = t.length;n < o;n++)t[n].fixed || d.getNodeByIndex(n).setLayout(t[n].p), c[f.getId(n)] = t[n].p;for (n = 0, o = e.length;n < o;n++) {
              const a = e[n]; const r = d.getEdgeByIndex(n); const s = a.n1.p; const l = a.n2.p; let u = r.getLayout();(u = u ? u.slice() : [])[0] = u[0] || [], u[1] = u[1] || [], at(u[0], s), at(u[1], l), +a.curveness && (u[2] = [(s[0] + l[0]) / 2 - (s[1] - l[1]) * a.curveness, (s[1] + l[1]) / 2 - (l[0] - s[0]) * a.curveness]), r.setLayout(u);
            }h && h(i);
          });
        }, r.forceLayout = g, r.preservedPoints = c, g.step();
      } else r.forceLayout = null;
    });
  }), wf('graphView', { create(t, d) {
    const f = [];return t.eachSeriesByType('graph', (t) => {
      const e = t.get('coordinateSystem');if (!e || 'view' === e) {
        const i = t.getData(); let n = []; let o = [];Wa(i.mapArray((t) => {
          const e = i.getItemModel(t);return [+e.get('x'), +e.get('y')];
        }), n, o), o[0] - n[0] == 0 && (o[0] += 1, n[0] -= 1), o[1] - n[1] == 0 && (o[1] += 1, n[1] -= 1);const a = (o[0] - n[0]) / (o[1] - n[1]); const r = (function (t, e, i) {
          const n = t.getBoxLayoutParams();return n.aspect = i, bu(n, { width: e.getWidth(), height: e.getHeight() });
        }(t, d, a));isNaN(a) && (n = [r.x, r.y], o = [r.x + r.width, r.y + r.height]);const s = o[0] - n[0]; const l = o[1] - n[1]; const u = r.width; const h = r.height; const c = t.coordinateSystem = new lx;c.zoomLimit = t.get('scaleLimit'), c.setBoundingRect(n[0], n[1], s, l), c.setViewRect(r.x, r.y, u, h), c.setCenter(t.get('center')), c.setZoom(t.get('zoom')), f.push(c);
      }
    }), f;
  } });sc.extend({ type: 'series.gauge', getInitialData(t, e) {
    return Yv(this, ['value']);
  }, defaultOption: { zlevel: 0, z: 2, center: ['50%', '50%'], legendHoverLink: !0, radius: '75%', startAngle: 225, endAngle: -45, clockwise: !0, min: 0, max: 100, splitNumber: 10, axisLine: { show: !0, lineStyle: { color: [[.2, '#91c7ae'], [.8, '#63869e'], [1, '#c23531']], width: 30 } }, splitLine: { show: !0, length: 30, lineStyle: { color: '#eee', width: 2, type: 'solid' } }, axisTick: { show: !0, splitNumber: 5, length: 8, lineStyle: { color: '#eee', width: 1, type: 'solid' } }, axisLabel: { show: !0, distance: 5, color: 'auto' }, pointer: { show: !0, length: '80%', width: 8 }, itemStyle: { color: 'auto' }, title: { show: !0, offsetCenter: [0, '-40%'], color: '#333', fontSize: 15 }, detail: { show: !0, backgroundColor: 'rgba(0,0,0,0)', borderWidth: 0, borderColor: '#ccc', width: 100, height: null, padding: [5, 10], offsetCenter: [0, '40%'], color: 'auto', fontSize: 30 } } });const Qw = Ar.extend({ type: 'echartsGaugePointer', shape: { angle: 0, width: 10, r: 10, x: 0, y: 0 }, buildPath(t, e) {
    const i = Math.cos; const n = Math.sin; const o = e.r; const a = e.width; let r = e.angle; const s = e.x - i(r) * a * (o / 3 <= a ? 1 : 2); const l = e.y - n(r) * a * (o / 3 <= a ? 1 : 2);r = e.angle - Math.PI / 2, t.moveTo(s, l), t.lineTo(e.x + i(r) * a, e.y + n(r) * a), t.lineTo(e.x + i(e.angle) * o, e.y + n(e.angle) * o), t.lineTo(e.x - i(r) * a, e.y - n(r) * a), t.lineTo(s, l);
  } });function tb(t, e) {
    return e && ('string' === typeof e ? t = e.replace('{value}', null != t ? t : '') : 'function' === typeof e && (t = e(t))), t;
  } const eb = 2 * Math.PI; var ib = (_c.extend({ type: 'gauge', render(t, e, i) {
    this.group.removeAll();const n = t.get('axisLine.lineStyle.color'); const o = (function (t, e) {
      const i = t.get('center'); const n = e.getWidth(); const o = e.getHeight(); const a = Math.min(n, o);return { cx: El(i[0], e.getWidth()), cy: El(i[1], e.getHeight()), r: El(t.get('radius'), a / 2) };
    }(t, i));this._renderMain(t, e, i, n, o);
  }, dispose() {}, _renderMain(t, e, i, n, o) {
    for (var a = this.group, r = t.getModel('axisLine'), s = r.getModel('lineStyle'), l = t.get('clockwise'), u = -t.get('startAngle') / 180 * Math.PI, h = ((g = -t.get('endAngle') / 180 * Math.PI) - u) % eb, c = u, d = s.get('width'), f = r.get('show'), p = 0;f && p < n.length;p++) {
      var g; const m = Math.min(Math.max(n[p][0], 0), 1); const v = new qr({ shape: { startAngle: c, endAngle: g = u + h * m, cx: o.cx, cy: o.cy, clockwise: l, r0: o.r - d, r: o.r }, silent: !0 });v.setStyle({ fill: n[p][1] }), v.setStyle(s.getLineStyle(['color', 'borderWidth', 'borderColor'])), a.add(v), c = g;
    } function y(t) {
      if (t <= 0) return n[0][1];for (var e = 0;e < n.length;e++) if (n[e][0] >= t && (0 === e ? 0 : n[e - 1][0]) < t) return n[e][1];return n[e - 1][1];
    } if (!l) {
      const x = u;u = g, g = x;
    } this._renderTicks(t, e, i, y, o, u, g, l), this._renderPointer(t, e, i, y, o, u, g, l), this._renderTitle(t, e, i, y, o), this._renderDetail(t, e, i, y, o);
  }, _renderTicks(t, e, i, n, o, a, r, s) {
    for (let l = this.group, u = o.cx, h = o.cy, c = o.r, d = +t.get('min'), f = +t.get('max'), p = t.getModel('splitLine'), g = t.getModel('axisTick'), m = t.getModel('axisLabel'), v = t.get('splitNumber'), y = g.get('splitNumber'), x = El(p.get('length'), c), _ = El(g.get('length'), c), w = a, b = (r - a) / v, S = b / y, M = p.getModel('lineStyle').getLineStyle(), I = g.getModel('lineStyle').getLineStyle(), T = 0;T <= v;T++) {
      let A = Math.cos(w); let D = Math.sin(w);if (p.get('show')) {
        const C = new ls({ shape: { x1: A * c + u, y1: D * c + h, x2: A * (c - x) + u, y2: D * (c - x) + h }, style: M, silent: !0 });'auto' === M.stroke && C.setStyle({ stroke: n(T / v) }), l.add(C);
      } if (m.get('show')) {
        const L = tb(zl(T / v * (f - d) + d), m.get('formatter')); const k = m.get('distance'); const P = n(T / v);l.add(new Ur({ style: nl({}, m, { text: L, x: A * (c - x - k) + u, y: D * (c - x - k) + h, textVerticalAlign: D < -.4 ? 'top' : .4 < D ? 'bottom' : 'middle', textAlign: A < -.4 ? 'left' : .4 < A ? 'right' : 'center' }, { autoColor: P }), silent: !0 }));
      } if (g.get('show') && T !== v) {
        for (let N = 0;N <= y;N++) {
          A = Math.cos(w), D = Math.sin(w);const O = new ls({ shape: { x1: A * c + u, y1: D * c + h, x2: A * (c - _) + u, y2: D * (c - _) + h }, silent: !0, style: I });'auto' === I.stroke && O.setStyle({ stroke: n((T + N / y) / v) }), l.add(O), w += S;
        }w -= S;
      } else w += b;
    }
  }, _renderPointer(n, t, e, o, a, i, r, s) {
    const l = this.group; const u = this._data;if (n.get('pointer.show')) {
      const h = [+n.get('min'), +n.get('max')]; const c = [i, r]; const d = n.getData(); const f = d.mapDimension('value');d.diff(u).add((t) => {
        const e = new Qw({ shape: { angle: i } });dl(e, { shape: { angle: Rl(d.get(f, t), h, c, !0) } }, n), l.add(e), d.setItemGraphicEl(t, e);
      })
        .update((t, e) => {
          const i = u.getItemGraphicEl(e);cl(i, { shape: { angle: Rl(d.get(f, t), h, c, !0) } }, n), l.add(i), d.setItemGraphicEl(t, i);
        })
        .remove((t) => {
          const e = u.getItemGraphicEl(t);l.remove(e);
        })
        .execute(), d.eachItemGraphicEl((t, e) => {
        const i = d.getItemModel(e); const n = i.getModel('pointer');t.setShape({ x: a.cx, y: a.cy, width: El(n.get('width'), a.r), r: El(n.get('length'), a.r) }), t.useStyle(i.getModel('itemStyle').getItemStyle()), 'auto' === t.style.fill && t.setStyle('fill', o(Rl(d.get(f, e), h, [0, 1], !0))), $s(t, i.getModel('emphasis.itemStyle').getItemStyle());
      }), this._data = d;
    } else u && u.eachItemGraphicEl((t) => {
      l.remove(t);
    });
  }, _renderTitle(t, e, i, n, o) {
    const a = t.getData(); const r = a.mapDimension('value'); const s = t.getModel('title');if (s.get('show')) {
      const l = s.get('offsetCenter'); const u = o.cx + El(l[0], o.r); const h = o.cy + El(l[1], o.r); const c = +t.get('min'); const d = +t.get('max'); const f = n(Rl(t.getData().get(r, 0), [c, d], [0, 1], !0));this.group.add(new Ur({ silent: !0, style: nl({}, s, { x: u, y: h, text: a.getName(0), textAlign: 'center', textVerticalAlign: 'middle' }, { autoColor: f, forceRich: !0 }) }));
    }
  }, _renderDetail(t, e, i, n, o) {
    const a = t.getModel('detail'); const r = +t.get('min'); const s = +t.get('max');if (a.get('show')) {
      const l = a.get('offsetCenter'); const u = o.cx + El(l[0], o.r); const h = o.cy + El(l[1], o.r); const c = El(a.get('width'), o.r); const d = El(a.get('height'), o.r); const f = t.getData(); const p = f.get(f.mapDimension('value'), 0); const g = n(Rl(p, [r, s], [0, 1], !0));this.group.add(new Ur({ silent: !0, style: nl({}, a, { x: u, y: h, text: tb(p, a.get('formatter')), textWidth: isNaN(c) ? null : c, textHeight: isNaN(d) ? null : d, textAlign: 'center', textVerticalAlign: 'middle' }, { autoColor: g, forceRich: !0 }) }));
    }
  } }), Df({ type: 'series.funnel', init(t) {
    ib.superApply(this, 'init', arguments), this.legendVisualProvider = new qv(A(this.getData, this), A(this.getRawData, this)), this._defaultLabelLine(t);
  }, getInitialData(t, e) {
    return Yv(this, { coordDimensions: ['value'], encodeDefaulter: T(Ju, this) });
  }, _defaultLabelLine(t) {
    Go(t, 'labelLine', ['show']);const e = t.labelLine; const i = t.emphasis.labelLine;e.show = e.show && t.label.show, i.show = i.show && t.emphasis.label.show;
  }, getDataParams(t) {
    const e = this.getData(); const i = ib.superCall(this, 'getDataParams', t); const n = e.mapDimension('value'); const o = e.getSum(n);return i.percent = o ? +(e.get(n, t) / o * 100).toFixed(2) : 0, i.$vars.push('percent'), i;
  }, defaultOption: { zlevel: 0, z: 2, legendHoverLink: !0, left: 80, top: 60, right: 80, bottom: 60, minSize: '0%', maxSize: '100%', sort: 'descending', orient: 'vertical', gap: 0, funnelAlign: 'center', label: { show: !0, position: 'outer' }, labelLine: { show: !0, length: 20, lineStyle: { width: 1, type: 'solid' } }, itemStyle: { borderColor: '#fff', borderWidth: 1 }, emphasis: { label: { show: !0 } } } }));function nb(t, e) {
    Ci.call(this);const i = new Qr; const n = new ts; const o = new Ur;this.add(i), this.add(n), this.add(o), this.highDownOnUpdate = function (t, e) {
      'emphasis' === e ? (n.ignore = n.hoverIgnore, o.ignore = o.hoverIgnore) : (n.ignore = n.normalIgnore, o.ignore = o.normalIgnore);
    }, this.updateData(t, e, !0);
  } const ob = nb.prototype; const ab = ['itemStyle', 'opacity'];ob.updateData = function (t, e, i) {
    const n = this.childAt(0); const o = t.hostModel; const a = t.getItemModel(e); const r = t.getItemLayout(e); let s = t.getItemModel(e).get(ab);s = null == s ? 1 : s, n.useStyle({}), i ? (n.setShape({ points: r.points }), n.setStyle({ opacity: 0 }), dl(n, { style: { opacity: s } }, o, e)) : cl(n, { style: { opacity: s }, shape: { points: r.points } }, o, e);const l = a.getModel('itemStyle'); const u = t.getItemVisual(e, 'color');n.setStyle(D({ lineJoin: 'round', fill: u }, l.getItemStyle(['opacity']))), n.hoverStyle = l.getModel('emphasis').getItemStyle(), this._updateLabel(t, e), $s(this);
  }, ob._updateLabel = function (t, e) {
    const i = this.childAt(1); const n = this.childAt(2); const o = t.hostModel; const a = t.getItemModel(e); const r = t.getItemLayout(e).label; let s = t.getItemVisual(e, 'color');cl(i, { shape: { points: r.linePoints || r.linePoints } }, o, e), cl(n, { style: { x: r.x, y: r.y } }, o, e), n.attr({ rotation: r.rotation, origin: [r.x, r.y], z2: 10 });const l = a.getModel('label'); const u = a.getModel('emphasis.label'); const h = a.getModel('labelLine'); const c = a.getModel('emphasis.labelLine');s = t.getItemVisual(e, 'color');el(n.style, n.hoverStyle = {}, l, u, { labelFetcher: t.hostModel, labelDataIndex: e, defaultText: t.getName(e), autoColor: s, useInsideStyle: !!r.inside }, { textAlign: r.textAlign, textVerticalAlign: r.verticalAlign }), n.ignore = n.normalIgnore = !l.get('show'), n.hoverIgnore = !u.get('show'), i.ignore = i.normalIgnore = !h.get('show'), i.hoverIgnore = !c.get('show'), i.setStyle({ stroke: s }), i.setStyle(h.getModel('lineStyle').getLineStyle()), i.hoverStyle = c.getModel('lineStyle').getLineStyle();
  }, w(nb, Ci);_c.extend({ type: 'funnel', render(t, e, i) {
    const n = t.getData(); const o = this._data; const a = this.group;n.diff(o).add((t) => {
      const e = new nb(n, t);n.setItemGraphicEl(t, e), a.add(e);
    })
      .update((t, e) => {
        const i = o.getItemGraphicEl(e);i.updateData(n, t), a.add(i), n.setItemGraphicEl(t, i);
      })
      .remove((t) => {
        const e = o.getItemGraphicEl(t);a.remove(e);
      })
      .execute(), this._data = n;
  }, remove() {
    this.group.removeAll(), this._data = null;
  }, dispose() {} });Sf(iy('funnel')), bf((t, A, e) => {
    t.eachSeriesByType('funnel', (t) => {
      const r = t.getData(); const s = r.mapDimension('value'); const e = t.get('sort'); const i = (function (t, e) {
        return bu(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() });
      }(t, A)); let n = (function (t, e) {
        for (var i = t.mapDimension('value'), n = t.mapArray(i, t => t), o = [], a = 'ascending' === e, r = 0, s = t.count();r < s;r++)o[r] = r;return 'function' === typeof e ? o.sort(e) : 'none' !== e && o.sort((t, e) => (a ? n[t] - n[e] : n[e] - n[t])), o;
      }(r, e)); const l = t.get('orient'); const u = i.width; const h = i.height; let c = i.x; let d = i.y; const f = 'horizontal' === l ? [El(t.get('minSize'), h), El(t.get('maxSize'), h)] : [El(t.get('minSize'), u), El(t.get('maxSize'), u)]; const o = r.getDataExtent(s); let p = t.get('min'); let g = t.get('max');null == p && (p = Math.min(o[0], 0)), null == g && (g = o[1]);function a(t, e) {
        if ('horizontal' === l) {
          let i; const n = Rl(r.get(s, t) || 0, [p, g], f, !0);switch (m) {
            case 'top':i = d;break;case 'center':i = d + (h - n) / 2;break;case 'bottom':i = d + (h - n);
          } return [[e, i], [e, i + n]];
        } let o; const a = Rl(r.get(s, t) || 0, [p, g], f, !0);switch (m) {
          case 'left':o = c;break;case 'center':o = c + (u - a) / 2;break;case 'right':o = c + u - a;
        } return [[o, e], [o + a, e]];
      } var m = t.get('funnelAlign'); let v = t.get('gap'); let y = (('horizontal' === l ? u : h) - v * (r.count() - 1)) / r.count();'ascending' === e && (y = -y, v = -v, 'horizontal' === l ? c += u : d += h, n = n.reverse());for (let x = 0;x < n.length;x++) {
        const _ = n[x]; const w = n[x + 1]; const b = r.getItemModel(_);if ('horizontal' === l) {
          var S = b.get('itemStyle.width');null == S ? S = y : (S = El(S, u), 'ascending' === e && (S = -S));var M = a(_, c); var I = a(w, c + S);c += S + v, r.setItemLayout(_, { points: M.concat(I.slice().reverse()) });
        } else {
          let T = b.get('itemStyle.height');null == T ? T = y : (T = El(T, h), 'ascending' === e && (T = -T));M = a(_, 'horizontal' === l ? c : d), I = a(w, 'horizontal' === l ? c + S : d + T);d += T + v, r.setItemLayout(_, { points: M.concat(I.slice().reverse()) });
        }
      }!(function (v) {
        v.each((t) => {
          let e; let i; let n; let o; const a = v.getItemModel(t); const r = a.getModel('label').get('position'); const s = a.get('orient'); const l = a.getModel('labelLine'); const u = v.getItemLayout(t); const h = u.points; const c = 'inner' === r || 'inside' === r || 'center' === r || 'insideLeft' === r || 'insideRight' === r;if (c)e = 'insideLeft' === r ? (i = (h[0][0] + h[3][0]) / 2 + 5, n = (h[0][1] + h[3][1]) / 2, 'left') : 'insideRight' === r ? (i = (h[1][0] + h[2][0]) / 2 - 5, n = (h[1][1] + h[2][1]) / 2, 'right') : (i = (h[0][0] + h[1][0] + h[2][0] + h[3][0]) / 4, n = (h[0][1] + h[1][1] + h[2][1] + h[3][1]) / 4, 'center'), o = [[i, n], [i, n]];else {
            let d; let f; let p; let g; const m = l.get('length');e = 'left' === r ? (d = (h[3][0] + h[0][0]) / 2, f = (h[3][1] + h[0][1]) / 2, i = (p = d - m) - 5, 'right') : 'right' === r ? (d = (h[1][0] + h[2][0]) / 2, f = (h[1][1] + h[2][1]) / 2, i = (p = d + m) + 5, 'left') : 'top' === r ? (d = (h[3][0] + h[0][0]) / 2, n = (g = (f = (h[3][1] + h[0][1]) / 2) - m) - 5, 'center') : 'bottom' === r ? (d = (h[1][0] + h[2][0]) / 2, n = (g = (f = (h[1][1] + h[2][1]) / 2) + m) + 5, 'center') : 'rightTop' === r ? (d = 'horizontal' === s ? h[3][0] : h[1][0], f = 'horizontal' === s ? h[3][1] : h[1][1], 'horizontal' === s ? (n = (g = f - m) - 5, 'center') : (i = (p = d + m) + 5, 'top')) : 'rightBottom' === r ? (d = h[2][0], f = h[2][1], 'horizontal' === s ? (n = (g = f + m) + 5, 'center') : (i = (p = d + m) + 5, 'bottom')) : 'leftTop' === r ? (d = h[0][0], f = 'horizontal' === s ? h[0][1] : h[1][1], 'horizontal' === s ? (n = (g = f - m) - 5, 'center') : (i = (p = d - m) - 5, 'right')) : 'leftBottom' === r ? (d = 'horizontal' === s ? h[1][0] : h[3][0], f = 'horizontal' === s ? h[1][1] : h[2][1], 'horizontal' === s ? (n = (g = f + m) + 5, 'center') : (i = (p = d - m) - 5, 'right')) : (d = (h[1][0] + h[2][0]) / 2, f = (h[1][1] + h[2][1]) / 2, 'horizontal' === s ? (n = (g = f + m) + 5, 'center') : (i = (p = d + m) + 5, 'left')), 'horizontal' === s ? i = p = d : n = g = f, o = [[d, f], [p, g]];
          }u.label = { linePoints: o, x: i, y: n, verticalAlign: 'middle', textAlign: e, inside: c };
        });
      }(r));
    });
  }), xf(uy('funnel'));function rb(t, e, i, n, o) {
    Gg.call(this, t, e, i), this.type = n || 'value', this.axisIndex = o;
  }rb.prototype = { constructor: rb, model: null, isHorizontal() {
    return 'horizontal' !== this.coordinateSystem.getModel().get('layout');
  } }, w(rb, Gg);function sb(t, e, i, n, o, a) {
    t = t || 0;const r = i[1] - i[0];if (null != o && (o = ub(o, [0, r])), null != a && (a = Math.max(a, null != o ? o : 0)), 'all' === n) {
      let s = Math.abs(e[1] - e[0]);o = a = ub(s = ub(s, [0, r]), [o, a]), n = 0;
    }e[0] = ub(e[0], i), e[1] = ub(e[1], i);const l = lb(e, n);e[n] += t;const u = o || 0; const h = i.slice();l.sign < 0 ? h[0] += u : h[1] -= u, e[n] = ub(e[n], h);let c = lb(e, n);return null != o && (c.sign !== l.sign || c.span < o) && (e[1 - n] = e[n] + l.sign * o), c = lb(e, n), null != a && c.span > a && (e[1 - n] = e[n] + c.sign * a), e;
  } function lb(t, e) {
    const i = t[e] - t[1 - e];return { span: Math.abs(i), sign: 0 < i ? -1 : i < 0 ? 1 : e ? -1 : 1 };
  } function ub(t, e) {
    return Math.min(null != e[1] ? e[1] : 1 / 0, Math.max(null != e[0] ? e[0] : -1 / 0, t));
  } const hb = R; const cb = Math.min; const db = Math.max; const fb = Math.floor; const pb = Math.ceil; const gb = zl; const mb = Math.PI;function vb(t, e, i) {
    this._axesMap = Q(), this._axesLayout = {}, this.dimensions = t.dimensions, this._rect, this._model = t, this._init(t, e, i);
  } function yb(t, e) {
    return cb(db(t, e[0]), e[1]);
  }vb.prototype = { type: 'parallel', constructor: vb, _init(t, r, e) {
    const i = t.dimensions; const s = t.parallelAxisIndex;hb(i, function (t, e) {
      const i = s[e]; const n = r.getComponent('parallelAxis', i); const o = this._axesMap.set(t, new rb(t, sg(n), [0, 0], n.get('type'), i)); const a = 'category' === o.type;o.onBand = a && n.get('boundaryGap'), o.inverse = n.get('inverse'), (n.axis = o).model = n, o.coordinateSystem = n.coordinateSystem = this;
    }, this);
  }, update(t, e) {
    this._updateAxesFromSeries(this._model, t);
  }, containPoint(t) {
    const e = this._makeLayoutInfo(); const i = e.axisBase; const n = e.layoutBase; const o = e.pixelDimIndex; const a = t[1 - o]; const r = t[o];return i <= a && a <= i + e.axisLength && n <= r && r <= n + e.layoutLength;
  }, getModel() {
    return this._model;
  }, _updateAxesFromSeries(e, n) {
    n.eachSeries(function (t) {
      if (e.contains(t, n)) {
        const i = t.getData();hb(this.dimensions, function (t) {
          const e = this._axesMap.get(t);e.scale.unionExtentFromData(i, i.mapDimension(t)), rg(e.scale, e.model);
        }, this);
      }
    }, this);
  }, resize(t, e) {
    this._rect = bu(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }), this._layoutAxes();
  }, getRect() {
    return this._rect;
  }, _makeLayoutInfo() {
    let t; const e = this._model; const i = this._rect; const n = ['x', 'y']; const o = ['width', 'height']; const a = e.get('layout'); const r = 'horizontal' === a ? 0 : 1; const s = i[o[r]]; const l = [0, s]; const u = this.dimensions.length; const h = yb(e.get('axisExpandWidth'), l); const c = yb(e.get('axisExpandCount') || 0, [0, u]); const d = e.get('axisExpandable') && 3 < u && c < u && 1 < c && 0 < h && 0 < s; let f = e.get('axisExpandWindow');f ? (t = yb(f[1] - f[0], l), f[1] = f[0] + t) : (t = yb(h * (c - 1), l), (f = [h * (e.get('axisExpandCenter') || fb(u / 2)) - t / 2])[1] = f[0] + t);let p = (s - t) / (u - c);p < 3 && (p = 0);const g = [fb(gb(f[0] / h, 1)) + 1, pb(gb(f[1] / h, 1)) - 1]; const m = p / h * f[0];return { layout: a, pixelDimIndex: r, layoutBase: i[n[r]], layoutLength: s, axisBase: i[n[1 - r]], axisLength: i[o[1 - r]], axisExpandable: d, axisExpandWidth: h, axisCollapseWidth: p, axisExpandWindow: f, axisCount: u, winInnerIndices: g, axisExpandWindow0Pos: m };
  }, _layoutAxes() {
    const l = this._rect; const t = this._axesMap; const e = this.dimensions; const u = this._makeLayoutInfo(); const h = u.layout;t.each((t) => {
      const e = [0, u.axisLength]; const i = t.inverse ? 1 : 0;t.setExtent(e[i], e[1 - i]);
    }), hb(e, function (t, e) {
      const i = (u.axisExpandable ? function (t, e) {
        let i; let n; const o = e.layoutLength; const a = e.axisExpandWidth; const r = e.axisCount; const s = e.axisCollapseWidth; const l = e.winInnerIndices; let u = s; let h = !1;t < l[0] ? (i = t * s, n = s) : t <= l[1] ? (i = e.axisExpandWindow0Pos + t * a - e.axisExpandWindow[0], u = a, h = !0) : (i = o - (r - 1 - t) * s, n = s);return { position: i, axisNameAvailableWidth: u, axisLabelShow: h, nameTruncateMaxWidth: n };
      } : function (t, e) {
        const i = e.layoutLength / (e.axisCount - 1);return { position: i * t, axisNameAvailableWidth: i, axisLabelShow: !0 };
      })(e, u); const n = { horizontal: { x: i.position, y: u.axisLength }, vertical: { x: 0, y: i.position } }; const o = { horizontal: mb / 2, vertical: 0 }; const a = [n[h].x + l.x, n[h].y + l.y]; const r = o[h]; const s = ae();he(s, s, r), ue(s, s, a), this._axesLayout[t] = { position: a, rotation: r, transform: s, axisNameAvailableWidth: i.axisNameAvailableWidth, axisLabelShow: i.axisLabelShow, nameTruncateMaxWidth: i.nameTruncateMaxWidth, tickDirection: 1, labelDirection: 1 };
    }, this);
  }, getAxis(t) {
    return this._axesMap.get(t);
  }, dataToPoint(t, e) {
    return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e);
  }, eachActiveState(e, t, i, n) {
    null == i && (i = 0), null == n && (n = e.count());const o = this._axesMap; const a = this.dimensions; const r = []; const s = [];R(a, (t) => {
      r.push(e.mapDimension(t)), s.push(o.get(t).model);
    });for (let l = this.hasAxisBrushed(), u = i;u < n;u++) {
      var h;if (l) {
        h = 'active';for (let c = e.getValues(r, u), d = 0, f = a.length;d < f;d++) {
          if ('inactive' === s[d].getActiveState(c[d])) {
            h = 'inactive';break;
          }
        }
      } else h = 'normal';t(h, u);
    }
  }, hasAxisBrushed() {
    for (var t = this.dimensions, e = this._axesMap, i = !1, n = 0, o = t.length;n < o;n++)'normal' !== e.get(t[n]).model.getActiveState() && (i = !0);return i;
  }, axisCoordToPoint(t, e) {
    return pl([t, 0], this._axesLayout[e].transform);
  }, getAxisLayout(t) {
    return k(this._axesLayout[t]);
  }, getSlidedAxisExpandWindow(t) {
    const e = this._makeLayoutInfo(); const i = e.pixelDimIndex; let n = e.axisExpandWindow.slice(); let o = n[1] - n[0]; const a = [0, e.axisExpandWidth * (e.axisCount - 1)];if (!this.containPoint(t)) return { behavior: 'none', axisExpandWindow: n };let r; const s = t[i] - e.layoutBase - e.axisExpandWindow0Pos; let l = 'slide'; const u = e.axisCollapseWidth; const h = this._model.get('axisExpandSlideTriggerArea'); const c = null != h[0];if (u)c && u && s < o * h[0] ? (l = 'jump', r = s - o * h[2]) : c && u && s > o * (1 - h[0]) ? (l = 'jump', r = s - o * (1 - h[2])) : 0 <= (r = s - o * h[1]) && (r = s - o * (1 - h[1])) <= 0 && (r = 0), (r *= e.axisExpandWidth / u) ? sb(r, n, a, 'all') : l = 'none';else {
      o = n[1] - n[0];(n = [db(0, a[1] * s / o - o / 2)])[1] = cb(a[1], n[0] + o), n[0] = n[1] - o;
    } return { axisExpandWindow: n, behavior: l };
  } }, lh.register('parallel', { create(n, o) {
    const a = [];return n.eachComponent('parallel', (t, e) => {
      const i = new vb(t, n, o);i.name = `parallel_${e}`, i.resize(t, o), (t.coordinateSystem = i).model = t, a.push(i);
    }), n.eachSeries((t) => {
      if ('parallel' === t.get('coordinateSystem')) {
        const e = n.queryComponents({ mainType: 'parallel', index: t.get('parallelIndex'), id: t.get('parallelId') })[0];t.coordinateSystem = e.coordinateSystem;
      }
    }), a;
  } });const xb = ku.extend({ type: 'baseParallelAxis', axis: null, activeIntervals: [], getAreaSelectStyle() {
    return ha([['fill', 'color'], ['lineWidth', 'borderWidth'], ['stroke', 'borderColor'], ['width', 'width'], ['opacity', 'opacity']])(this.getModel('areaSelectStyle'));
  }, setActiveIntervals(t) {
    const e = this.activeIntervals = k(t);if (e) for (let i = e.length - 1;0 <= i;i--)Bl(e[i]);
  }, getActiveState(t) {
    const e = this.activeIntervals;if (!e.length) return 'normal';if (null == t || isNaN(t)) return 'inactive';if (1 === e.length) {
      const i = e[0];if (i[0] <= t && t <= i[1]) return 'active';
    } else for (let n = 0, o = e.length;n < o;n++) if (e[n][0] <= t && t <= e[n][1]) return 'active';return 'inactive';
  } });m(xb.prototype, dg), Gm('parallel', xb, (t, e) => e.type || (e.data ? 'category' : 'value'), { type: 'value', dim: null, areaSelectStyle: { width: 20, borderWidth: 1, borderColor: 'rgba(160,197,232)', color: 'rgba(160,197,232)', opacity: .3 }, realtime: !0, z: 10 }), ku.extend({ type: 'parallel', dependencies: ['parallelAxis'], coordinateSystem: null, dimensions: null, parallelAxisIndex: null, layoutMode: 'box', defaultOption: { zlevel: 0, z: 0, left: 80, top: 60, right: 80, bottom: 60, layout: 'horizontal', axisExpandable: !1, axisExpandCenter: null, axisExpandCount: 0, axisExpandWidth: 50, axisExpandRate: 17, axisExpandDebounce: 50, axisExpandSlideTriggerArea: [-.15, .05, .4], axisExpandTriggerOn: 'click', parallelAxisDefault: null }, init() {
    ku.prototype.init.apply(this, arguments), this.mergeOption({});
  }, mergeOption(t) {
    const e = this.option;t && m(e, t, !0), this._initDimensions();
  }, contains(t, e) {
    const i = t.get('parallelIndex');return null != i && e.getComponent('parallel', i) === this;
  }, setAxisExpand(e) {
    R(['axisExpandable', 'axisExpandCenter', 'axisExpandCount', 'axisExpandWidth', 'axisExpandWindow'], function (t) {
      e.hasOwnProperty(t) && (this.option[t] = e[t]);
    }, this);
  }, _initDimensions() {
    const e = this.dimensions = []; const i = this.parallelAxisIndex = [];R(M(this.dependentModels.parallelAxis, function (t) {
      return (t.get('parallelIndex') || 0) === this.componentIndex;
    }, this), (t) => {
      e.push(`dim${t.get('dim')}`), i.push(t.componentIndex);
    });
  } });_f({ type: 'axisAreaSelect', event: 'axisAreaSelected' }, (e, t) => {
    t.eachComponent({ mainType: 'parallelAxis', query: e }, (t) => {
      t.axis.model.setActiveIntervals(e.intervals);
    });
  }), _f('parallelAxisExpand', (e, t) => {
    t.eachComponent({ mainType: 'parallel', query: e }, (t) => {
      t.setAxisExpand(e);
    });
  });const _b = T; const wb = R; const bb = O; const Sb = Math.min; const Mb = Math.max; const Ib = Math.pow; const Tb = 1e4; const Ab = 6; const Db = 6; const Cb = 'globalPan'; const Lb = { w: [0, 0], e: [0, 1], n: [1, 0], s: [1, 1] }; const kb = { w: 'ew', e: 'ew', n: 'ns', s: 'ns', ne: 'nesw', sw: 'nesw', nw: 'nwse', se: 'nwse' }; const Pb = { brushStyle: { lineWidth: 2, stroke: 'rgba(0,0,0,0.3)', fill: 'rgba(0,0,0,0.1)' }, transformable: !0, brushMode: 'single', removeOnClick: !1 }; let Nb = 0;function Ob(t) {
    Ct.call(this), this._zr = t, this.group = new Ci, this._brushType, this._brushOption, this._panels, this._track = [], this._dragging, this._covers = [], this._creatingCover, this._creatingPanel, this._enableGlobalPan, this._uid = `brushController_${Nb++}`, this._handlers = {}, wb(rS, function (t, e) {
      this._handlers[e] = A(t, this);
    }, this);
  } function Rb(t, e) {
    const i = lS[e.brushType].createCover(t, e);return i.__brushOption = e, Bb(i, e), t.group.add(i), i;
  } function Eb(t, e) {
    const i = Gb(e);return i.endCreating && (i.endCreating(t, e), Bb(e, e.__brushOption)), e;
  } function zb(t, e) {
    const i = e.__brushOption;Gb(e).updateCoverShape(t, e, i.range, i);
  } function Bb(t, e) {
    let i = e.z;null == i && (i = Tb), t.traverse((t) => {
      t.z = i, t.z2 = i;
    });
  } function Vb(t, e) {
    Gb(e).updateCommon(t, e), zb(t, e);
  } function Gb(t) {
    return lS[t.__brushOption.brushType];
  } function Fb(t, e, i) {
    let n; const o = t._panels;if (!o) return !0;const a = t._transform;return wb(o, (t) => {
      t.isTargetByCursor(e, i, a) && (n = t);
    }), n;
  } function Wb(t, e) {
    const i = t._panels;if (!i) return !0;const n = e.__brushOption.panelId;return null == n || i[n];
  } function Hb(e) {
    const t = e._covers; const i = t.length;return wb(t, (t) => {
      e.group.remove(t);
    }, e), t.length = 0, !!i;
  } function Zb(t, e) {
    const i = bb(t._covers, (t) => {
      const e = t.__brushOption; const i = k(e.range);return { brushType: e.brushType, panelId: e.panelId, range: i };
    });t.trigger('brush', i, { isEnd: !!e.isEnd, removeOnClick: !!e.removeOnClick });
  } function Ub(t) {
    let e = t.length - 1;return e < 0 && (e = 0), [t[0], t[e]];
  } function Xb(e, i, t, n) {
    const o = new Ci;return o.add(new rs({ name: 'main', style: Kb(t), silent: !0, draggable: !0, cursor: 'move', drift: _b(e, i, o, 'nswe'), ondragend: _b(Zb, i, { isEnd: !0 }) })), wb(n, (t) => {
      o.add(new rs({ name: t, style: { opacity: 0 }, draggable: !0, silent: !0, invisible: !0, drift: _b(e, i, o, t), ondragend: _b(Zb, i, { isEnd: !0 }) }));
    }), o;
  } function Yb(t, e, i, n) {
    const o = n.brushStyle.lineWidth || 0; const a = Mb(o, Db); const r = i[0][0]; const s = i[1][0]; const l = r - o / 2; const u = s - o / 2; const h = i[0][1]; const c = i[1][1]; const d = h - a + o / 2; const f = c - a + o / 2; const p = h - r; const g = c - s; const m = p + o; const v = g + o;qb(t, e, 'main', r, s, p, g), n.transformable && (qb(t, e, 'w', l, u, a, v), qb(t, e, 'e', d, u, a, v), qb(t, e, 'n', l, u, m, a), qb(t, e, 's', l, f, m, a), qb(t, e, 'nw', l, u, a, a), qb(t, e, 'ne', d, u, a, a), qb(t, e, 'sw', l, f, a, a), qb(t, e, 'se', d, f, a, a));
  } function jb(n, o) {
    const t = o.__brushOption; const a = t.transformable; const e = o.childAt(0);e.useStyle(Kb(t)), e.attr({ silent: !a, cursor: a ? 'move' : 'default' }), wb(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], (t) => {
      const e = o.childOfName(t); const i = (function t(e, i) {
        { if (1 < i.length) {
          i = i.split('');var n = [t(e, i[0]), t(e, i[1])];return 'e' !== n[0] && 'w' !== n[0] || n.reverse(), n.join('');
        } const o = { w: 'left', e: 'right', n: 'top', s: 'bottom' }; const a = { left: 'w', right: 'e', top: 'n', bottom: 's' }; var n = gl(o[i], fl(e.group));return a[n]; }
      }(n, t));e && e.attr({ silent: !a, invisible: !a, cursor: a ? `${kb[i]}-resize` : null });
    });
  } function qb(t, e, i, n, o, a, r) {
    const s = e.childOfName(i);s && s.setShape(function (t) {
      const e = Sb(t[0][0], t[1][0]); const i = Sb(t[0][1], t[1][1]); const n = Mb(t[0][0], t[1][0]); const o = Mb(t[0][1], t[1][1]);return { x: e, y: i, width: n - e, height: o - i };
    }(eS(t, e, [[n, o], [n + a, o + r]])));
  } function Kb(t) {
    return D({ strokeNoScale: !0 }, t.brushStyle);
  } function $b(t, e, i, n) {
    const o = [Sb(t, i), Sb(e, n)]; const a = [Mb(t, i), Mb(e, n)];return [[o[0], a[0]], [o[1], a[1]]];
  } function Jb(t, e, i, n, o, a, r, s) {
    const l = n.__brushOption; const u = t(l.range); const h = tS(i, a, r);wb(o.split(''), (t) => {
      const e = Lb[t];u[e[0]][e[1]] += h[e[0]];
    }), l.range = e($b(u[0][0], u[1][0], u[0][1], u[1][1])), Vb(i, n), Zb(i, { isEnd: !1 });
  } function Qb(t, e, i, n, o) {
    const a = e.__brushOption.range; const r = tS(t, i, n);wb(a, (t) => {
      t[0] += r[0], t[1] += r[1];
    }), Vb(t, e), Zb(t, { isEnd: !1 });
  } function tS(t, e, i) {
    const n = t.group; const o = n.transformCoordToLocal(e, i); const a = n.transformCoordToLocal(0, 0);return [o[0] - a[0], o[1] - a[1]];
  } function eS(t, e, i) {
    const n = Wb(t, e);return n && !0 !== n ? n.clipPath(i, t._transform) : k(i);
  } function iS(t) {
    const e = t.event;e.preventDefault && e.preventDefault();
  } function nS(t, e, i) {
    return t.childOfName('main').contain(e, i);
  } function oS(t, e, i, n) {
    let o; let a = t._creatingCover; const r = t._creatingPanel; const s = t._brushOption;if (t._track.push(i.slice()), (function (t) {
      const e = t._track;if (!e.length) return !1;const i = e[e.length - 1]; const n = e[0]; const o = i[0] - n[0]; const a = i[1] - n[1]; const r = Ib(o * o + a * a, .5);return Ab < r;
    }(t)) || a) {
      if (r && !a) {
        'single' === s.brushMode && Hb(t);const l = k(s);l.brushType = aS(l.brushType, r), l.panelId = !0 === r ? null : r.panelId, a = t._creatingCover = Rb(t, l), t._covers.push(a);
      } if (a) {
        const u = lS[aS(t._brushType, r)];a.__brushOption.range = u.getCreatingRange(eS(t, a, t._track)), n && (Eb(t, a), u.updateCommon(t, a)), zb(t, a), o = { isEnd: n };
      }
    } else n && 'single' === s.brushMode && s.removeOnClick && Fb(t, e, i) && Hb(t) && (o = { isEnd: n, removeOnClick: !0 });return o;
  } function aS(t, e) {
    return 'auto' === t ? e.defaultBrushType : t;
  }Ob.prototype = { constructor: Ob, enableBrush(t) {
    return this._brushType && (function (t) {
      const e = t._zr;(function (t, e, i) {
        const n = By(t);n[e] === i && (n[e] = null);
      }(e, Cb, t._uid)), (function (i, t) {
        wb(t, (t, e) => {
          i.off(e, t);
        });
      }(e, t._handlers)), t._brushType = t._brushOption = null;
    }(this)), t.brushType && (function (t, e) {
      const i = t._zr;t._enableGlobalPan || (function (t, e, i) {
        By(t)[e] = i;
      }(i, Cb, t._uid));(function (i, t) {
        wb(t, (t, e) => {
          i.on(e, t);
        });
      }(i, t._handlers)), t._brushType = e.brushType, t._brushOption = m(k(Pb), e, !0);
    }(this, t)), this;
  }, setPanels(t) {
    if (t && t.length) {
      const e = this._panels = {};R(t, (t) => {
        e[t.panelId] = k(t);
      });
    } else this._panels = null;return this;
  }, mount(t) {
    t = t || {}, this._enableGlobalPan = t.enableGlobalPan;const e = this.group;return this._zr.add(e), e.attr({ position: t.position || [0, 0], rotation: t.rotation || 0, scale: t.scale || [1, 1] }), this._transform = e.getLocalTransform(), this;
  }, eachCover(t, e) {
    wb(this._covers, t, e);
  }, updateCovers(o) {
    o = O(o, t => m(k(Pb), t, !0));const i = '\0-brush-index-'; const a = this._covers; const r = this._covers = []; const s = this; const l = this._creatingCover;return new kf(a, o, ((t, e) => n(t.__brushOption, e)), n).add(t)
      .update(t)
      .remove((t) => {
        a[t] !== l && s.group.remove(a[t]);
      })
      .execute(), this;function n(t, e) {
      return `${null != t.id ? t.id : i + e}-${t.brushType}`;
    } function t(t, e) {
      const i = o[t];if (null != e && a[e] === l)r[t] = a[e];else {
        const n = r[t] = null != e ? (a[e].__brushOption = i, a[e]) : Eb(s, Rb(s, i));Vb(s, n);
      }
    }
  }, unmount() {
    return this.enableBrush(!1), Hb(this), this._zr.remove(this.group), this;
  }, dispose() {
    this.unmount(), this.off();
  } }, b(Ob, Ct);var rS = { mousedown(t) {
    if (this._dragging)sS(this, t);else if (!t.target || !t.target.draggable) {
      iS(t);const e = this.group.transformCoordToLocal(t.offsetX, t.offsetY);this._creatingCover = null, (this._creatingPanel = Fb(this, t, e)) && (this._dragging = !0, this._track = [e.slice()]);
    }
  }, mousemove(t) {
    const e = t.offsetX; const i = t.offsetY; const n = this.group.transformCoordToLocal(e, i);if ((function (t, e, i) {
      if (t._brushType && !(function (t, e, i) {
        const n = t._zr;return e < 0 || e > n.getWidth() || i < 0 || i > n.getHeight();
      }(t, e))) {
        const n = t._zr; const o = t._covers; const a = Fb(t, e, i);if (!t._dragging) for (let r = 0;r < o.length;r++) {
          const s = o[r].__brushOption;if (a && (!0 === a || s.panelId === a.panelId) && lS[s.brushType].contain(o[r], i[0], i[1])) return;
        }a && n.setCursorStyle('crosshair');
      }
    }(this, t, n)), this._dragging) {
      iS(t);const o = oS(this, t, n, !1);o && Zb(this, o);
    }
  }, mouseup(t) {
    sS(this, t);
  } };function sS(t, e) {
    if (t._dragging) {
      iS(e);const i = e.offsetX; const n = e.offsetY; const o = t.group.transformCoordToLocal(i, n); const a = oS(t, e, o, !0);t._dragging = !1, t._track = [], t._creatingCover = null, a && Zb(t, a);
    }
  } var lS = { lineX: uS(0), lineY: uS(1), rect: { createCover(t, e) {
    return Xb(_b(Jb, t => t, t => t), t, e, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);
  }, getCreatingRange(t) {
    const e = Ub(t);return $b(e[1][0], e[1][1], e[0][0], e[0][1]);
  }, updateCoverShape(t, e, i, n) {
    Yb(t, e, i, n);
  }, updateCommon: jb, contain: nS }, polygon: { createCover(t, e) {
    const i = new Ci;return i.add(new ts({ name: 'main', style: Kb(e), silent: !0 })), i;
  }, getCreatingRange(t) {
    return t;
  }, endCreating(t, e) {
    e.remove(e.childAt(0)), e.add(new Qr({ name: 'main', draggable: !0, drift: _b(Qb, t, e), ondragend: _b(Zb, t, { isEnd: !0 }) }));
  }, updateCoverShape(t, e, i, n) {
    e.childAt(0).setShape({ points: eS(t, e, i) });
  }, updateCommon: jb, contain: nS } };function uS(l) {
    return { createCover(t, e) {
      return Xb(_b(Jb, (t) => {
        const e = [t, [0, 100]];return l && e.reverse(), e;
      }, t => t[l]), t, e, [['w', 'e'], ['n', 's']][l]);
    }, getCreatingRange(t) {
      const e = Ub(t);return [Sb(e[0][l], e[1][l]), Mb(e[0][l], e[1][l])];
    }, updateCoverShape(t, e, i, n) {
      let o; const a = Wb(t, e);if (!0 !== a && a.getLinearBrushOtherExtent)o = a.getLinearBrushOtherExtent(l, t._transform);else {
        const r = t._zr;o = [0, [r.getWidth(), r.getHeight()][1 - l]];
      } const s = [i, o];l && s.reverse(), Yb(t, e, s, n);
    }, updateCommon: jb, contain: nS };
  } function hS(i) {
    return i = fS(i), function (t, e) {
      return vl(t, i);
    };
  } function cS(o, a) {
    return o = fS(o), function (t) {
      const e = null != a ? a : t; const i = e ? o.width : o.height; const n = e ? o.x : o.y;return [n, n + (i || 0)];
    };
  } function dS(n, o, a) {
    return n = fS(n), function (t, e, i) {
      return n.contain(e[0], e[1]) && !$y(t, o, a);
    };
  } function fS(t) {
    return Di.create(t);
  } const pS = ['axisLine', 'axisTickLabel', 'axisName']; var gS = Af({ type: 'parallelAxis', init(t, e) {
    gS.superApply(this, 'init', arguments), (this._brushController = new Ob(e.getZr())).on('brush', A(this._onBrush, this));
  }, render(t, e, i, n) {
    if (!(function (t, e, i) {
      return i && 'axisAreaSelect' === i.type && e.findComponents({ mainType: 'parallelAxis', query: i })[0] === t;
    }(t, e, n))) {
      this.axisModel = t, this.api = i, this.group.removeAll();const o = this._axisGroup;if (this._axisGroup = new Ci, this.group.add(this._axisGroup), t.get('show')) {
        const a = (function (t, e) {
          return e.getComponent('parallel', t.get('parallelIndex'));
        }(t, e)); const r = a.coordinateSystem; const s = t.getAreaSelectStyle(); const l = s.width; const u = t.axis.dim; const h = P({ strokeContainThreshold: l }, r.getAxisLayout(u)); const c = new Qm(t, h);R(pS, c.add, c), this._axisGroup.add(c.getGroup()), this._refreshBrushController(h, s, t, a, l, i);const d = n && !1 === n.animation ? null : t;ml(o, this._axisGroup, d);
      }
    }
  }, _refreshBrushController(t, e, i, n, o, a) {
    const r = i.axis.getExtent(); const s = r[1] - r[0]; const l = Math.min(30, .1 * Math.abs(s)); const u = Di.create({ x: r[0], y: -o / 2, width: s, height: o });u.x -= l, u.width += 2 * l, this._brushController.mount({ enableGlobalPan: !0, rotation: t.rotation, position: t.position }).setPanels([{ panelId: 'pl', clipPath: hS(u), isTargetByCursor: dS(u, a, n), getLinearBrushOtherExtent: cS(u, 0) }])
      .enableBrush({ brushType: 'lineX', brushStyle: e, removeOnClick: !0 })
      .updateCovers(function (t) {
        const e = t.axis;return O(t.activeIntervals, t => ({ brushType: 'lineX', panelId: 'pl', range: [e.dataToCoord(t[0], !0), e.dataToCoord(t[1], !0)] }));
      }(i));
  }, _onBrush(t, e) {
    const i = this.axisModel; const n = i.axis; const o = O(t, t => [n.coordToData(t.range[0], !0), n.coordToData(t.range[1], !0)]);!i.option.realtime !== e.isEnd && !e.removeOnClick || this.api.dispatchAction({ type: 'axisAreaSelect', parallelAxisId: i.id, intervals: o });
  }, dispose() {
    this._brushController.dispose();
  } });Af({ type: 'parallel', render(t, e, i) {
    this._model = t, this._api = i, this._handlers || (this._handlers = {}, R(mS, function (t, e) {
      i.getZr().on(e, this._handlers[e] = A(t, this));
    }, this)), kc(this, '_throttledDispatchExpand', t.get('axisExpandRate'), 'fixRate');
  }, dispose(t, i) {
    R(this._handlers, (t, e) => {
      i.getZr().off(e, t);
    }), this._handlers = null;
  }, _throttledDispatchExpand(t) {
    this._dispatchExpand(t);
  }, _dispatchExpand(t) {
    t && this._api.dispatchAction(P({ type: 'parallelAxisExpand' }, t));
  } });var mS = { mousedown(t) {
    vS(this, 'click') && (this._mouseDownPoint = [t.offsetX, t.offsetY]);
  }, mouseup(t) {
    const e = this._mouseDownPoint;if (vS(this, 'click') && e) {
      const i = [t.offsetX, t.offsetY];if (5 < Math.pow(e[0] - i[0], 2) + Math.pow(e[1] - i[1], 2)) return;const n = this._model.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY]);'none' !== n.behavior && this._dispatchExpand({ axisExpandWindow: n.axisExpandWindow });
    } this._mouseDownPoint = null;
  }, mousemove(t) {
    if (!this._mouseDownPoint && vS(this, 'mousemove')) {
      const e = this._model; const i = e.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY]); const n = i.behavior;'jump' === n && this._throttledDispatchExpand.debounceNextCall(e.get('axisExpandDebounce')), this._throttledDispatchExpand('none' === n ? null : { axisExpandWindow: i.axisExpandWindow, animation: 'jump' === n && null });
    }
  } };function vS(t, e) {
    const i = t._model;return i.get('axisExpandable') && i.get('axisExpandTriggerOn') === e;
  }yf((t) => {
    !(function (t) {
      if (t.parallel) return;let e = !1;R(t.series, (t) => {
        t && 'parallel' === t.type && (e = !0);
      }), e && (t.parallel = [{}]);
    }(t)), (function (n) {
      R(Vo(n.parallelAxis), (t) => {
        if (z(t)) {
          const e = t.parallelIndex || 0; const i = Vo(n.parallel)[e];i && i.parallelAxisDefault && m(t, i.parallelAxisDefault, !1);
        }
      });
    }(t));
  }), sc.extend({ type: 'series.parallel', dependencies: ['parallel'], visualColorAccessPath: 'lineStyle.color', getInitialData(t, e) {
    const i = this.getSource();return (function (t, e) {
      if (t.encodeDefine) return;const i = e.ecModel.getComponent('parallel', e.get('parallelIndex'));if (!i) return;const n = t.encodeDefine = Q();R(i.dimensions, (t) => {
        const e = (function (t) {
          return +t.replace('dim', '');
        }(t));n.set(t, e);
      });
    }(i, this)), gp(i, this);
  }, getRawIndicesByActiveState(i) {
    const t = this.coordinateSystem; const n = this.getData(); const o = [];return t.eachActiveState(n, (t, e) => {
      i === t && o.push(n.getRawIndex(e));
    }), o;
  }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: 'parallel', parallelIndex: 0, label: { show: !1 }, inactiveOpacity: .05, activeOpacity: 1, lineStyle: { width: 1, opacity: .45, type: 'solid' }, emphasis: { label: { show: !1 } }, progressive: 500, smooth: !1, animationEasing: 'linear' } });_c.extend({ type: 'parallel', init() {
    this._dataGroup = new Ci, this.group.add(this._dataGroup), this._data, this._initialized;
  }, render(a, t, e, r) {
    const i = this._dataGroup; const s = a.getData(); const l = this._data; const u = a.coordinateSystem; const h = u.dimensions; const c = _S(a);if (s.diff(l).add((t) => {
      wS(xS(s, i, t, h, u), s, t, c);
    })
      .update((t, e) => {
        const i = l.getItemGraphicEl(e); const n = yS(s, t, h, u);s.setItemGraphicEl(t, i);const o = r && !1 === r.animation ? null : a;cl(i, { shape: { points: n } }, o, t), wS(i, s, t, c);
      })
      .remove((t) => {
        const e = l.getItemGraphicEl(t);i.remove(e);
      })
      .execute(), !this._initialized) {
      this._initialized = !0;const n = (function (t, e, i) {
        const n = t.model; const o = t.getRect(); const a = new rs({ shape: { x: o.x, y: o.y, width: o.width, height: o.height } }); const r = 'horizontal' === n.get('layout') ? 'width' : 'height';return a.setShape(r, 0), dl(a, { shape: { width: o.width, height: o.height } }, e, i), a;
      }(u, a, () => {
        setTimeout(() => {
          i.removeClipPath();
        });
      }));i.setClipPath(n);
    } this._data = s;
  }, incrementalPrepareRender(t, e, i) {
    this._initialized = !0, this._data = null, this._dataGroup.removeAll();
  }, incrementalRender(t, e, i) {
    for (let n = e.getData(), o = e.coordinateSystem, a = o.dimensions, r = _S(e), s = t.start;s < t.end;s++) {
      const l = xS(n, this._dataGroup, s, a, o);l.incremental = !0, wS(l, n, s, r);
    }
  }, dispose() {}, remove() {
    this._dataGroup && this._dataGroup.removeAll(), this._data = null;
  } });function yS(t, e, i, n) {
    for (var o, a = [], r = 0;r < i.length;r++) {
      const s = i[r]; const l = t.get(t.mapDimension(s), e);o = l, ('category' === n.getAxis(s).type ? null == o : null == o || isNaN(o)) || a.push(n.dataToPoint(l, s));
    } return a;
  } function xS(t, e, i, n, o) {
    const a = yS(t, i, n, o); const r = new ts({ shape: { points: a }, silent: !0, z2: 10 });return e.add(r), t.setItemGraphicEl(i, r), r;
  } function _S(t) {
    let e = t.get('smooth', !0);return !0 === e && (e = .3), { lineStyle: t.getModel('lineStyle').getLineStyle(), smooth: null != e ? e : .3 };
  } function wS(t, e, i, n) {
    let o = n.lineStyle;e.hasItemOption && (o = e.getItemModel(i).getModel('lineStyle')
      .getLineStyle());t.useStyle(o);const a = t.style;a.fill = null, a.stroke = e.getItemVisual(i, 'color'), a.opacity = e.getItemVisual(i, 'opacity'), n.smooth && (t.shape.smooth = n.smooth);
  } const bS = ['lineStyle', 'normal', 'opacity'];Sf({ seriesType: 'parallel', reset(t, e, i) {
    const n = t.getModel('itemStyle'); const o = t.getModel('lineStyle'); const a = e.get('color'); const r = o.get('color') || n.get('color') || a[t.seriesIndex % a.length]; const s = t.get('inactiveOpacity'); const l = t.get('activeOpacity'); const u = t.getModel('lineStyle').getLineStyle(); const h = t.coordinateSystem; const c = t.getData(); const d = { normal: u.opacity, active: l, inactive: s };return c.setVisual('color', r), { progress(t, o) {
      h.eachActiveState(o, (t, e) => {
        let i = d[t];if ('normal' === t && o.hasItemOption) {
          const n = o.getItemModel(e).get(bS, !0);null != n && (i = n);
        }o.setItemVisual(e, 'opacity', i);
      }, t.start, t.end);
    } };
  } });var SS = sc.extend({ type: 'series.sankey', layoutInfo: null, levelModels: null, getInitialData(t, e) {
    for (var i = t.edges || t.links, n = t.data || t.nodes, o = t.levels, a = this.levelModels = {}, r = 0;r < o.length;r++)null != o[r].depth && 0 <= o[r].depth && (a[o[r].depth] = new Cl(o[r], this, e));if (n && i) return iw(n, i, this, !0, (t, e) => {
      t.wrapMethod('getItemModel', (t, n) => (t.customizeGetParent(function (t) {
        const e = this.parentModel; const i = e.getData().getItemLayout(n).depth;return e.levelModels[i] || this.parentModel;
      }), t)), e.wrapMethod('getItemModel', (t, n) => (t.customizeGetParent(function (t) {
        const e = this.parentModel; const i = e.getGraph().getEdgeByIndex(n).node1.getLayout().depth;return e.levelModels[i] || this.parentModel;
      }), t));
    }).data;
  }, setNodePosition(t, e) {
    const i = this.option.data[t];i.localX = e[0], i.localY = e[1];
  }, getGraph() {
    return this.getData().graph;
  }, getEdgeData() {
    return this.getGraph().edgeData;
  }, formatTooltip(t, e, i) {
    if ('edge' === i) {
      const n = this.getDataParams(t, i); const o = n.data; var a = `${o.source} -- ${o.target}`;return n.value && (a += ` : ${n.value}`), au(a);
    } if ('node' !== i) return SS.superCall(this, 'formatTooltip', t, e);const r = this.getGraph().getNodeByIndex(t)
      .getLayout().value; const s = this.getDataParams(t, i).data.name;if (r)a = `${s} : ${r}`;return au(a);
  }, optionUpdated() {
    const t = this.option;!0 === t.focusNodeAdjacency && (t.focusNodeAdjacency = 'allEdges');
  }, getDataParams(t, e) {
    const i = SS.superCall(this, 'getDataParams', t, e);if (null == i.value && 'node' === e) {
      const n = this.getGraph().getNodeByIndex(t)
        .getLayout().value;i.value = n;
    } return i;
  }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: 'view', layout: null, left: '5%', top: '5%', right: '20%', bottom: '5%', orient: 'horizontal', nodeWidth: 20, nodeGap: 8, draggable: !0, focusNodeAdjacency: !1, layoutIterations: 32, label: { show: !0, position: 'right', color: '#000', fontSize: 12 }, levels: [], nodeAlign: 'justify', itemStyle: { borderWidth: 1, borderColor: '#333' }, lineStyle: { color: '#314656', opacity: .2, curveness: .5 }, emphasis: { label: { show: !0 }, lineStyle: { opacity: .5 } }, animationEasing: 'linear', animationDuration: 1e3 } }); const MS = ['itemStyle', 'opacity']; const IS = ['emphasis', 'itemStyle', 'opacity']; const TS = ['lineStyle', 'opacity']; const AS = ['emphasis', 'lineStyle', 'opacity'];function DS(t, e) {
    return t.getVisual('opacity') || t.getModel().get(e);
  } function CS(t, e, i) {
    const n = t.getGraphicEl(); let o = DS(t, e);null != i && (null == o && (o = 1), o *= i), n.downplay && n.downplay(), n.traverse((t) => {
      'group' !== t.type && t.setStyle('opacity', o);
    });
  } function LS(t, e) {
    const i = DS(t, e); const n = t.getGraphicEl();n.traverse((t) => {
      'group' !== t.type && t.setStyle('opacity', i);
    }), n.highlight && n.highlight();
  } const kS = Cs({ shape: { x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, cpx2: 0, cpy2: 0, extent: 0, orient: '' }, buildPath(t, e) {
    const i = e.extent;t.moveTo(e.x1, e.y1), t.bezierCurveTo(e.cpx1, e.cpy1, e.cpx2, e.cpy2, e.x2, e.y2), 'vertical' === e.orient ? (t.lineTo(e.x2 + i, e.y2), t.bezierCurveTo(e.cpx2 + i, e.cpy2, e.cpx1 + i, e.cpy1, e.x1 + i, e.y1)) : (t.lineTo(e.x2, e.y2 + i), t.bezierCurveTo(e.cpx2, e.cpy2 + i, e.cpx1, e.cpy1 + i, e.x1, e.y1 + i)), t.closePath();
  }, highlight() {
    this.trigger('emphasis');
  }, downplay() {
    this.trigger('normal');
  } });Cf({ type: 'sankey', _model: null, _focusAdjacencyDisabled: !1, render(w, t, n) {
    const o = this; const e = w.getGraph(); const b = this.group; const i = w.layoutInfo; const S = i.width; const M = i.height; const u = w.getData(); const I = w.getData('edge'); const T = w.get('orient');this._model = w, b.removeAll(), b.attr('position', [i.x, i.y]), e.eachEdge((t) => {
      const e = new kS;e.dataIndex = t.dataIndex, e.seriesIndex = w.seriesIndex, e.dataType = 'edge';let i; let n; let o; let a; let r; let s; let l; let u; const h = t.getModel('lineStyle'); const c = h.get('curveness'); const d = t.node1.getLayout(); const f = t.node1.getModel(); const p = f.get('localX'); const g = f.get('localY'); const m = t.node2.getLayout(); const v = t.node2.getModel(); const y = v.get('localX'); const x = v.get('localY'); const _ = t.getLayout();switch (e.shape.extent = Math.max(1, _.dy), u = 'vertical' === (e.shape.orient = T) ? (i = (null != p ? p * S : d.x) + _.sy, n = (null != g ? g * M : d.y) + d.dy, o = (null != y ? y * S : m.x) + _.ty, r = i, s = n * (1 - c) + (a = null != x ? x * M : m.y) * c, l = o, n * c + a * (1 - c)) : (i = (null != p ? p * S : d.x) + d.dx, n = (null != g ? g * M : d.y) + _.sy, r = i * (1 - c) + (o = null != y ? y * S : m.x) * c, s = n, l = i * c + o * (1 - c), a = (null != x ? x * M : m.y) + _.ty), e.setShape({ x1: i, y1: n, x2: o, y2: a, cpx1: r, cpy1: s, cpx2: l, cpy2: u }), e.setStyle(h.getItemStyle()), e.style.fill) {
        case 'source':e.style.fill = t.node1.getVisual('color');break;case 'target':e.style.fill = t.node2.getVisual('color');
      }$s(e, t.getModel('emphasis.lineStyle').getItemStyle()), b.add(e), I.setItemGraphicEl(t.dataIndex, e);
    }), e.eachNode((t) => {
      const e = t.getLayout(); const i = t.getModel(); const n = i.get('localX'); const o = i.get('localY'); const a = i.getModel('label'); const r = i.getModel('emphasis.label'); const s = new rs({ shape: { x: null != n ? n * S : e.x, y: null != o ? o * M : e.y, width: e.dx, height: e.dy }, style: i.getModel('itemStyle').getItemStyle() }); const l = t.getModel('emphasis.itemStyle').getItemStyle();el(s.style, l, a, r, { labelFetcher: w, labelDataIndex: t.dataIndex, defaultText: t.id, isRectText: !0 }), s.setStyle('fill', t.getVisual('color')), $s(s, l), b.add(s), u.setItemGraphicEl(t.dataIndex, s), s.dataType = 'node';
    }), u.eachItemGraphicEl((t, i) => {
      const e = u.getItemModel(i);e.get('draggable') && (t.drift = function (t, e) {
        o._focusAdjacencyDisabled = !0, this.shape.x += t, this.shape.y += e, this.dirty(), n.dispatchAction({ type: 'dragNode', seriesId: w.id, dataIndex: u.getRawIndex(i), localX: this.shape.x / S, localY: this.shape.y / M });
      }, t.ondragend = function () {
        o._focusAdjacencyDisabled = !1;
      }, t.draggable = !0, t.cursor = 'move'), t.highlight = function () {
        this.trigger('emphasis');
      }, t.downplay = function () {
        this.trigger('normal');
      }, t.focusNodeAdjHandler && t.off('mouseover', t.focusNodeAdjHandler), t.unfocusNodeAdjHandler && t.off('mouseout', t.unfocusNodeAdjHandler), e.get('focusNodeAdjacency') && (t.on('mouseover', t.focusNodeAdjHandler = function () {
        o._focusAdjacencyDisabled || (o._clearTimer(), n.dispatchAction({ type: 'focusNodeAdjacency', seriesId: w.id, dataIndex: t.dataIndex }));
      }), t.on('mouseout', t.unfocusNodeAdjHandler = function () {
        o._focusAdjacencyDisabled || o._dispatchUnfocus(n);
      }));
    }), I.eachItemGraphicEl((t, e) => {
      const i = I.getItemModel(e);t.focusNodeAdjHandler && t.off('mouseover', t.focusNodeAdjHandler), t.unfocusNodeAdjHandler && t.off('mouseout', t.unfocusNodeAdjHandler), i.get('focusNodeAdjacency') && (t.on('mouseover', t.focusNodeAdjHandler = function () {
        o._focusAdjacencyDisabled || (o._clearTimer(), n.dispatchAction({ type: 'focusNodeAdjacency', seriesId: w.id, edgeDataIndex: t.dataIndex }));
      }), t.on('mouseout', t.unfocusNodeAdjHandler = function () {
        o._focusAdjacencyDisabled || o._dispatchUnfocus(n);
      }));
    }), !this._data && w.get('animation') && b.setClipPath(function (t, e, i) {
      const n = new rs({ shape: { x: t.x - 10, y: t.y - 10, width: 0, height: t.height + 20 } });return dl(n, { shape: { width: t.width + 20 } }, e, i), n;
    }(b.getBoundingRect(), w, () => {
      b.removeClipPath();
    })), this._data = w.getData();
  }, dispose() {
    this._clearTimer();
  }, _dispatchUnfocus(t) {
    const e = this;this._clearTimer(), this._unfocusDelayTimer = setTimeout(() => {
      e._unfocusDelayTimer = null, t.dispatchAction({ type: 'unfocusNodeAdjacency', seriesId: e._model.id });
    }, 500);
  }, _clearTimer() {
    this._unfocusDelayTimer && (clearTimeout(this._unfocusDelayTimer), this._unfocusDelayTimer = null);
  }, focusNodeAdjacency(t, e, i, n) {
    const o = t.getData(); const a = o.graph; const r = n.dataIndex; const s = o.getItemModel(r); const l = n.edgeDataIndex;if (null != r || null != l) {
      const u = a.getNodeByIndex(r); const h = a.getEdgeByIndex(l);if (a.eachNode((t) => {
        CS(t, MS, .1);
      }), a.eachEdge((t) => {
        CS(t, TS, .1);
      }), u) {
        LS(u, IS);const c = s.get('focusNodeAdjacency');'outEdges' === c ? R(u.outEdges, (t) => {
          t.dataIndex < 0 || (LS(t, AS), LS(t.node2, IS));
        }) : 'inEdges' === c ? R(u.inEdges, (t) => {
          t.dataIndex < 0 || (LS(t, AS), LS(t.node1, IS));
        }) : 'allEdges' === c && R(u.edges, (t) => {
          t.dataIndex < 0 || (LS(t, AS), t.node1 !== u && LS(t.node1, IS), t.node2 !== u && LS(t.node2, IS));
        });
      }h && (LS(h, AS), LS(h.node1, IS), LS(h.node2, IS));
    }
  }, unfocusNodeAdjacency(t, e, i, n) {
    const o = t.getGraph();o.eachNode((t) => {
      CS(t, MS);
    }), o.eachEdge((t) => {
      CS(t, TS);
    });
  } }), _f({ type: 'dragNode', event: 'dragnode', update: 'update' }, (e, t) => {
    t.eachComponent({ mainType: 'series', subType: 'sankey', query: e }, (t) => {
      t.setNodePosition(e.dataIndex, [e.localX, e.localY]);
    });
  });function PS(t) {
    const e = t.hostGraph.data.getRawDataItem(t.dataIndex);return null != e.depth && 0 <= e.depth;
  } function NS(t, l, u, h, c) {
    const d = 'vertical' === c ? 'x' : 'y';R(t, (t) => {
      let e; let i; let n;t.sort((t, e) => t.getLayout()[d] - e.getLayout()[d]);for (var o = 0, a = t.length, r = 'vertical' === c ? 'dx' : 'dy', s = 0;s < a;s++)0 < (n = o - (i = t[s]).getLayout()[d]) && (e = i.getLayout()[d] + n, 'vertical' === c ? i.setLayout({ x: e }, !0) : i.setLayout({ y: e }, !0)), o = i.getLayout()[d] + i.getLayout()[r] + l;if (0 < (n = o - l - ('vertical' === c ? h : u))) for (e = i.getLayout()[d] - n, 'vertical' === c ? i.setLayout({ x: e }, !0) : i.setLayout({ y: e }, !0), o = e, s = a - 2;0 <= s;--s)0 < (n = (i = t[s]).getLayout()[d] + i.getLayout()[r] + l - o) && (e = i.getLayout()[d] - n, 'vertical' === c ? i.setLayout({ x: e }, !0) : i.setLayout({ y: e }, !0)), o = i.getLayout()[d];
    });
  } function OS(t, a, r) {
    R(t.slice().reverse(), (t) => {
      R(t, (t) => {
        if (t.outEdges.length) {
          let e = FS(t.outEdges, RS, r) / FS(t.outEdges, GS, r);if (isNaN(e)) {
            const i = t.outEdges.length;e = i ? FS(t.outEdges, ES, r) / i : 0;
          } if ('vertical' === r) {
            const n = t.getLayout().x + (e - VS(t, r)) * a;t.setLayout({ x: n }, !0);
          } else {
            const o = t.getLayout().y + (e - VS(t, r)) * a;t.setLayout({ y: o }, !0);
          }
        }
      });
    });
  } function RS(t, e) {
    return VS(t.node2, e) * t.getValue();
  } function ES(t, e) {
    return VS(t.node2, e);
  } function zS(t, e) {
    return VS(t.node1, e) * t.getValue();
  } function BS(t, e) {
    return VS(t.node1, e);
  } function VS(t, e) {
    return 'vertical' === e ? t.getLayout().x + t.getLayout().dx / 2 : t.getLayout().y + t.getLayout().dy / 2;
  } function GS(t) {
    return t.getValue();
  } function FS(t, e, i) {
    for (var n = 0, o = t.length, a = -1;++a < o;) {
      const r = +e.call(t, t[a], i);isNaN(r) || (n += r);
    } return n;
  } function WS(t, a, r) {
    R(t, (t) => {
      R(t, (t) => {
        if (t.inEdges.length) {
          let e = FS(t.inEdges, zS, r) / FS(t.inEdges, GS, r);if (isNaN(e)) {
            const i = t.inEdges.length;e = i ? FS(t.inEdges, BS, r) / i : 0;
          } if ('vertical' === r) {
            const n = t.getLayout().x + (e - VS(t, r)) * a;t.setLayout({ x: n }, !0);
          } else {
            const o = t.getLayout().y + (e - VS(t, r)) * a;t.setLayout({ y: o }, !0);
          }
        }
      });
    });
  }bf((t, u, e) => {
    t.eachSeriesByType('sankey', (t) => {
      const e = t.get('nodeWidth'); const i = t.get('nodeGap'); const n = (function (t, e) {
        return bu(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() });
      }(t, u)); const o = (t.layoutInfo = n).width; const a = n.height; const r = t.getGraph(); const s = r.nodes; const l = r.edges;!(function (t) {
        R(t, (t) => {
          const e = FS(t.outEdges, GS); const i = FS(t.inEdges, GS); const n = t.getValue() || 0; const o = Math.max(e, i, n);t.setLayout({ value: o }, !0);
        });
      }(s)), (function (t, e, i, n, o, a, r, s, l) {
        (function (t, e, i, n, o, a, r) {
          for (var s = [], l = [], u = [], h = [], c = 0, d = 0;d < e.length;d++)s[d] = 1;for (d = 0;d < t.length;d++)l[d] = t[d].inEdges.length, 0 === l[d] && u.push(t[d]);let f = -1;for (;u.length;) {
            for (let p = 0;p < u.length;p++) {
              const g = u[p]; const m = g.hostGraph.data.getRawDataItem(g.dataIndex); const v = null != m.depth && 0 <= m.depth;v && m.depth > f && (f = m.depth), g.setLayout({ depth: v ? m.depth : c }, !0), 'vertical' === a ? g.setLayout({ dy: i }, !0) : g.setLayout({ dx: i }, !0);for (let y = 0;y < g.outEdges.length;y++) {
                const x = g.outEdges[y]; const _ = e.indexOf(x);s[_] = 0;const w = x.node2; const b = t.indexOf(w);0 == --l[b] && h.indexOf(w) < 0 && h.push(w);
              }
            }++c, u = h, h = [];
          } for (d = 0;d < s.length;d++) if (1 === s[d]) throw new Error('Sankey is a DAG, the original data has cycle!');const S = c - 1 < f ? f : c - 1;r && 'left' !== r && (function (t, e, i, n) {
            if ('right' === e) {
              for (let o = [], a = t, r = 0;a.length;) {
                for (let s = 0;s < a.length;s++) {
                  const l = a[s];l.setLayout({ skNodeHeight: r }, !0);for (let u = 0;u < l.inEdges.length;u++) {
                    const h = l.inEdges[u];o.indexOf(h.node1) < 0 && o.push(h.node1);
                  }
                }a = o, o = [], ++r;
              }R(t, (t) => {
                PS(t) || t.setLayout({ depth: Math.max(0, n - t.getLayout().skNodeHeight) }, !0);
              });
            } else 'justify' === e && (function (t, e) {
              R(t, (t) => {
                PS(t) || t.outEdges.length || t.setLayout({ depth: e }, !0);
              });
            }(t, n));
          }(t, r, 0, S));!(function (t, i, n) {
            R(t, (t) => {
              const e = t.getLayout().depth * i;'vertical' === n ? t.setLayout({ y: e }, !0) : t.setLayout({ x: e }, !0);
            });
          }(t, 'vertical' === a ? (o - i) / S : (n - i) / S, a));
        }(t, e, i, o, a, s, l)), (function (t, e, i, n, o, a, r) {
          const s = (function (t, e) {
            const i = []; const n = 'vertical' === e ? 'y' : 'x'; const o = ta(t, t => t.getLayout()[n]);return o.keys.sort((t, e) => t - e), R(o.keys, (t) => {
              i.push(o.buckets.get(t));
            }), i;
          }(t, r));(function (t, e, o, a, r, s) {
            let l = 1 / 0;R(t, (t) => {
              const e = t.length; let i = 0;R(t, (t) => {
                i += t.getLayout().value;
              });const n = 'vertical' === s ? (a - (e - 1) * r) / i : (o - (e - 1) * r) / i;n < l && (l = n);
            }), R(t, (t) => {
              R(t, (t, e) => {
                const i = t.getLayout().value * l;'vertical' === s ? (t.setLayout({ x: e }, !0), t.setLayout({ dx: i }, !0)) : (t.setLayout({ y: e }, !0), t.setLayout({ dy: i }, !0));
              });
            }), R(e, (t) => {
              const e = +t.getValue() * l;t.setLayout({ dy: e }, !0);
            });
          }(s, e, i, n, o, r)), NS(s, o, i, n, r);for (let l = 1;0 < a;a--)OS(s, l *= .99, r), NS(s, o, i, n, r), WS(s, l, r), NS(s, o, i, n, r);
        }(t, e, a, o, n, r, s)), (function (t, e) {
          const i = 'vertical' === e ? 'x' : 'y';R(t, (t) => {
            t.outEdges.sort((t, e) => t.node2.getLayout()[i] - e.node2.getLayout()[i]), t.inEdges.sort((t, e) => t.node1.getLayout()[i] - e.node1.getLayout()[i]);
          }), R(t, (t) => {
            let e = 0; let i = 0;R(t.outEdges, (t) => {
              t.setLayout({ sy: e }, !0), e += t.getLayout().dy;
            }), R(t.inEdges, (t) => {
              t.setLayout({ ty: i }, !0), i += t.getLayout().dy;
            });
          });
        }(t, s));
      }(s, l, e, i, o, a, 0 !== M(s, t => 0 === t.getLayout().value).length ? 0 : t.get('layoutIterations'), t.get('orient'), t.get('nodeAlign')));
    });
  }), Sf((t, e) => {
    t.eachSeriesByType('sankey', (n) => {
      const t = n.getGraph().nodes;if (t.length) {
        let o = 1 / 0; let a = -1 / 0;R(t, (t) => {
          const e = t.getLayout().value;e < o && (o = e), a < e && (a = e);
        }), R(t, (t) => {
          const e = new g_({ type: 'color', mappingMethod: 'linear', dataExtent: [o, a], visual: n.get('color') }).mapValueToVisual(t.getLayout().value); const i = t.getModel().get('itemStyle.color');null != i ? t.setVisual('color', i) : t.setVisual('color', e);
        });
      }
    });
  });const HS = { _baseAxisDim: null, getInitialData(t, e) {
    let i; let n; const o = e.getComponent('xAxis', this.get('xAxisIndex')); const a = e.getComponent('yAxis', this.get('yAxisIndex')); const r = o.get('type'); const s = a.get('type');'category' === r ? (t.layout = 'horizontal', i = o.getOrdinalMeta(), n = !0) : 'category' === s ? (t.layout = 'vertical', i = a.getOrdinalMeta(), n = !0) : t.layout = t.layout || 'horizontal';const l = ['x', 'y']; const u = 'horizontal' === t.layout ? 0 : 1; const h = this._baseAxisDim = l[u]; const c = l[1 - u]; const d = [o, a]; const f = d[u].get('type'); const p = d[1 - u].get('type'); const g = t.data;if (g && n) {
      const m = [];R(g, (t, e) => {
        let i;t.value && L(t.value) ? (i = t.value.slice(), t.value.unshift(e)) : L(t) ? (i = t.slice(), t.unshift(e)) : i = t, m.push(i);
      }), t.data = m;
    } const v = this.defaultValueDimensions; const y = [{ name: h, type: Rf(f), ordinalMeta: i, otherDims: { tooltip: !1, itemName: 0 }, dimsDef: ['base'] }, { name: c, type: Rf(p), dimsDef: v.slice() }];return Yv(this, { coordDimensions: y, dimensionsCount: v.length + 1, encodeDefaulter: T($u, y, this) });
  }, getBaseAxis() {
    const t = this._baseAxisDim;return this.ecModel.getComponent(`${t}Axis`, this.get(`${t}AxisIndex`)).axis;
  } };b(sc.extend({ type: 'series.boxplot', dependencies: ['xAxis', 'yAxis', 'grid'], defaultValueDimensions: [{ name: 'min', defaultTooltip: !0 }, { name: 'Q1', defaultTooltip: !0 }, { name: 'median', defaultTooltip: !0 }, { name: 'Q3', defaultTooltip: !0 }, { name: 'max', defaultTooltip: !0 }], dimensions: null, defaultOption: { zlevel: 0, z: 2, coordinateSystem: 'cartesian2d', legendHoverLink: !0, hoverAnimation: !0, layout: null, boxWidth: [7, 50], itemStyle: { color: '#fff', borderWidth: 1 }, emphasis: { itemStyle: { borderWidth: 2, shadowBlur: 5, shadowOffsetX: 2, shadowOffsetY: 2, shadowColor: 'rgba(0,0,0,0.4)' } }, animationEasing: 'elasticOut', animationDuration: 800 } }), HS, !0);const ZS = ['itemStyle']; const US = ['emphasis', 'itemStyle']; const XS = (_c.extend({ type: 'boxplot', render(t, e, i) {
    const o = t.getData(); const a = this.group; const r = this._data;this._data || a.removeAll();const s = 'horizontal' === t.get('layout') ? 1 : 0;o.diff(r).add((t) => {
      if (o.hasValue(t)) {
        const e = YS(o.getItemLayout(t), o, t, s, !0);o.setItemGraphicEl(t, e), a.add(e);
      }
    })
      .update((t, e) => {
        let i = r.getItemGraphicEl(e);if (o.hasValue(t)) {
          const n = o.getItemLayout(t);i ? jS(n, i, o, t) : i = YS(n, o, t, s), a.add(i), o.setItemGraphicEl(t, i);
        } else a.remove(i);
      })
      .remove((t) => {
        const e = r.getItemGraphicEl(t);e && a.remove(e);
      })
      .execute(), this._data = o;
  }, remove(t) {
    const e = this.group; const i = this._data;this._data = null, i && i.eachItemGraphicEl((t) => {
      t && e.remove(t);
    });
  }, dispose: et }), Ar.extend({ type: 'boxplotBoxPath', shape: {}, buildPath(t, e) {
    const i = e.points; let n = 0;for (t.moveTo(i[n][0], i[n][1]), n++;n < 4;n++)t.lineTo(i[n][0], i[n][1]);for (t.closePath();n < i.length;n++)t.moveTo(i[n][0], i[n][1]), n++, t.lineTo(i[n][0], i[n][1]);
  } }));function YS(t, e, i, n, o) {
    const a = t.ends; const r = new XS({ shape: { points: o ? (function (t, e, i) {
      return O(t, t => ((t = t.slice())[e] = i.initBaseline, t));
    }(a, n, t)) : a } });return jS(t, r, e, i, o), r;
  } function jS(t, e, i, n, o) {
    const a = i.hostModel;(0, bl[o ? 'initProps' : 'updateProps'])(e, { shape: { points: t.ends } }, a, n);const r = i.getItemModel(n); const s = r.getModel(ZS); const l = i.getItemVisual(n, 'color'); const u = s.getItemStyle(['borderColor']);u.stroke = l, u.strokeNoScale = !0, e.useStyle(u), e.z2 = 100, $s(e, r.getModel(US).getItemStyle());
  } const qS = ['itemStyle', 'borderColor']; const KS = R;Sf((n, t) => {
    const o = n.get('color');n.eachRawSeriesByType('boxplot', (t) => {
      const e = o[t.seriesIndex % o.length]; const i = t.getData();i.setVisual({ legendSymbol: 'roundRect', color: t.get(qS) || e }), n.isSeriesFiltered(t) || i.each((t) => {
        const e = i.getItemModel(t);i.setItemVisual(t, { color: e.get(qS, !0) });
      });
    });
  }), bf((t) => {
    const e = (function (t) {
      const n = []; const o = [];return t.eachSeriesByType('boxplot', (t) => {
        const e = t.getBaseAxis(); let i = _(o, e);i < 0 && (i = o.length, o[i] = e, n[i] = { axis: e, seriesModels: [] }), n[i].seriesModels.push(t);
      }), n;
    }(t));KS(e, (i) => {
      const t = i.seriesModels;t.length && ((function (t) {
        let e; let i; const n = t.axis; const o = t.seriesModels; const a = o.length; const r = t.boxWidthList = []; const s = t.boxOffsetList = []; const l = [];if ('category' === n.type)i = n.getBandWidth();else {
          let u = 0;KS(o, (t) => {
            u = Math.max(u, t.getData().count());
          }), e = n.getExtent(), Math.abs(e[1] - e[0]);
        }KS(o, (t) => {
          let e = t.get('boxWidth');L(e) || (e = [e, e]), l.push([El(e[0], i) || 0, El(e[1], i) || 0]);
        });const h = .8 * i - 2; const c = h / a * .3; const d = (h - c * (a - 1)) / a; let f = d / 2 - h / 2;KS(o, (t, e) => {
          s.push(f), f += c + d, r.push(Math.min(Math.max(d, l[e][0]), l[e][1]));
        });
      }(i)), KS(t, (t, e) => {
        !(function (t, r, e) {
          const s = t.coordinateSystem; const l = t.getData(); const a = e / 2; const u = 'horizontal' === t.get('layout') ? 0 : 1; const h = 1 - u; const i = ['x', 'y']; const n = l.mapDimension(i[u]); const o = l.mapDimension(i[h], !0);if (null == n || o.length < 5) return;for (let c = 0;c < l.count();c++) {
            const d = l.get(n, c); const f = x(d, o[2], c); const p = x(d, o[0], c); const g = x(d, o[1], c); const m = x(d, o[3], c); const v = x(d, o[4], c); const y = [];_(y, g, 0), _(y, m, 1), y.push(p, g, v, m), w(y, p), w(y, v), w(y, f), l.setItemLayout(c, { initBaseline: f[h], ends: y });
          } function x(t, e, i) {
            let n; const o = l.get(e, i); const a = [];return a[u] = t, a[h] = o, isNaN(t) || isNaN(o) ? n = [NaN, NaN] : (n = s.dataToPoint(a))[u] += r, n;
          } function _(t, e, i) {
            const n = e.slice(); const o = e.slice();n[u] += a, o[u] -= a, i ? t.push(n, o) : t.push(o, n);
          } function w(t, e) {
            const i = e.slice(); const n = e.slice();i[u] -= a, n[u] += a, t.push(i, n);
          }
        }(t, i.boxOffsetList[e], i.boxWidthList[e]));
      }));
    });
  }), b(sc.extend({ type: 'series.candlestick', dependencies: ['xAxis', 'yAxis', 'grid'], defaultValueDimensions: [{ name: 'open', defaultTooltip: !0 }, { name: 'close', defaultTooltip: !0 }, { name: 'lowest', defaultTooltip: !0 }, { name: 'highest', defaultTooltip: !0 }], dimensions: null, defaultOption: { zlevel: 0, z: 2, coordinateSystem: 'cartesian2d', legendHoverLink: !0, hoverAnimation: !0, layout: null, clip: !0, itemStyle: { color: '#c23531', color0: '#314656', borderWidth: 1, borderColor: '#c23531', borderColor0: '#314656' }, emphasis: { itemStyle: { borderWidth: 2 } }, barMaxWidth: null, barMinWidth: null, barWidth: null, large: !0, largeThreshold: 600, progressive: 3e3, progressiveThreshold: 1e4, progressiveChunkMode: 'mod', animationUpdate: !1, animationEasing: 'linear', animationDuration: 300 }, getShadowDim() {
    return 'open';
  }, brushSelector(t, e, i) {
    const n = e.getItemLayout(t);return n && i.rect(n.brushRect);
  } }), HS, !0);const $S = ['itemStyle']; const JS = ['emphasis', 'itemStyle']; const QS = ['color', 'color0', 'borderColor', 'borderColor0']; const tM = (_c.extend({ type: 'candlestick', render(t, e, i) {
    this.group.removeClipPath(), this._updateDrawMode(t), this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t);
  }, incrementalPrepareRender(t, e, i) {
    this._clear(), this._updateDrawMode(t);
  }, incrementalRender(t, e, i, n) {
    this._isLargeDraw ? this._incrementalRenderLarge(t, e) : this._incrementalRenderNormal(t, e);
  }, _updateDrawMode(t) {
    const e = t.pipelineContext.large;(null == this._isLargeDraw || e ^ this._isLargeDraw) && (this._isLargeDraw = e, this._clear());
  }, _renderNormal(o) {
    const a = o.getData(); const r = this._data; const s = this.group; const l = a.getLayout('isSimpleBox'); const u = o.get('clip', !0); const t = o.coordinateSystem; const h = t.getArea && t.getArea();this._data || s.removeAll(), a.diff(r).add((t) => {
      if (a.hasValue(t)) {
        let e; const i = a.getItemLayout(t);if (u && iM(h, i)) return;dl(e = eM(i, t, !0), { shape: { points: i.ends } }, o, t), nM(e, a, t, l), s.add(e), a.setItemGraphicEl(t, e);
      }
    })
      .update((t, e) => {
        let i = r.getItemGraphicEl(e);if (a.hasValue(t)) {
          const n = a.getItemLayout(t);u && iM(h, n) ? s.remove(i) : (i ? cl(i, { shape: { points: n.ends } }, o, t) : i = eM(n, t), nM(i, a, t, l), s.add(i), a.setItemGraphicEl(t, i));
        } else s.remove(i);
      })
      .remove((t) => {
        const e = r.getItemGraphicEl(t);e && s.remove(e);
      })
      .execute(), this._data = a;
  }, _renderLarge(t) {
    this._clear(), aM(t, this.group);const e = t.get('clip', !0) ? Sm(t.coordinateSystem, !1, t) : null;e ? this.group.setClipPath(e) : this.group.removeClipPath();
  }, _incrementalRenderNormal(t, e) {
    for (var i, n = e.getData(), o = n.getLayout('isSimpleBox');null != (i = t.next());) {
      var a;nM(a = eM(n.getItemLayout(i), i), n, i, o), a.incremental = !0, this.group.add(a);
    }
  }, _incrementalRenderLarge(t, e) {
    aM(e, this.group, !0);
  }, remove(t) {
    this._clear();
  }, _clear() {
    this.group.removeAll(), this._data = null;
  }, dispose: et }), Ar.extend({ type: 'normalCandlestickBox', shape: {}, buildPath(t, e) {
    const i = e.points;this.__simpleBox ? (t.moveTo(i[4][0], i[4][1]), t.lineTo(i[6][0], i[6][1])) : (t.moveTo(i[0][0], i[0][1]), t.lineTo(i[1][0], i[1][1]), t.lineTo(i[2][0], i[2][1]), t.lineTo(i[3][0], i[3][1]), t.closePath(), t.moveTo(i[4][0], i[4][1]), t.lineTo(i[5][0], i[5][1]), t.moveTo(i[6][0], i[6][1]), t.lineTo(i[7][0], i[7][1]));
  } }));function eM(t, e, i) {
    const n = t.ends;return new tM({ shape: { points: i ? (function (t, e) {
      return O(t, t => ((t = t.slice())[1] = e.initBaseline, t));
    }(n, t)) : n }, z2: 100 });
  } function iM(t, e) {
    for (var i = !0, n = 0;n < e.ends.length;n++) if (t.contain(e.ends[n][0], e.ends[n][1])) {
      i = !1;break;
    } return i;
  } function nM(t, e, i, n) {
    const o = e.getItemModel(i); const a = o.getModel($S); const r = e.getItemVisual(i, 'color'); const s = e.getItemVisual(i, 'borderColor') || r; const l = a.getItemStyle(QS);t.useStyle(l), t.style.strokeNoScale = !0, t.style.fill = r, t.style.stroke = s, t.__simpleBox = n, $s(t, o.getModel(JS).getItemStyle());
  } const oM = Ar.extend({ type: 'largeCandlestickBox', shape: {}, buildPath(t, e) {
    for (let i = e.points, n = 0;n < i.length;) if (this.__sign === i[n++]) {
      const o = i[n++];t.moveTo(o, i[n++]), t.lineTo(o, i[n++]);
    } else n += 3;
  } });function aM(t, e, i) {
    const n = t.getData(); const o = n.getLayout('largePoints'); const a = new oM({ shape: { points: o }, __sign: 1 });e.add(a);const r = new oM({ shape: { points: o }, __sign: -1 });e.add(r), rM(1, a, t, n), rM(-1, r, t, n), i && (a.incremental = !0, r.incremental = !0);
  } function rM(t, e, i, n) {
    const o = 0 < t ? 'P' : 'N'; const a = n.getVisual(`borderColor${o}`) || n.getVisual(`color${o}`); const r = i.getModel($S).getItemStyle(QS);e.useStyle(r), e.style.fill = null, e.style.stroke = a;
  } const sM = ['itemStyle', 'borderColor']; const lM = ['itemStyle', 'borderColor0']; const uM = ['itemStyle', 'color']; const hM = ['itemStyle', 'color0']; const cM = { seriesType: 'candlestick', plan: vc(), performRawSeries: !0, reset(t, e) {
    if (t.getData().setVisual({ legendSymbol: 'roundRect', colorP: a(1, t), colorN: a(-1, t), borderColorP: r(1, t), borderColorN: r(-1, t) }), !e.isSeriesFiltered(t)) return !t.pipelineContext.large && { progress(t, e) {
      let i;for (;null != (i = t.next());) {
        const n = e.getItemModel(i); const o = e.getItemLayout(i).sign;e.setItemVisual(i, { color: a(o, n), borderColor: r(o, n) });
      }
    } };function a(t, e) {
      return e.get(0 < t ? uM : hM);
    } function r(t, e) {
      return e.get(0 < t ? sM : lM);
    }
  } }; const dM = 'undefined' !== typeof Float32Array ? Float32Array : Array; const fM = { seriesType: 'candlestick', plan: vc(), reset(t) {
    const x = t.coordinateSystem; const e = t.getData(); const _ = (function (t, e) {
      let i; const n = t.getBaseAxis(); const o = 'category' === n.type ? n.getBandWidth() : (i = n.getExtent(), Math.abs(i[1] - i[0]) / e.count()); const a = El(H(t.get('barMaxWidth'), o), o); const r = El(H(t.get('barMinWidth'), 1), o); const s = t.get('barWidth');return null != s ? El(s, o) : Math.max(Math.min(o / 2, a), r);
    }(t, e)); const i = ['x', 'y']; const w = e.mapDimension(i[0]); const n = e.mapDimension(i[1], !0); const b = n[0]; const S = n[1]; const M = n[2]; const I = n[3];if (e.setLayout({ candleWidth: _, isSimpleBox: _ <= 1.3 }), !(null == w || n.length < 4)) return { progress: t.pipelineContext.large ? function (t, e) {
      let i; let n; const o = new dM(4 * t.count); let a = 0; const r = []; const s = [];for (;null != (n = t.next());) {
        const l = e.get(w, n); const u = e.get(b, n); const h = e.get(S, n); const c = e.get(M, n); const d = e.get(I, n);isNaN(l) || isNaN(c) || isNaN(d) ? (o[a++] = NaN, a += 3) : (o[a++] = pM(e, n, u, h, S), r[0] = l, r[1] = c, i = x.dataToPoint(r, null, s), o[a++] = i ? i[0] : NaN, o[a++] = i ? i[1] : NaN, r[1] = d, i = x.dataToPoint(r, null, s), o[a++] = i ? i[1] : NaN);
      }e.setLayout('largePoints', o);
    } : function (t, e) {
      let i;for (;null != (i = t.next());) {
        const n = e.get(w, i); const o = e.get(b, i); const a = e.get(S, i); const r = e.get(M, i); const s = e.get(I, i); const l = Math.min(o, a); const u = Math.max(o, a); const h = g(l, n); const c = g(u, n); const d = g(r, n); const f = g(s, n); const p = [];m(p, c, 0), m(p, h, 1), p.push(y(f), y(c), y(d), y(h)), e.setItemLayout(i, { sign: pM(e, i, o, a, S), initBaseline: a < o ? c[1] : h[1], ends: p, brushRect: v(r, s, n) });
      } function g(t, e) {
        const i = [];return i[0] = e, i[1] = t, isNaN(e) || isNaN(t) ? [NaN, NaN] : x.dataToPoint(i);
      } function m(t, e, i) {
        const n = e.slice(); const o = e.slice();n[0] = zs(n[0] + _ / 2, 1, !1), o[0] = zs(o[0] - _ / 2, 1, !0), i ? t.push(n, o) : t.push(o, n);
      } function v(t, e, i) {
        const n = g(t, i); const o = g(e, i);return n[0] -= _ / 2, o[0] -= _ / 2, { x: n[0], y: n[1], width: _, height: o[1] - n[1] };
      } function y(t) {
        return t[0] = zs(t[0], 1), t;
      }
    } };
  } };function pM(t, e, i, n, o) {
    return n < i ? -1 : i < n ? 1 : 0 < e ? t.get(o, e - 1) <= n ? 1 : -1 : 1;
  }yf((t) => {
    t && L(t.series) && R(t.series, (t) => {
      z(t) && 'k' === t.type && (t.type = 'candlestick');
    });
  }), Sf(cM), bf(fM), sc.extend({ type: 'series.effectScatter', dependencies: ['grid', 'polar'], getInitialData(t, e) {
    return gp(this.getSource(), this, { useEncodeDefaulter: !0 });
  }, brushSelector: 'point', defaultOption: { coordinateSystem: 'cartesian2d', zlevel: 0, z: 2, legendHoverLink: !0, effectType: 'ripple', progressive: 0, showEffectOn: 'render', rippleEffect: { period: 4, scale: 2.5, brushType: 'fill' }, symbolSize: 10 } });function gM(t, e) {
    const i = e.rippleEffectColor || e.color;t.eachChild((t) => {
      t.attr({ z: e.z, zlevel: e.zlevel, style: { stroke: 'stroke' === e.brushType ? i : null, fill: 'fill' === e.brushType ? i : null } });
    });
  } function mM(t, e) {
    Ci.call(this);const i = new Xg(t, e); const n = new Ci;this.add(i), this.add(n), n.beforeUpdate = function () {
      this.attr(i.getScale());
    }, this.updateData(t, e);
  } const vM = mM.prototype;vM.stopEffectAnimation = function () {
    this.childAt(1).removeAll();
  }, vM.startEffectAnimation = function (t) {
    for (var e = t.symbolType, i = t.color, n = this.childAt(1), o = 0;o < 3;o++) {
      const a = wg(e, -1, -1, 2, 2, i);a.attr({ style: { strokeNoScale: !0 }, z2: 99, silent: !0, scale: [.5, .5] });const r = -o / 3 * t.period + t.effectOffset;a.animate('', !0).when(t.period, { scale: [t.rippleScale / 2, t.rippleScale / 2] })
        .delay(r)
        .start(), a.animateStyle(!0).when(t.period, { opacity: 0 })
        .delay(r)
        .start(), n.add(a);
    }gM(n, t);
  }, vM.updateEffectAnimation = function (t) {
    for (var e = this._effectCfg, i = this.childAt(1), n = ['symbolType', 'period', 'rippleScale'], o = 0;o < n.length;o++) {
      const a = n[o];if (e[a] !== t[a]) return this.stopEffectAnimation(), void this.startEffectAnimation(t);
    }gM(i, t);
  }, vM.highlight = function () {
    this.trigger('emphasis');
  }, vM.downplay = function () {
    this.trigger('normal');
  }, vM.updateData = function (t, e) {
    const i = t.hostModel;this.childAt(0).updateData(t, e);const n = this.childAt(1); const o = t.getItemModel(e); const a = t.getItemVisual(e, 'symbol'); const r = (function (t) {
      return L(t) || (t = [+t, +t]), t;
    }(t.getItemVisual(e, 'symbolSize'))); const s = t.getItemVisual(e, 'color');n.attr('scale', r), n.traverse((t) => {
      t.attr({ fill: s });
    });const l = o.getShallow('symbolOffset');if (l) {
      const u = n.position;u[0] = El(l[0], r[0]), u[1] = El(l[1], r[1]);
    } const h = t.getItemVisual(e, 'symbolRotate');n.rotation = (h || 0) * Math.PI / 180 || 0;const c = {};if (c.showEffectOn = i.get('showEffectOn'), c.rippleScale = o.get('rippleEffect.scale'), c.brushType = o.get('rippleEffect.brushType'), c.period = 1e3 * o.get('rippleEffect.period'), c.effectOffset = e / t.count(), c.z = o.getShallow('z') || 0, c.zlevel = o.getShallow('zlevel') || 0, c.symbolType = a, c.color = s, c.rippleEffectColor = o.get('rippleEffect.color'), this.off('mouseover').off('mouseout')
      .off('emphasis')
      .off('normal'), 'render' === c.showEffectOn) this._effectCfg ? this.updateEffectAnimation(c) : this.startEffectAnimation(c), this._effectCfg = c;else {
      this._effectCfg = null, this.stopEffectAnimation();const d = this.childAt(0); const f = function () {
        d.highlight(), 'render' !== c.showEffectOn && this.startEffectAnimation(c);
      }; const p = function () {
        d.downplay(), 'render' !== c.showEffectOn && this.stopEffectAnimation();
      };this.on('mouseover', f, this).on('mouseout', p, this)
        .on('emphasis', f, this)
        .on('normal', p, this);
    } this._effectCfg = c;
  }, vM.fadeOut = function (t) {
    this.off('mouseover').off('mouseout')
      .off('emphasis')
      .off('normal'), t && t();
  }, w(mM, Ci), Cf({ type: 'effectScatter', init() {
    this._symbolDraw = new im(mM);
  }, render(t, e, i) {
    const n = t.getData(); const o = this._symbolDraw;o.updateData(n), this.group.add(o.group);
  }, updateTransform(t, e, i) {
    const n = t.getData();this.group.dirty();const o = km().reset(t);o.progress && o.progress({ start: 0, end: n.count() }, n), this._symbolDraw.updateLayout(n);
  }, _updateGroupTransform(t) {
    const e = t.coordinateSystem;e && e.getRoamTransform && (this.group.transform = fe(e.getRoamTransform()), this.group.decomposeTransform());
  }, remove(t, e) {
    this._symbolDraw && this._symbolDraw.remove(e);
  }, dispose() {} }), Sf(Lm('effectScatter', 'circle')), bf(km('effectScatter'));const yM = 'undefined' === typeof Uint32Array ? Array : Uint32Array; const xM = 'undefined' === typeof Float64Array ? Array : Float64Array;function _M(t) {
    const e = t.data;e && e[0] && e[0][0] && e[0][0].coord && (t.data = O(e, (t) => {
      const e = { coords: [t[0].coord, t[1].coord] };return t[0].name && (e.fromName = t[0].name), t[1].name && (e.toName = t[1].name), p([e, t[0], t[1]]);
    }));
  } var wM = sc.extend({ type: 'series.lines', dependencies: ['grid', 'polar'], visualColorAccessPath: 'lineStyle.color', init(t) {
    t.data = t.data || [], _M(t);const e = this._processFlatCoordsArray(t.data);this._flatCoords = e.flatCoords, this._flatCoordsOffset = e.flatCoordsOffset, e.flatCoords && (t.data = new Float32Array(e.count)), wM.superApply(this, 'init', arguments);
  }, mergeOption(t) {
    if (_M(t), t.data) {
      const e = this._processFlatCoordsArray(t.data);this._flatCoords = e.flatCoords, this._flatCoordsOffset = e.flatCoordsOffset, e.flatCoords && (t.data = new Float32Array(e.count));
    }wM.superApply(this, 'mergeOption', arguments);
  }, appendData(t) {
    const e = this._processFlatCoordsArray(t.data);e.flatCoords && (this._flatCoords ? (this._flatCoords = tt(this._flatCoords, e.flatCoords), this._flatCoordsOffset = tt(this._flatCoordsOffset, e.flatCoordsOffset)) : (this._flatCoords = e.flatCoords, this._flatCoordsOffset = e.flatCoordsOffset), t.data = new Float32Array(e.count)), this.getRawData().appendData(t.data);
  }, _getCoordsFromItemModel(t) {
    const e = this.getData().getItemModel(t);return e.option instanceof Array ? e.option : e.getShallow('coords');
  }, getLineCoordsCount(t) {
    return this._flatCoordsOffset ? this._flatCoordsOffset[2 * t + 1] : this._getCoordsFromItemModel(t).length;
  }, getLineCoords(t, e) {
    if (this._flatCoordsOffset) {
      for (var i = this._flatCoordsOffset[2 * t], n = this._flatCoordsOffset[2 * t + 1], o = 0;o < n;o++)e[o] = e[o] || [], e[o][0] = this._flatCoords[i + 2 * o], e[o][1] = this._flatCoords[i + 2 * o + 1];return n;
    } const a = this._getCoordsFromItemModel(t);for (o = 0;o < a.length;o++)e[o] = e[o] || [], e[o][0] = a[o][0], e[o][1] = a[o][1];return a.length;
  }, _processFlatCoordsArray(t) {
    let e = 0;if (this._flatCoords && (e = this._flatCoords.length), 'number' !== typeof t[0]) return { flatCoordsOffset: null, flatCoords: null, count: t.length };for (var i = t.length, n = new yM(i), o = new xM(i), a = 0, r = 0, s = 0, l = 0;l < i;) {
      s++;const u = t[l++];n[r++] = a + e, n[r++] = u;for (let h = 0;h < u;h++) {
        const c = t[l++]; const d = t[l++];o[a++] = c, o[a++] = d;
      }
    } return { flatCoordsOffset: new Uint32Array(n.buffer, 0, r), flatCoords: o, count: s };
  }, getInitialData(t, e) {
    const a = new Yf(['value'], this);return a.hasItemOption = !1, a.initData(t.data, [], (t, e, i, n) => {
      if (t instanceof Array) return NaN;a.hasItemOption = !0;const o = t.value;return null != o ? o instanceof Array ? o[n] : o : void 0;
    }), a;
  }, formatTooltip(t) {
    const e = this.getData().getItemModel(t); const i = e.get('name');if (i) return i;const n = e.get('fromName'); const o = e.get('toName'); const a = [];return null != n && a.push(n), null != o && a.push(o), au(a.join(' > '));
  }, preventIncremental() {
    return !!this.get('effect.show');
  }, getProgressive() {
    const t = this.option.progressive;return null == t ? this.option.large ? 1e4 : this.get('progressive') : t;
  }, getProgressiveThreshold() {
    const t = this.option.progressiveThreshold;return null == t ? this.option.large ? 2e4 : this.get('progressiveThreshold') : t;
  }, defaultOption: { coordinateSystem: 'geo', zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, xAxisIndex: 0, yAxisIndex: 0, symbol: ['none', 'none'], symbolSize: [10, 10], geoIndex: 0, effect: { show: !1, period: 4, constantSpeed: 0, symbol: 'circle', symbolSize: 3, loop: !0, trailLength: .2 }, large: !1, largeThreshold: 2e3, polyline: !1, clip: !0, label: { show: !1, position: 'end' }, lineStyle: { opacity: .5 } } });function bM(t, e, i) {
    Ci.call(this), this.add(this.createLine(t, e, i)), this._updateEffectSymbol(t, e);
  } const SM = bM.prototype;function MM(t, e, i) {
    Ci.call(this), this._createPolyline(t, e, i);
  }SM.createLine = function (t, e, i) {
    return new ww(t, e, i);
  }, SM._updateEffectSymbol = function (t, e) {
    const i = t.getItemModel(e).getModel('effect'); let n = i.get('symbolSize'); const o = i.get('symbol');L(n) || (n = [n, n]);const a = i.get('color') || t.getItemVisual(e, 'color'); let r = this.childAt(1);this._symbolType !== o && (this.remove(r), (r = wg(o, -.5, -.5, 1, 1, a)).z2 = 100, r.culling = !0, this.add(r)), r && (r.setStyle('shadowColor', a), r.setStyle(i.getItemStyle(['color'])), r.attr('scale', n), r.setColor(a), r.attr('scale', n), this._symbolType = o, this._symbolScale = n, this._updateEffectAnimation(t, i, e));
  }, SM._updateEffectAnimation = function (e, t, i) {
    const n = this.childAt(1);if (n) {
      const o = this; const a = e.getItemLayout(i); let r = 1e3 * t.get('period'); const s = t.get('loop'); const l = t.get('constantSpeed'); const u = W(t.get('delay'), t => t / e.count() * r / 3); const h = 'function' === typeof u;if (n.ignore = !0, this.updateAnimationPoints(n, a), 0 < l && (r = this.getLineLength(n) / l * 1e3), r !== this._period || s !== this._loop) {
        n.stopAnimation();let c = u;h && (c = u(i)), 0 < n.__t && (c = -r * n.__t), n.__t = 0;const d = n.animate('', s).when(r, { __t: 1 })
          .delay(c)
          .during(() => {
            o.updateSymbolPosition(n);
          });s || d.done(() => {
          o.remove(n);
        }), d.start();
      } this._period = r, this._loop = s;
    }
  }, SM.getLineLength = function (t) {
    return yt(t.__p1, t.__cp1) + yt(t.__cp1, t.__p2);
  }, SM.updateAnimationPoints = function (t, e) {
    t.__p1 = e[0], t.__p2 = e[1], t.__cp1 = e[2] || [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2];
  }, SM.updateData = function (t, e, i) {
    this.childAt(0).updateData(t, e, i), this._updateEffectSymbol(t, e);
  }, SM.updateSymbolPosition = function (t) {
    const e = t.__p1; const i = t.__p2; const n = t.__cp1; const o = t.__t; const a = t.position; const r = [a[0], a[1]]; const s = La; const l = ka;a[0] = s(e[0], n[0], i[0], o), a[1] = s(e[1], n[1], i[1], o);const u = l(e[0], n[0], i[0], o); const h = l(e[1], n[1], i[1], o);if (t.rotation = -Math.atan2(h, u) - Math.PI / 2, 'line' === this._symbolType || 'rect' === this._symbolType || 'roundRect' === this._symbolType) if (void 0 !== t.__lastT && t.__lastT < t.__t) {
      var c = 1.05 * yt(r, a);t.attr('scale', [t.scale[0], c]), 1 === o && (a[0] = r[0] + (a[0] - r[0]) / 2, a[1] = r[1] + (a[1] - r[1]) / 2);
    } else if (1 === t.__lastT) {
      c = 2 * yt(e, a);t.attr('scale', [t.scale[0], c]);
    } else t.attr('scale', this._symbolScale);t.__lastT = t.__t, t.ignore = !1;
  }, SM.updateLayout = function (t, e) {
    this.childAt(0).updateLayout(t, e);const i = t.getItemModel(e).getModel('effect');this._updateEffectAnimation(t, i, e);
  }, w(bM, Ci);const IM = MM.prototype;function TM(t, e, i) {
    bM.call(this, t, e, i), this._lastFrame = 0, this._lastFramePercent = 0;
  }IM._createPolyline = function (t, e, i) {
    const n = t.getItemLayout(e); const o = new ts({ shape: { points: n } });this.add(o), this._updateCommonStl(t, e, i);
  }, IM.updateData = function (t, e, i) {
    const n = t.hostModel;cl(this.childAt(0), { shape: { points: t.getItemLayout(e) } }, n, e), this._updateCommonStl(t, e, i);
  }, IM._updateCommonStl = function (t, e, i) {
    const n = this.childAt(0); const o = t.getItemModel(e); const a = t.getItemVisual(e, 'color'); let r = i && i.lineStyle; let s = i && i.hoverLineStyle;i && !t.hasItemOption || (r = o.getModel('lineStyle').getLineStyle(), s = o.getModel('emphasis.lineStyle').getLineStyle()), n.useStyle(D({ strokeNoScale: !0, fill: 'none', stroke: a }, r)), n.hoverStyle = s, $s(this);
  }, IM.updateLayout = function (t, e) {
    this.childAt(0).setShape('points', t.getItemLayout(e));
  }, w(MM, Ci);const AM = TM.prototype;AM.createLine = function (t, e, i) {
    return new MM(t, e, i);
  }, AM.updateAnimationPoints = function (t, e) {
    this._points = e;for (var i = [0], n = 0, o = 1;o < e.length;o++) {
      const a = e[o - 1]; const r = e[o];n += yt(a, r), i.push(n);
    } if (0 !== n) {
      for (o = 0;o < i.length;o++)i[o] /= n;this._offsets = i, this._length = n;
    }
  }, AM.getLineLength = function (t) {
    return this._length;
  }, AM.updateSymbolPosition = function (t) {
    const e = t.__t; const i = this._points; const n = this._offsets; const o = i.length;if (n) {
      const a = this._lastFrame;if (e < this._lastFramePercent) {
        for (r = Math.min(a + 1, o - 1);0 <= r && !(n[r] <= e);r--);r = Math.min(r, o - 2);
      } else {
        for (var r = a;r < o && !(n[r] > e);r++);r = Math.min(r - 1, o - 2);
      }wt(t.position, i[r], i[r + 1], (e - n[r]) / (n[r + 1] - n[r]));const s = i[r + 1][0] - i[r][0]; const l = i[r + 1][1] - i[r][1];t.rotation = -Math.atan2(l, s) - Math.PI / 2, this._lastFrame = r, this._lastFramePercent = e, t.ignore = !1;
    }
  }, w(TM, bM);const DM = Cs({ shape: { polyline: !1, curveness: 0, segs: [] }, buildPath(t, e) {
    const i = e.segs; const n = e.curveness;if (e.polyline) for (var o = 0;o < i.length;) {
      const a = i[o++];if (0 < a) {
        t.moveTo(i[o++], i[o++]);for (let r = 1;r < a;r++)t.lineTo(i[o++], i[o++]);
      }
    } else for (o = 0;o < i.length;) {
      const s = i[o++]; const l = i[o++]; const u = i[o++]; const h = i[o++];if (t.moveTo(s, l), 0 < n) {
        const c = (s + u) / 2 - (l - h) * n; const d = (l + h) / 2 - (u - s) * n;t.quadraticCurveTo(c, d, u, h);
      } else t.lineTo(u, h);
    }
  }, findDataIndex(t, e) {
    const i = this.shape; const n = i.segs; const o = i.curveness;if (i.polyline) for (var a = 0, r = 0;r < n.length;) {
      const s = n[r++];if (0 < s) for (var l = n[r++], u = n[r++], h = 1;h < s;h++) {
        if (sr(l, u, c = n[r++], d = n[r++])) return a;
      }a++;
    } else for (a = 0, r = 0;r < n.length;) {
      l = n[r++], u = n[r++];var c = n[r++]; var d = n[r++];if (0 < o) {
        if (ur(l, u, (l + c) / 2 - (u - d) * o, (u + d) / 2 - (c - l) * o, c, d)) return a;
      } else if (sr(l, u, c, d)) return a;a++;
    } return -1;
  } });function CM() {
    this.group = new Ci;
  } const LM = CM.prototype;LM.isPersistent = function () {
    return !this._incremental;
  }, LM.updateData = function (t) {
    this.group.removeAll();const e = new DM({ rectHover: !0, cursor: 'default' });e.setShape({ segs: t.getLayout('linesPoints') }), this._setCommon(e, t), this.group.add(e), this._incremental = null;
  }, LM.incrementalPrepareUpdate = function (t) {
    this.group.removeAll(), this._clearIncremental(), 5e5 < t.count() ? (this._incremental || (this._incremental = new vs({ silent: !0 })), this.group.add(this._incremental)) : this._incremental = null;
  }, LM.incrementalUpdate = function (t, e) {
    const i = new DM;i.setShape({ segs: e.getLayout('linesPoints') }), this._setCommon(i, e, !!this._incremental), this._incremental ? this._incremental.addDisplayable(i, !0) : (i.rectHover = !0, i.cursor = 'default', i.__startIndex = t.start, this.group.add(i));
  }, LM.remove = function () {
    this._clearIncremental(), this._incremental = null, this.group.removeAll();
  }, LM._setCommon = function (i, t, e) {
    const n = t.hostModel;i.setShape({ polyline: n.get('polyline'), curveness: n.get('lineStyle.curveness') }), i.useStyle(n.getModel('lineStyle').getLineStyle()), i.style.strokeNoScale = !0;const o = t.getVisual('color');o && i.setStyle('stroke', o), i.setStyle('fill'), e || (i.seriesIndex = n.seriesIndex, i.on('mousemove', (t) => {
      i.dataIndex = null;const e = i.findDataIndex(t.offsetX, t.offsetY);0 < e && (i.dataIndex = e + i.__startIndex);
    }));
  }, LM._clearIncremental = function () {
    const t = this._incremental;t && t.clearDisplaybles();
  };const kM = { seriesType: 'lines', plan: vc(), reset(g) {
    const m = g.coordinateSystem; const v = g.get('polyline'); const y = g.pipelineContext.large;return { progress(t, e) {
      const i = [];if (y) {
        let n; const o = t.end - t.start;if (v) {
          for (var a = 0, r = t.start;r < t.end;r++)a += g.getLineCoordsCount(r);n = new Float32Array(o + 2 * a);
        } else n = new Float32Array(4 * o);let s = 0; let l = [];for (r = t.start;r < t.end;r++) {
          var u = g.getLineCoords(r, i);v && (n[s++] = u);for (let h = 0;h < u;h++)l = m.dataToPoint(i[h], !1, l), n[s++] = l[0], n[s++] = l[1];
        }e.setLayout('linesPoints', n);
      } else for (r = t.start;r < t.end;r++) {
        const c = e.getItemModel(r); const d = (u = g.getLineCoords(r, i), []);if (v) for (let f = 0;f < u;f++)d.push(m.dataToPoint(i[f]));else {
          d[0] = m.dataToPoint(i[0]), d[1] = m.dataToPoint(i[1]);const p = c.get('lineStyle.curveness');+p && (d[2] = [(d[0][0] + d[1][0]) / 2 - (d[0][1] - d[1][1]) * p, (d[0][1] + d[1][1]) / 2 - (d[1][0] - d[0][0]) * p]);
        }e.setItemLayout(r, d);
      }
    } };
  } };function PM(t) {
    return t instanceof Array || (t = [t, t]), t;
  }Cf({ type: 'lines', init() {}, render(t, e, i) {
    const n = t.getData(); const o = this._updateLineDraw(n, t); const a = t.get('zlevel'); const r = t.get('effect.trailLength'); const s = i.getZr(); const l = 'svg' === s.painter.getType();l || s.painter.getLayer(a).clear(!0), null == this._lastZlevel || l || s.configLayer(this._lastZlevel, { motionBlur: !1 }), this._showEffect(t) && r && (l || s.configLayer(a, { motionBlur: !0, lastFrameAlpha: Math.max(Math.min(r / 10 + .9, 1), 0) })), o.updateData(n);const u = t.get('clip', !0) && Sm(t.coordinateSystem, !1, t);u ? this.group.setClipPath(u) : this.group.removeClipPath(), this._lastZlevel = a, this._finished = !0;
  }, incrementalPrepareRender(t, e, i) {
    const n = t.getData();this._updateLineDraw(n, t).incrementalPrepareUpdate(n), this._clearLayer(i), this._finished = !1;
  }, incrementalRender(t, e, i) {
    this._lineDraw.incrementalUpdate(t, e.getData()), this._finished = t.end === e.getData().count();
  }, updateTransform(t, e, i) {
    const n = t.getData(); const o = t.pipelineContext;if (!this._finished || o.large || o.progressiveRender) return { update: !0 };const a = kM.reset(t);a.progress && a.progress({ start: 0, end: n.count() }, n), this._lineDraw.updateLayout(), this._clearLayer(i);
  }, _updateLineDraw(t, e) {
    let i = this._lineDraw; const n = this._showEffect(e); const o = !!e.get('polyline'); const a = e.pipelineContext.large;return i && n === this._hasEffet && o === this._isPolyline && a === this._isLargeDraw || (i && i.remove(), i = this._lineDraw = a ? new CM : new Sw(o ? n ? TM : MM : n ? bM : ww), this._hasEffet = n, this._isPolyline = o, this._isLargeDraw = a, this.group.removeAll()), this.group.add(i.group), i;
  }, _showEffect(t) {
    return !!t.get('effect.show');
  }, _clearLayer(t) {
    const e = t.getZr();'svg' === e.painter.getType() || null == this._lastZlevel || e.painter.getLayer(this._lastZlevel).clear(!0);
  }, remove(t, e) {
    this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(e);
  }, dispose() {} });const NM = 'lineStyle.opacity'.split('.'); const OM = { seriesType: 'lines', reset(t, e, i) {
    const n = PM(t.get('symbol')); const o = PM(t.get('symbolSize')); const a = t.getData();return a.setVisual('fromSymbol', n && n[0]), a.setVisual('toSymbol', n && n[1]), a.setVisual('fromSymbolSize', o && o[0]), a.setVisual('toSymbolSize', o && o[1]), a.setVisual('opacity', t.get(NM)), { dataEach: a.hasItemOption ? function (t, e) {
      const i = t.getItemModel(e); const n = PM(i.getShallow('symbol', !0)); const o = PM(i.getShallow('symbolSize', !0)); const a = i.get(NM);n[0] && t.setItemVisual(e, 'fromSymbol', n[0]), n[1] && t.setItemVisual(e, 'toSymbol', n[1]), o[0] && t.setItemVisual(e, 'fromSymbolSize', o[0]), o[1] && t.setItemVisual(e, 'toSymbolSize', o[1]), t.setItemVisual(e, 'opacity', a);
    } : null };
  } };bf(kM), Sf(OM), sc.extend({ type: 'series.heatmap', getInitialData(t, e) {
    return gp(this.getSource(), this, { generateCoord: 'value' });
  }, preventIncremental() {
    const t = lh.get(this.get('coordinateSystem'));if (t && t.dimensions) return 'lng' === t.dimensions[0] && 'lat' === t.dimensions[1];
  }, defaultOption: { coordinateSystem: 'cartesian2d', zlevel: 0, z: 2, geoIndex: 0, blurSize: 30, pointSize: 20, maxOpacity: 1, minOpacity: 0 } });function RM() {
    const t = y();this.canvas = t, this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {};
  }RM.prototype = { update(t, e, i, n, o, a) {
    const r = this._getBrush(); const s = this._getGradient(t, o, 'inRange'); const l = this._getGradient(t, o, 'outOfRange'); const u = this.pointSize + this.blurSize; const h = this.canvas; const c = h.getContext('2d'); const d = t.length;h.width = e, h.height = i;for (let f = 0;f < d;++f) {
      const p = t[f]; const g = p[0]; const m = p[1]; var v = n(p[2]);c.globalAlpha = v, c.drawImage(r, g - u, m - u);
    } if (!h.width || !h.height) return h;for (var y = c.getImageData(0, 0, h.width, h.height), x = y.data, _ = 0, w = x.length, b = this.minOpacity, S = this.maxOpacity - b;_ < w;) {
      v = x[_ + 3] / 256;const M = 4 * Math.floor(255 * v);if (0 < v) {
        const I = a(v) ? s : l;0 < v && (v = v * S + b), x[_++] = I[M], x[_++] = I[1 + M], x[_++] = I[2 + M], x[_++] = I[3 + M] * v * 256;
      } else _ += 4;
    } return c.putImageData(y, 0, 0), h;
  }, _getBrush() {
    const t = this._brushCanvas || (this._brushCanvas = y()); const e = this.pointSize + this.blurSize; const i = 2 * e;t.width = i, t.height = i;const n = t.getContext('2d');return n.clearRect(0, 0, i, i), n.shadowOffsetX = i, n.shadowBlur = this.blurSize, n.shadowColor = '#000', n.beginPath(), n.arc(-e, e, this.pointSize, 0, 2 * Math.PI, !0), n.closePath(), n.fill(), t;
  }, _getGradient(t, e, i) {
    for (var n = this._gradientPixels, o = n[i] || (n[i] = new Uint8ClampedArray(1024)), a = [0, 0, 0, 0], r = 0, s = 0;s < 256;s++)e[i](s / 255, !0, a), o[r++] = a[0], o[r++] = a[1], o[r++] = a[2], o[r++] = a[3];return o;
  } }, Cf({ type: 'heatmap', render(i, t, e) {
    let n;t.eachComponent('visualMap', (e) => {
      e.eachTargetSeries((t) => {
        t === i && (n = e);
      });
    }), this.group.removeAll(), this._incrementalDisplayable = null;const o = i.coordinateSystem;'cartesian2d' === o.type || 'calendar' === o.type ? this._renderOnCartesianAndCalendar(i, e, 0, i.getData().count()) : (function (t) {
      const e = t.dimensions;return 'lng' === e[0] && 'lat' === e[1];
    }(o)) && this._renderOnGeo(o, i, n, e);
  }, incrementalPrepareRender(t, e, i) {
    this.group.removeAll();
  }, incrementalRender(t, e, i, n) {
    e.coordinateSystem && this._renderOnCartesianAndCalendar(e, n, t.start, t.end, !0);
  }, _renderOnCartesianAndCalendar(t, e, i, n, o) {
    let a; let r; const s = t.coordinateSystem;if ('cartesian2d' === s.type) {
      const l = s.getAxis('x'); const u = s.getAxis('y');a = l.getBandWidth(), r = u.getBandWidth();
    } for (let h = this.group, c = t.getData(), d = 'emphasis.itemStyle', f = 'emphasis.label', p = t.getModel('itemStyle').getItemStyle(['color']), g = t.getModel(d).getItemStyle(), m = t.getModel('label'), v = t.getModel(f), y = s.type, x = 'cartesian2d' === y ? [c.mapDimension('x'), c.mapDimension('y'), c.mapDimension('value')] : [c.mapDimension('time'), c.mapDimension('value')], _ = i;_ < n;_++) {
      var w;if ('cartesian2d' === y) {
        if (isNaN(c.get(x[2], _))) continue;const b = s.dataToPoint([c.get(x[0], _), c.get(x[1], _)]);w = new rs({ shape: { x: Math.floor(Math.round(b[0]) - a / 2), y: Math.floor(Math.round(b[1]) - r / 2), width: Math.ceil(a), height: Math.ceil(r) }, style: { fill: c.getItemVisual(_, 'color'), opacity: c.getItemVisual(_, 'opacity') } });
      } else {
        if (isNaN(c.get(x[1], _))) continue;w = new rs({ z2: 1, shape: s.dataToRect([c.get(x[0], _)]).contentShape, style: { fill: c.getItemVisual(_, 'color'), opacity: c.getItemVisual(_, 'opacity') } });
      } const S = c.getItemModel(_);c.hasItemOption && (p = S.getModel('itemStyle').getItemStyle(['color']), g = S.getModel(d).getItemStyle(), m = S.getModel('label'), v = S.getModel(f));const M = t.getRawValue(_); let I = '-';M && null != M[2] && (I = M[2]), el(p, g, m, v, { labelFetcher: t, labelDataIndex: _, defaultText: I, isRectText: !0 }), w.setStyle(p), $s(w, c.hasItemOption ? g : P({}, g)), (w.incremental = o) && (w.useHoverLayer = !0), h.add(w), c.setItemGraphicEl(_, w);
    }
  }, _renderOnGeo(o, t, e, i) {
    const n = e.targetVisuals.inRange; const a = e.targetVisuals.outOfRange; const r = t.getData(); const s = this._hmLayer || this._hmLayer || new RM;s.blurSize = t.get('blurSize'), s.pointSize = t.get('pointSize'), s.minOpacity = t.get('minOpacity'), s.maxOpacity = t.get('maxOpacity');const l = o.getViewRect().clone(); const u = o.getRoamTransform();l.applyTransform(u);const h = Math.max(l.x, 0); const c = Math.max(l.y, 0); const d = Math.min(l.width + l.x, i.getWidth()); const f = Math.min(l.height + l.y, i.getHeight()); const p = d - h; const g = f - c; const m = [r.mapDimension('lng'), r.mapDimension('lat'), r.mapDimension('value')]; const v = r.mapArray(m, (t, e, i) => {
      const n = o.dataToPoint([t, e]);return n[0] -= h, n[1] -= c, n.push(i), n;
    }); const y = e.getExtent(); const x = 'visualMap.continuous' === e.type ? (function (t, e) {
      const i = t[1] - t[0];return e = [(e[0] - t[0]) / i, (e[1] - t[0]) / i], function (t) {
        return t >= e[0] && t <= e[1];
      };
    }(y, e.option.range)) : (function (e, n, o) {
      const i = e[1] - e[0]; const a = (n = O(n, t => ({ interval: [(t.interval[0] - e[0]) / i, (t.interval[1] - e[0]) / i] }))).length; let r = 0;return function (t) {
        for (var e = r;e < a;e++) {
          if ((i = n[e].interval)[0] <= t && t <= i[1]) {
            r = e;break;
          }
        } if (e === a) for (e = r - 1;0 <= e;e--) {
          var i;if ((i = n[e].interval)[0] <= t && t <= i[1]) {
            r = e;break;
          }
        } return 0 <= e && e < a && o[e];
      };
    }(y, e.getPieceList(), e.option.selected));s.update(v, p, g, n.color.getNormalizer(), { inRange: n.color.getColorMapper(), outOfRange: a.color.getColorMapper() }, x);const _ = new Qn({ style: { width: p, height: g, x: h, y: c, image: s.canvas }, silent: !0 });this.group.add(_);
  }, dispose() {} });var EM = Tv.extend({ type: 'series.pictorialBar', dependencies: ['grid'], defaultOption: { symbol: 'circle', symbolSize: null, symbolRotate: null, symbolPosition: null, symbolOffset: null, symbolMargin: null, symbolRepeat: !1, symbolRepeatDirection: 'end', symbolClip: !1, symbolBoundingData: null, symbolPatternSize: 400, barGap: '-100%', progressive: 0, hoverAnimation: !1 }, getInitialData(t) {
    return t.stack = null, EM.superApply(this, 'getInitialData', arguments);
  } }); const zM = ['itemStyle', 'borderWidth']; const BM = [{ xy: 'x', wh: 'width', index: 0, posDesc: ['left', 'right'] }, { xy: 'y', wh: 'height', index: 1, posDesc: ['top', 'bottom'] }]; const VM = new Yr;Cf({ type: 'pictorialBar', render(t, e, i) {
    const r = this.group; const s = t.getData(); const l = this._data; const n = t.coordinateSystem; const o = !!n.getBaseAxis().isHorizontal(); const a = n.grid.getRect(); const u = { ecSize: { width: i.getWidth(), height: i.getHeight() }, seriesModel: t, coordSys: n, coordSysExtent: [[a.x, a.x + a.width], [a.y, a.y + a.height]], isHorizontal: o, valueDim: BM[+o], categoryDim: BM[1 - o] };return s.diff(l).add((t) => {
      if (s.hasValue(t)) {
        const e = YM(s, t); const i = GM(s, t, e, u); const n = $M(s, u, i);s.setItemGraphicEl(t, n), r.add(n), iI(n, u, i);
      }
    })
      .update((t, e) => {
        let i = l.getItemGraphicEl(e);if (s.hasValue(t)) {
          const n = YM(s, t); const o = GM(s, t, n, u); const a = QM(s, o);i && a !== i.__pictorialShapeStr && (r.remove(i), s.setItemGraphicEl(t, null), i = null), i ? (function (t, e, i) {
            const n = i.animationModel; const o = i.dataIndex;cl(t.__pictorialBundle, { position: i.bundlePosition.slice() }, n, o), i.symbolRepeat ? HM(t, e, i, !0) : ZM(t, e, i, !0);UM(t, i, !0), XM(t, e, i, !0);
          }(i, u, o)) : i = $M(s, u, o, !0), s.setItemGraphicEl(t, i), i.__pictorialSymbolMeta = o, r.add(i), iI(i, u, o);
        } else r.remove(i);
      })
      .remove((t) => {
        const e = l.getItemGraphicEl(t);e && JM(l, t, e.__pictorialSymbolMeta.animationModel, e);
      })
      .execute(), this._data = s, this.group;
  }, dispose: et, remove(e, t) {
    const i = this.group; const n = this._data;e.get('animation') ? n && n.eachItemGraphicEl((t) => {
      JM(n, t.dataIndex, e, t);
    }) : i.removeAll();
  } });function GM(t, e, i, n) {
    const o = t.getItemLayout(e); const a = i.get('symbolRepeat'); const r = i.get('symbolClip'); const s = i.get('symbolPosition') || 'start'; const l = (i.get('symbolRotate') || 0) * Math.PI / 180 || 0; const u = i.get('symbolPatternSize') || 2; const h = i.isAnimationEnabled(); const c = { dataIndex: e, layout: o, itemModel: i, symbolType: t.getItemVisual(e, 'symbol') || 'circle', color: t.getItemVisual(e, 'color'), symbolClip: r, symbolRepeat: a, symbolRepeatDirection: i.get('symbolRepeatDirection'), symbolPatternSize: u, rotation: l, animationModel: h ? i : null, hoverAnimation: h && i.get('hoverAnimation'), z2: i.getShallow('z', !0) || 0 };!(function (t, e, i, n, o) {
      let a; const r = n.valueDim; const s = t.get('symbolBoundingData'); const l = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()); const u = l.toGlobalCoord(l.dataToCoord(0)); const h = 1 - +(i[r.wh] <= 0);if (L(s)) {
        const c = [FM(l, s[0]) - u, FM(l, s[1]) - u];c[1] < c[0] && c.reverse(), a = c[h];
      } else a = null != s ? FM(l, s) - u : e ? n.coordSysExtent[r.index][h] - u : i[r.wh];o.boundingLength = a, e && (o.repeatCutLength = i[r.wh]);o.pxSign = 0 < a ? 1 : a < 0 ? -1 : 0;
    }(i, a, o, n, c)), (function (t, e, i, n, o, a, r, s, l, u) {
      const h = l.valueDim; const c = l.categoryDim; const d = Math.abs(i[c.wh]); let f = t.getItemVisual(e, 'symbolSize');f = L(f) ? f.slice() : (null == f && (f = '100%'), [f, f]);f[c.index] = El(f[c.index], d), f[h.index] = El(f[h.index], n ? d : Math.abs(a)), u.symbolSize = f, (u.symbolScale = [f[0] / s, f[1] / s])[h.index] *= (l.isHorizontal ? -1 : 1) * r;
    }(t, e, o, a, 0, c.boundingLength, c.pxSign, u, n, c)), (function (t, e, i, n, o) {
      let a = t.get(zM) || 0;a && (VM.attr({ scale: e.slice(), rotation: i }), VM.updateTransform(), a /= VM.getLineScale(), a *= e[n.valueDim.index]);o.valueLineWidth = a;
    }(i, c.symbolScale, l, n, c));const d = c.symbolSize; let f = i.get('symbolOffset');return L(f) && (f = [El(f[0], d[0]), El(f[1], d[1])]), (function (t, e, i, n, o, a, r, s, l, u, h, c) {
      const d = h.categoryDim; const f = h.valueDim; const p = c.pxSign; const g = Math.max(e[f.index] + s, 0); let m = g;if (n) {
        const v = Math.abs(l); let y = `${W(t.get('symbolMargin'), '15%')}`; let x = !1;y.lastIndexOf('!') === y.length - 1 && (x = !0, y = y.slice(0, y.length - 1)), y = El(y, e[f.index]);let _ = Math.max(g + 2 * y, 0); let w = x ? 0 : 2 * y; const b = Jl(n); let S = b ? n : nI((v + w) / _);_ = g + 2 * (y = (v - S * g) / 2 / (x ? S : S - 1)), w = x ? 0 : 2 * y, b || 'fixed' === n || (S = u ? nI((Math.abs(u) + w) / _) : 0), m = S * _ - w, c.repeatTimes = S, c.symbolMargin = y;
      } const M = p * (m / 2); const I = c.pathPosition = [];I[d.index] = i[d.wh] / 2, I[f.index] = 'start' === r ? M : 'end' === r ? l - M : l / 2, a && (I[0] += a[0], I[1] += a[1]);const T = c.bundlePosition = [];T[d.index] = i[d.xy], T[f.index] = i[f.xy];const A = c.barRectShape = P({}, i);A[f.wh] = p * Math.max(Math.abs(i[f.wh]), Math.abs(I[f.index] + M)), A[d.wh] = i[d.wh];const D = c.clipShape = {};D[d.xy] = -i[d.xy], D[d.wh] = h.ecSize[d.wh], D[f.xy] = 0, D[f.wh] = i[f.wh];
    }(i, d, o, a, 0, f, s, c.valueLineWidth, c.boundingLength, c.repeatCutLength, n, c)), c;
  } function FM(t, e) {
    return t.toGlobalCoord(t.dataToCoord(t.scale.parse(e)));
  } function WM(t) {
    const e = t.symbolPatternSize; const i = wg(t.symbolType, -e / 2, -e / 2, e, e, t.color);return i.attr({ culling: !0 }), 'image' !== i.type && i.setStyle({ strokeNoScale: !0 }), i;
  } function HM(t, e, o, i) {
    const n = t.__pictorialBundle; const a = o.symbolSize; const r = o.valueLineWidth; const s = o.pathPosition; const l = e.valueDim; const u = o.repeatTimes || 0; let h = 0; const c = a[e.valueDim.index] + r + 2 * o.symbolMargin;for (tI(t, (t) => {
      t.__pictorialAnimationIndex = h, t.__pictorialRepeatTimes = u, h < u ? eI(t, null, p(h), o, i) : eI(t, null, { scale: [0, 0] }, o, i, () => {
        n.remove(t);
      }), KM(t, o), h++;
    });h < u;h++) {
      const d = WM(o);d.__pictorialAnimationIndex = h, d.__pictorialRepeatTimes = u, n.add(d);const f = p(h);eI(d, { position: f.position, scale: [0, 0] }, { scale: f.scale, rotation: f.rotation }, o, i), d.on('mouseover', g).on('mouseout', m), KM(d, o);
    } function p(t) {
      const e = s.slice(); const i = o.pxSign; let n = t;return ('start' === o.symbolRepeatDirection ? 0 < i : i < 0) && (n = u - 1 - t), e[l.index] = c * (n - u / 2 + .5) + s[l.index], { position: e, scale: o.symbolScale.slice(), rotation: o.rotation };
    } function g() {
      tI(t, (t) => {
        t.trigger('emphasis');
      });
    } function m() {
      tI(t, (t) => {
        t.trigger('normal');
      });
    }
  } function ZM(t, e, i, n) {
    const o = t.__pictorialBundle; let a = t.__pictorialMainPath;a ? eI(a, null, { position: i.pathPosition.slice(), scale: i.symbolScale.slice(), rotation: i.rotation }, i, n) : (a = t.__pictorialMainPath = WM(i), o.add(a), eI(a, { position: i.pathPosition.slice(), scale: [0, 0], rotation: i.rotation }, { scale: i.symbolScale.slice() }, i, n), a.on('mouseover', function () {
      this.trigger('emphasis');
    }).on('mouseout', function () {
      this.trigger('normal');
    })), KM(a, i);
  } function UM(t, e, i) {
    const n = P({}, e.barRectShape); let o = t.__pictorialBarRect;o ? eI(o, null, { shape: n }, e, i) : (o = t.__pictorialBarRect = new rs({ z2: 2, shape: n, silent: !0, style: { stroke: 'transparent', fill: 'transparent', lineWidth: 0 } }), t.add(o));
  } function XM(t, e, i, n) {
    if (i.symbolClip) {
      let o = t.__pictorialClipPath; const a = P({}, i.clipShape); const r = e.valueDim; const s = i.animationModel; const l = i.dataIndex;if (o)cl(o, { shape: a }, s, l);else {
        a[r.wh] = 0, o = new rs({ shape: a }), t.__pictorialBundle.setClipPath(o), t.__pictorialClipPath = o;const u = {};u[r.wh] = i.clipShape[r.wh], bl[n ? 'updateProps' : 'initProps'](o, { shape: u }, s, l);
      }
    }
  } function YM(t, e) {
    const i = t.getItemModel(e);return i.getAnimationDelayParams = jM, i.isAnimationEnabled = qM, i;
  } function jM(t) {
    return { index: t.__pictorialAnimationIndex, count: t.__pictorialRepeatTimes };
  } function qM() {
    return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation');
  } function KM(t, e) {
    t.off('emphasis').off('normal');const i = e.symbolScale.slice();e.hoverAnimation && t.on('emphasis', function () {
      this.animateTo({ scale: [1.1 * i[0], 1.1 * i[1]] }, 400, 'elasticOut');
    }).on('normal', function () {
      this.animateTo({ scale: i.slice() }, 400, 'elasticOut');
    });
  } function $M(t, e, i, n) {
    const o = new Ci; const a = new Ci;return o.add(a), (o.__pictorialBundle = a).attr('position', i.bundlePosition.slice()), i.symbolRepeat ? HM(o, e, i) : ZM(o, 0, i), UM(o, i, n), XM(o, e, i, n), o.__pictorialShapeStr = QM(t, i), o.__pictorialSymbolMeta = i, o;
  } function JM(t, e, i, n) {
    const o = n.__pictorialBarRect;o && (o.style.text = null);const a = [];tI(n, (t) => {
      a.push(t);
    }), n.__pictorialMainPath && a.push(n.__pictorialMainPath), n.__pictorialClipPath && (i = null), R(a, (t) => {
      cl(t, { scale: [0, 0] }, i, e, () => {
        n.parent && n.parent.remove(n);
      });
    }), t.setItemGraphicEl(e, null);
  } function QM(t, e) {
    return [t.getItemVisual(e.dataIndex, 'symbol') || 'none', !!e.symbolRepeat, !!e.symbolClip].join(':');
  } function tI(e, i, n) {
    R(e.__pictorialBundle.children(), (t) => {
      t !== e.__pictorialBarRect && i.call(n, t);
    });
  } function eI(t, e, i, n, o, a) {
    e && t.attr(e), n.symbolClip && !o ? i && t.attr(i) : i && bl[o ? 'updateProps' : 'initProps'](t, i, n.animationModel, n.dataIndex, a);
  } function iI(t, e, i) {
    const n = i.color; const o = i.dataIndex; const a = i.itemModel; const r = a.getModel('itemStyle').getItemStyle(['color']); const s = a.getModel('emphasis.itemStyle').getItemStyle(); const l = a.getShallow('cursor');tI(t, (t) => {
      t.setColor(n), t.setStyle(D({ fill: n, opacity: i.opacity }, r)), $s(t, s), l && (t.cursor = l), t.z2 = i.z2;
    });const u = {}; const h = (e.valueDim.posDesc[+(0 < i.boundingLength)], t.__pictorialBarRect);Av(h.style, u, a, n, e.seriesModel, o), $s(h, u);
  } function nI(t) {
    const e = Math.round(t);return Math.abs(t - e) < 1e-4 ? e : Math.ceil(t);
  }bf(T(zp, 'pictorialBar')), Sf(Lm('pictorialBar', 'roundRect'));function oI(t, e, i, n, o) {
    Gg.call(this, t, e, i), this.type = n || 'value', this.position = o || 'bottom', this.orient = null;
  } function aI(t, e, i) {
    this.dimension = 'single', this.dimensions = ['single'], this._axis = null, this._rect, this._init(t, e, i), this.model = t;
  } function rI(t, e) {
    e = e || {};const i = t.coordinateSystem; const n = t.axis; const o = {}; const a = n.position; const r = n.orient; const s = i.getRect(); const l = [s.x, s.x + s.width, s.y, s.y + s.height]; const u = { horizontal: { top: l[2], bottom: l[3] }, vertical: { left: l[0], right: l[1] } };o.position = ['vertical' === r ? u.vertical[a] : l[0], 'horizontal' === r ? u.horizontal[a] : l[3]];o.rotation = Math.PI / 2 * { horizontal: 0, vertical: 1 }[r];o.labelDirection = o.tickDirection = o.nameDirection = { top: -1, bottom: 1, right: 1, left: -1 }[a], t.get('axisTick.inside') && (o.tickDirection = -o.tickDirection), W(e.labelInside, t.get('axisLabel.inside')) && (o.labelDirection = -o.labelDirection);let h = e.rotate;return null == h && (h = t.get('axisLabel.rotate')), o.labelRotation = 'top' === a ? -h : h, o.z2 = 1, o;
  }oI.prototype = { constructor: oI, model: null, isHorizontal() {
    const t = this.position;return 'top' === t || 'bottom' === t;
  }, pointToData(t, e) {
    return this.coordinateSystem.pointToData(t, e)[0];
  }, toGlobalCoord: null, toLocalCoord: null }, w(oI, Gg), lh.register('single', { create(n, o) {
    const a = [];return n.eachComponent('singleAxis', (t, e) => {
      const i = new aI(t, n, o);i.name = `single_${e}`, i.resize(t, o), t.coordinateSystem = i, a.push(i);
    }), n.eachSeries((t) => {
      if ('singleAxis' === t.get('coordinateSystem')) {
        const e = n.queryComponents({ mainType: 'singleAxis', index: t.get('singleAxisIndex'), id: t.get('singleAxisId') })[0];t.coordinateSystem = e && e.coordinateSystem;
      }
    }), a;
  }, dimensions: (aI.prototype = { type: 'singleAxis', axisPointerEnabled: !0, constructor: aI, _init(t, e, i) {
    const n = this.dimension; const o = new oI(n, sg(t), [0, 0], t.get('type'), t.get('position')); const a = 'category' === o.type;o.onBand = a && t.get('boundaryGap'), o.inverse = t.get('inverse'), o.orient = t.get('orient'), (t.axis = o).model = t, (o.coordinateSystem = this)._axis = o;
  }, update(t, e) {
    t.eachSeries(function (t) {
      if (t.coordinateSystem === this) {
        const e = t.getData();R(e.mapDimension(this.dimension, !0), function (t) {
          this._axis.scale.unionExtentFromData(e, t);
        }, this), rg(this._axis.scale, this._axis.model);
      }
    }, this);
  }, resize(t, e) {
    this._rect = bu({ left: t.get('left'), top: t.get('top'), right: t.get('right'), bottom: t.get('bottom'), width: t.get('width'), height: t.get('height') }, { width: e.getWidth(), height: e.getHeight() }), this._adjustAxis();
  }, getRect() {
    return this._rect;
  }, _adjustAxis() {
    const t = this._rect; const e = this._axis; const i = e.isHorizontal(); const n = i ? [0, t.width] : [0, t.height]; const o = e.reverse ? 1 : 0;e.setExtent(n[o], n[1 - o]), this._updateAxisTransform(e, i ? t.x : t.y);
  }, _updateAxisTransform(t, e) {
    const i = t.getExtent(); const n = i[0] + i[1]; const o = t.isHorizontal();t.toGlobalCoord = o ? function (t) {
      return t + e;
    } : function (t) {
      return n - t + e;
    }, t.toLocalCoord = o ? function (t) {
      return t - e;
    } : function (t) {
      return n - t + e;
    };
  }, getAxis() {
    return this._axis;
  }, getBaseAxis() {
    return this._axis;
  }, getAxes() {
    return [this._axis];
  }, getTooltipAxes() {
    return { baseAxes: [this.getAxis()] };
  }, containPoint(t) {
    const e = this.getRect(); const i = this.getAxis();return 'horizontal' === i.orient ? i.contain(i.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : i.contain(i.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height;
  }, pointToData(t) {
    const e = this.getAxis();return [e.coordToData(e.toLocalCoord(t['horizontal' === e.orient ? 0 : 1]))];
  }, dataToPoint(t) {
    const e = this.getAxis(); const i = this.getRect(); const n = []; const o = 'horizontal' === e.orient ? 0 : 1;return t instanceof Array && (t = t[0]), n[o] = e.toGlobalCoord(e.dataToCoord(+t)), n[1 - o] = 0 == o ? i.y + i.height / 2 : i.x + i.width / 2, n;
  } }).dimensions });const sI = ['axisLine', 'axisTickLabel', 'axisName']; const lI = ['splitArea', 'splitLine']; var uI = mv.extend({ type: 'singleAxis', axisPointerClass: 'SingleAxisPointer', render(e, t, i, n) {
    const o = this.group;o.removeAll();const a = this._axisGroup;this._axisGroup = new Ci;const r = rI(e); const s = new Qm(e, r);R(sI, s.add, s), o.add(this._axisGroup), o.add(s.getGroup()), R(lI, function (t) {
      e.get(`${t}.show`) && this[`_${t}`](e);
    }, this), ml(a, this._axisGroup, e), uI.superCall(this, 'render', e, t, i, n);
  }, remove() {
    bv(this);
  }, _splitLine(t) {
    const e = t.axis;if (!e.scale.isBlank()) {
      const i = t.getModel('splitLine'); const n = i.getModel('lineStyle'); const o = n.get('width'); let a = n.get('color');a = a instanceof Array ? a : [a];for (var r = t.coordinateSystem.getRect(), s = e.isHorizontal(), l = [], u = 0, h = e.getTicksCoords({ tickModel: i }), c = [], d = [], f = 0;f < h.length;++f) {
        const p = e.toGlobalCoord(h[f].coord);s ? (c[0] = p, c[1] = r.y, d[0] = p, d[1] = r.y + r.height) : (c[0] = r.x, c[1] = p, d[0] = r.x + r.width, d[1] = p);const g = u++ % a.length;l[g] = l[g] || [], l[g].push(new ls({ subPixelOptimize: !0, shape: { x1: c[0], y1: c[1], x2: d[0], y2: d[1] }, style: { lineWidth: o }, silent: !0 }));
      } for (f = 0;f < l.length;++f) this.group.add(Rs(l[f], { style: { stroke: a[f % a.length], lineDash: n.getLineDash(o), lineWidth: o }, silent: !0 }));
    }
  }, _splitArea(t) {
    wv(this, this._axisGroup, t, t);
  } }); const hI = ku.extend({ type: 'singleAxis', layoutMode: 'box', axis: null, coordinateSystem: null, getCoordSysModel() {
    return this;
  } });m(hI.prototype, dg), Gm('single', hI, (t, e) => e.type || (e.data ? 'category' : 'value'), { left: '5%', top: '5%', right: '5%', bottom: '5%', type: 'value', position: 'bottom', orient: 'horizontal', axisLine: { show: !0, lineStyle: { width: 1, type: 'solid' } }, tooltip: { show: !0 }, axisTick: { show: !0, length: 6, lineStyle: { width: 1 } }, axisLabel: { show: !0, interval: 'auto' }, splitLine: { show: !0, lineStyle: { type: 'dashed', opacity: .2 } } });function cI(t, e) {
    let i; let n = []; const o = t.seriesIndex;if (null == o || !(i = e.getSeriesByIndex(o))) return { point: [] };const a = i.getData(); const r = Yo(a, t);if (null == r || r < 0 || L(r)) return { point: [] };const s = a.getItemGraphicEl(r); const l = i.coordinateSystem;if (i.getTooltipPosition)n = i.getTooltipPosition(r) || [];else if (l && l.dataToPoint)n = l.dataToPoint(a.getValues(O(l.dimensions, t => a.mapDimension(t)), r, !0)) || [];else if (s) {
      const u = s.getBoundingRect().clone();u.applyTransform(s.transform), n = [u.x + u.width / 2, u.y + u.height / 2];
    } return { point: n, el: s };
  } const dI = R; const fI = T; const pI = jo();function gI(t, e, i, n, o) {
    const a = t.axis;if (!a.scale.isBlank() && a.containData(e)) if (t.involveSeries) {
      const r = (function (l, t) {
        const u = t.axis; const h = u.dim; let c = l; const d = []; let f = Number.MAX_VALUE; let p = -1;return dI(t.seriesModels, (e, t) => {
          let i; let n; const o = e.getData().mapDimension(h, !0);if (e.getAxisTooltipData) {
            const a = e.getAxisTooltipData(o, l, u);n = a.dataIndices, i = a.nestestValue;
          } else {
            if (!(n = e.getData().indicesOfNearest(o[0], l, 'category' === u.type ? .5 : null)).length) return;i = e.getData().get(o[0], n[0]);
          } if (null != i && isFinite(i)) {
            const r = l - i; const s = Math.abs(r);s <= f && ((s < f || 0 <= r && p < 0) && (f = s, p = r, c = i, d.length = 0), dI(n, (t) => {
              d.push({ seriesIndex: e.seriesIndex, dataIndexInside: t, dataIndex: e.getData().getRawIndex(t) });
            }));
          }
        }), { payloadBatch: d, snapToValue: c };
      }(e, t)); const s = r.payloadBatch; const l = r.snapToValue;s[0] && null == o.seriesIndex && P(o, s[0]), !n && t.snap && a.containData(l) && null != l && (e = l), i.showPointer(t, e, s, o), i.showTooltip(t, r, l);
    } else i.showPointer(t, e);
  } function mI(t, e, i, n) {
    t[e.key] = { value: i, payloadBatch: n };
  } function vI(t, e, i, n) {
    const o = i.payloadBatch; const a = e.axis; const r = a.model; const s = e.axisPointerModel;if (e.triggerTooltip && o.length) {
      const l = e.coordSys.model; const u = gv(l); let h = t.map[u];h || (h = t.map[u] = { coordSysId: l.id, coordSysIndex: l.componentIndex, coordSysType: l.type, coordSysMainType: l.mainType, dataByAxis: [] }, t.list.push(h)), h.dataByAxis.push({ axisDim: a.dim, axisIndex: r.componentIndex, axisType: r.type, axisId: r.id, value: n, valueLabelOpt: { precision: s.get('label.precision'), formatter: s.get('label.formatter') }, seriesDataIndices: o.slice() });
    }
  } function yI(t) {
    const e = t.axis.model; const i = {}; const n = i.axisDim = t.axis.dim;return i.axisIndex = i[`${n}AxisIndex`] = e.componentIndex, i.axisName = i[`${n}AxisName`] = e.name, i.axisId = i[`${n}AxisId`] = e.id, i;
  } function xI(t) {
    return !t || null == t[0] || isNaN(t[0]) || null == t[1] || isNaN(t[1]);
  }Tf({ type: 'axisPointer', coordSysAxesInfo: null, defaultOption: { show: 'auto', triggerOn: null, zlevel: 0, z: 50, type: 'line', snap: !1, triggerTooltip: !0, value: null, status: null, link: [], animation: null, animationDurationUpdate: 200, lineStyle: { color: '#aaa', width: 1, type: 'solid' }, shadowStyle: { color: 'rgba(150,150,150,0.3)' }, label: { show: !0, formatter: null, precision: 'auto', margin: 3, color: '#fff', padding: [5, 7, 5, 7], backgroundColor: 'auto', borderColor: null, borderWidth: 0, shadowBlur: 3, shadowColor: '#aaa' }, handle: { show: !1, icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z', size: 45, margin: 50, color: '#333', shadowBlur: 3, shadowColor: '#aaa', shadowOffsetX: 0, shadowOffsetY: 2, throttle: 40 } } });const _I = jo(); const wI = R;function bI(t, e, i) {
    if (!v.node) {
      const n = e.getZr();_I(n).records || (_I(n).records = {}), (function (o, a) {
        if (_I(o).initialized) return;function t(t, n) {
          o.on(t, (e) => {
            const i = (function (i) {
              const n = { showTip: [], hideTip: [] }; var o = function (t) {
                const e = n[t.type];e ? e.push(t) : (t.dispatchAction = o, i.dispatchAction(t));
              };return { dispatchAction: o, pendings: n };
            }(a));wI(_I(o).records, (t) => {
              t && n(t, e, i.dispatchAction);
            }), (function (t, e) {
              let i; const n = t.showTip.length; const o = t.hideTip.length;n ? i = t.showTip[n - 1] : o && (i = t.hideTip[o - 1]);i && (i.dispatchAction = null, e.dispatchAction(i));
            }(i.pendings, a));
          });
        }_I(o).initialized = !0, t('click', T(MI, 'click')), t('mousemove', T(MI, 'mousemove')), t('globalout', SI);
      }(n, e)), (_I(n).records[t] || (_I(n).records[t] = {})).handler = i;
    }
  } function SI(t, e, i) {
    t.handler('leave', null, i);
  } function MI(t, e, i, n) {
    e.handler(t, i, n);
  } function II(t, e) {
    if (!v.node) {
      const i = e.getZr();(_I(i).records || {})[t] && (_I(i).records[t] = null);
    }
  } var TI = Af({ type: 'axisPointer', render(t, e, i) {
    const n = e.getComponent('tooltip'); const o = t.get('triggerOn') || n && n.get('triggerOn') || 'mousemove|click';bI('axisPointer', i, (t, e, i) => {
      'none' !== o && ('leave' === t || 0 <= o.indexOf(t)) && i({ type: 'updateAxisPointer', currTrigger: t, x: e && e.offsetX, y: e && e.offsetY });
    });
  }, remove(t, e) {
    II(e.getZr(), 'axisPointer'), TI.superApply(this._model, 'remove', arguments);
  }, dispose(t, e) {
    II('axisPointer', e), TI.superApply(this._model, 'dispose', arguments);
  } }); const AI = jo(); const DI = k; const CI = A;function LI() {} function kI(t, e, i, n) {
    !(function i(n, t) {
      { if (z(n) && z(t)) {
        let o = !0;return R(t, (t, e) => {
          o = o && i(n[e], t);
        }), !!o;
      } return n === t; }
    }(AI(i).lastProp, n)) && (AI(i).lastProp = n, e ? cl(i, n, t) : (i.stopAnimation(), i.attr(n)));
  } function PI(t, e) {
    t[e.get('label.show') ? 'show' : 'hide']();
  } function NI(t) {
    return { position: t.position.slice(), rotation: t.rotation || 0 };
  } function OI(t, e, i) {
    const n = e.get('z'); const o = e.get('zlevel');t && t.traverse((t) => {
      'group' !== t.type && (null != n && (t.z = n), null != o && (t.zlevel = o), t.silent = i);
    });
  } function RI(t) {
    let e; const i = t.get('type'); const n = t.getModel(`${i}Style`);return 'line' === i ? (e = n.getLineStyle()).fill = null : 'shadow' === i && ((e = n.getAreaStyle()).stroke = null), e;
  } function EI(t, e, i, n, o) {
    const a = zI(i.get('value'), e.axis, e.ecModel, i.get('seriesDataIndices'), { precision: i.get('label.precision'), formatter: i.get('label.formatter') }); const r = i.getModel('label'); const s = iu(r.get('padding') || 0); const l = r.getFont(); const u = gn(a, l); const h = o.position; const c = u.width + s[1] + s[3]; const d = u.height + s[0] + s[2]; const f = o.align;'right' === f && (h[0] -= c), 'center' === f && (h[0] -= c / 2);const p = o.verticalAlign;'bottom' === p && (h[1] -= d), 'middle' === p && (h[1] -= d / 2), (function (t, e, i, n) {
      const o = n.getWidth(); const a = n.getHeight();t[0] = Math.min(t[0] + e, o) - e, t[1] = Math.min(t[1] + i, a) - i, t[0] = Math.max(t[0], 0), t[1] = Math.max(t[1], 0);
    }(h, c, d, n));let g = r.get('backgroundColor');g && 'auto' !== g || (g = e.get('axisLine.lineStyle.color')), t.label = { shape: { x: 0, y: 0, width: c, height: d, r: r.get('borderRadius') }, position: h.slice(), style: { text: a, textFont: l, textFill: r.getTextColor(), textPosition: 'inside', textPadding: s, fill: g, stroke: r.get('borderColor') || 'transparent', lineWidth: r.get('borderWidth') || 0, shadowBlur: r.get('shadowBlur'), shadowColor: r.get('shadowColor'), shadowOffsetX: r.get('shadowOffsetX'), shadowOffsetY: r.get('shadowOffsetY') }, z2: 10 };
  } function zI(t, e, o, i, n) {
    t = e.scale.parse(t);let a = e.scale.getLabel(t, { precision: n.precision }); const r = n.formatter;if (r) {
      const s = { value: ug(e, t), axisDimension: e.dim, axisIndex: e.index, seriesData: [] };R(i, (t) => {
        const e = o.getSeriesByIndex(t.seriesIndex); const i = t.dataIndexInside; const n = e && e.getDataParams(i);n && s.seriesData.push(n);
      }), E(r) ? a = r.replace('{value}', a) : C(r) && (a = r(s));
    } return a;
  } function BI(t, e, i) {
    const n = ae();return he(n, n, i.rotation), ue(n, n, i.position), pl([t.dataToCoord(e), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0)], n);
  } function VI(t, e, i, n, o, a) {
    const r = Qm.innerTextLayout(i.rotation, 0, i.labelDirection);i.labelMargin = o.get('label.margin'), EI(e, n, o, a, { position: BI(n.axis, t, i), align: r.textAlign, verticalAlign: r.textVerticalAlign });
  } function GI(t, e, i) {
    return { x1: t[i = i || 0], y1: t[1 - i], x2: e[i], y2: e[1 - i] };
  } function FI(t, e, i) {
    return { x: t[i = i || 0], y: t[1 - i], width: e[i], height: e[1 - i] };
  } function WI(t, e, i, n, o, a) {
    return { cx: t, cy: e, r0: i, r: n, startAngle: o, endAngle: a, clockwise: !0 };
  }oa((LI.prototype = { _group: null, _lastGraphicKey: null, _handle: null, _dragging: !1, _lastValue: null, _lastStatus: null, _payloadInfo: null, animationThreshold: 15, render(t, e, i, n) {
    const o = e.get('value'); const a = e.get('status');if (this._axisModel = t, this._axisPointerModel = e, this._api = i, n || this._lastValue !== o || this._lastStatus !== a) {
      this._lastValue = o, this._lastStatus = a;let r = this._group; const s = this._handle;if (!a || 'hide' === a) return r && r.hide(), void(s && s.hide());r && r.show(), s && s.show();const l = {};this.makeElOption(l, o, t, e, i);const u = l.graphicKey;u !== this._lastGraphicKey && this.clear(i), this._lastGraphicKey = u;const h = this._moveAnimation = this.determineAnimation(t, e);if (r) {
        const c = T(kI, e, h);this.updatePointerEl(r, l, c, e), this.updateLabelEl(r, l, c, e);
      } else r = this._group = new Ci, this.createPointerEl(r, l, t, e), this.createLabelEl(r, l, t, e), i.getZr().add(r);OI(r, e, !0), this._renderHandle(o);
    }
  }, remove(t) {
    this.clear(t);
  }, dispose(t) {
    this.clear(t);
  }, determineAnimation(t, e) {
    const i = e.get('animation'); const n = t.axis; const o = 'category' === n.type; const a = e.get('snap');if (!a && !o) return !1;if ('auto' !== i && null != i) return !0 === i;const r = this.animationThreshold;if (o && n.getBandWidth() > r) return !0;if (a) {
      const s = fv(t).seriesDataCount; const l = n.getExtent();return Math.abs(l[0] - l[1]) / s > r;
    } return !1;
  }, makeElOption(t, e, i, n, o) {}, createPointerEl(t, e, i, n) {
    const o = e.pointer;if (o) {
      const a = AI(t).pointerEl = new bl[o.type](DI(e.pointer));t.add(a);
    }
  }, createLabelEl(t, e, i, n) {
    if (e.label) {
      const o = AI(t).labelEl = new rs(DI(e.label));t.add(o), PI(o, n);
    }
  }, updatePointerEl(t, e, i) {
    const n = AI(t).pointerEl;n && e.pointer && (n.setStyle(e.pointer.style), i(n, { shape: e.pointer.shape }));
  }, updateLabelEl(t, e, i, n) {
    const o = AI(t).labelEl;o && (o.setStyle(e.label.style), i(o, { shape: e.label.shape, position: e.label.position }), PI(o, n));
  }, _renderHandle(t) {
    if (!this._dragging && this.updateHandleTransform) {
      let e; const i = this._axisPointerModel; const n = this._api.getZr(); let o = this._handle; const a = i.getModel('handle'); const r = i.get('status');if (!a.get('show') || !r || 'hide' === r) return o && n.remove(o), void(this._handle = null);this._handle || (e = !0, o = this._handle = yl(a.get('icon'), { cursor: 'move', draggable: !0, onmousemove(t) {
        Xt(t.event);
      }, onmousedown: CI(this._onHandleDragMove, this, 0, 0), drift: CI(this._onHandleDragMove, this), ondragend: CI(this._onHandleDragEnd, this) }), n.add(o)), OI(o, i, !1);o.setStyle(a.getItemStyle(null, ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY']));let s = a.get('size');L(s) || (s = [s, s]), o.attr('scale', [s[0] / 2, s[1] / 2]), kc(this, '_doDispatchAxisPointer', a.get('throttle') || 0, 'fixRate'), this._moveHandleToValue(t, e);
    }
  }, _moveHandleToValue(t, e) {
    kI(this._axisPointerModel, !e && this._moveAnimation, this._handle, NI(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
  }, _onHandleDragMove(t, e) {
    const i = this._handle;if (i) {
      this._dragging = !0;const n = this.updateHandleTransform(NI(i), [t, e], this._axisModel, this._axisPointerModel);this._payloadInfo = n, i.stopAnimation(), i.attr(NI(n)), AI(i).lastProp = null, this._doDispatchAxisPointer();
    }
  }, _doDispatchAxisPointer() {
    if (this._handle) {
      const t = this._payloadInfo; const e = this._axisModel;this._api.dispatchAction({ type: 'updateAxisPointer', x: t.cursorPoint[0], y: t.cursorPoint[1], tooltipOption: t.tooltipOption, axesInfo: [{ axisDim: e.axis.dim, axisIndex: e.componentIndex }] });
    }
  }, _onHandleDragEnd(t) {
    if (this._dragging = !1, this._handle) {
      const e = this._axisPointerModel.get('value');this._moveHandleToValue(e), this._api.dispatchAction({ type: 'hideTip' });
    }
  }, getHandleTransform: null, updateHandleTransform: null, clear(t) {
    this._lastValue = null, this._lastStatus = null;const e = t.getZr(); const i = this._group; const n = this._handle;e && i && (this._lastGraphicKey = null, i && e.remove(i), n && e.remove(n), this._group = null, this._handle = null, this._payloadInfo = null);
  }, doClear() {}, buildLabel(t, e, i) {
    return { x: t[i = i || 0], y: t[1 - i], width: e[i], height: e[1 - i] };
  } }).constructor = LI);const HI = LI.extend({ makeElOption(t, e, i, n, o) {
    const a = i.axis; const r = a.grid; const s = n.get('type'); const l = ZI(r, a).getOtherAxis(a)
      .getGlobalExtent(); const u = a.toGlobalCoord(a.dataToCoord(e, !0));if (s && 'none' !== s) {
      const h = RI(n); const c = UI[s](a, u, l);c.style = h, t.graphicKey = c.type, t.pointer = c;
    }VI(e, t, _v(r.model, i), i, n, o);
  }, getHandleTransform(t, e, i) {
    const n = _v(e.axis.grid.model, e, { labelInside: !1 });return n.labelMargin = i.get('handle.margin'), { position: BI(e.axis, t, n), rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0) };
  }, updateHandleTransform(t, e, i, n) {
    const o = i.axis; const a = o.grid; const r = o.getGlobalExtent(!0); const s = ZI(a, o).getOtherAxis(o)
      .getGlobalExtent(); const l = 'x' === o.dim ? 0 : 1; const u = t.position;u[l] += e[l], u[l] = Math.min(r[1], u[l]), u[l] = Math.max(r[0], u[l]);const h = (s[1] + s[0]) / 2; const c = [h, h];c[l] = u[l];return { position: u, rotation: t.rotation, cursorPoint: c, tooltipOption: [{ verticalAlign: 'middle' }, { align: 'center' }][l] };
  } });function ZI(t, e) {
    const i = {};return i[`${e.dim}AxisIndex`] = e.index, t.getCartesian(i);
  } var UI = { line(t, e, i) {
    return { type: 'Line', subPixelOptimize: !0, shape: GI([e, i[0]], [e, i[1]], XI(t)) };
  }, shadow(t, e, i) {
    const n = Math.max(1, t.getBandWidth()); const o = i[1] - i[0];return { type: 'Rect', shape: FI([e - n / 2, i[0]], [n, o], XI(t)) };
  } };function XI(t) {
    return 'x' === t.dim ? 0 : 1;
  }mv.registerAxisPointerClass('CartesianAxisPointer', HI), yf((t) => {
    if (t) {
      t.axisPointer && 0 !== t.axisPointer.length || (t.axisPointer = {});const e = t.axisPointer.link;e && !L(e) && (t.axisPointer.link = [e]);
    }
  }), xf(Ld.PROCESSOR.STATISTIC, (t, e) => {
    t.getComponent('axisPointer').coordSysAxesInfo = cv(t, e);
  }), _f({ type: 'updateAxisPointer', event: 'updateAxisPointer', update: ':updateAxisPointer' }, (t, e, i) => {
    const n = t.currTrigger; let r = [t.x, t.y]; const o = t; const a = t.dispatchAction || A(i.dispatchAction, i); const s = e.getComponent('axisPointer').coordSysAxesInfo;if (s) {
      xI(r) && (r = cI({ seriesIndex: o.seriesIndex, dataIndex: o.dataIndex }, e).point);const l = xI(r); const u = o.axesInfo; const h = s.axesInfo; const c = 'leave' === n || xI(r); const d = {}; const f = {}; const p = { list: [], map: {} }; const g = { showPointer: fI(mI, f), showTooltip: fI(vI, p) };dI(s.coordSysMap, (t, e) => {
        const a = l || t.containPoint(r);dI(s.coordSysAxesInfo[e], (t, e) => {
          const i = t.axis; const n = (function (t, e) {
            for (let i = 0;i < (t || []).length;i++) {
              const n = t[i];if (e.axis.dim === n.axisDim && e.axis.model.componentIndex === n.axisIndex) return n;
            }
          }(u, t));if (!c && a && (!u || n)) {
            let o = n && n.value;null != o || l || (o = i.pointToData(r)), null != o && gI(t, o, g, !1, d);
          }
        });
      });const m = {};return dI(h, (o, t) => {
        const a = o.linkGroup;a && !f[t] && dI(a.axesInfo, (t, e) => {
          const i = f[e];if (t !== o && i) {
            let n = i.value;a.mapper && (n = o.axis.scale.parse(a.mapper(n, yI(t), yI(o)))), m[o.key] = n;
          }
        });
      }), dI(m, (t, e) => {
        gI(h[e], t, g, !0, d);
      }), (function (o, t, e) {
        const a = e.axesInfo = [];dI(t, (t, e) => {
          const i = t.axisPointerModel.option; const n = o[e];n ? (t.useHandle || (i.status = 'show'), i.value = n.value, i.seriesDataIndices = (n.payloadBatch || []).slice()) : t.useHandle || (i.status = 'hide'), 'show' === i.status && a.push({ axisDim: t.axis.dim, axisIndex: t.axis.model.componentIndex, value: i.value });
        });
      }(f, h, d)), (function (t, e, i, n) {
        if (xI(e) || !t.list.length) return n({ type: 'hideTip' });const o = ((t.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};n({ type: 'showTip', escapeConnect: !0, x: e[0], y: e[1], tooltipOption: i.tooltipOption, position: i.position, dataIndexInside: o.dataIndexInside, dataIndex: o.dataIndex, seriesIndex: o.seriesIndex, dataByCoordSys: t.list });
      }(p, r, t, a)), (function (t, e, i) {
        const n = i.getZr(); const o = 'axisPointerLastHighlights'; const a = pI(n)[o] || {}; const r = pI(n)[o] = {};dI(t, (t, e) => {
          const i = t.axisPointerModel.option;'show' === i.status && dI(i.seriesDataIndices, (t) => {
            const e = `${t.seriesIndex} | ${t.dataIndex}`;r[e] = t;
          });
        });const s = []; const l = [];R(a, (t, e) => {
          r[e] || l.push(t);
        }), R(r, (t, e) => {
          a[e] || s.push(t);
        }), l.length && i.dispatchAction({ type: 'downplay', escapeConnect: !0, batch: l }), s.length && i.dispatchAction({ type: 'highlight', escapeConnect: !0, batch: s });
      }(h, 0, i)), d;
    }
  });const YI = ['x', 'y']; const jI = ['width', 'height']; const qI = LI.extend({ makeElOption(t, e, i, n, o) {
    const a = i.axis; const r = a.coordinateSystem; const s = JI(r, 1 - $I(a)); const l = r.dataToPoint(e)[0]; const u = n.get('type');if (u && 'none' !== u) {
      const h = RI(n); const c = KI[u](a, l, s);c.style = h, t.graphicKey = c.type, t.pointer = c;
    }VI(e, t, rI(i), i, n, o);
  }, getHandleTransform(t, e, i) {
    const n = rI(e, { labelInside: !1 });return n.labelMargin = i.get('handle.margin'), { position: BI(e.axis, t, n), rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0) };
  }, updateHandleTransform(t, e, i, n) {
    const o = i.axis; const a = o.coordinateSystem; const r = $I(o); const s = JI(a, r); const l = t.position;l[r] += e[r], l[r] = Math.min(s[1], l[r]), l[r] = Math.max(s[0], l[r]);const u = JI(a, 1 - r); const h = (u[1] + u[0]) / 2; const c = [h, h];return c[r] = l[r], { position: l, rotation: t.rotation, cursorPoint: c, tooltipOption: { verticalAlign: 'middle' } };
  } }); var KI = { line(t, e, i) {
    return { type: 'Line', subPixelOptimize: !0, shape: GI([e, i[0]], [e, i[1]], $I(t)) };
  }, shadow(t, e, i) {
    const n = t.getBandWidth(); const o = i[1] - i[0];return { type: 'Rect', shape: FI([e - n / 2, i[0]], [n, o], $I(t)) };
  } };function $I(t) {
    return t.isHorizontal() ? 0 : 1;
  } function JI(t, e) {
    const i = t.getRect();return [i[YI[e]], i[YI[e]] + i[jI[e]]];
  }mv.registerAxisPointerClass('SingleAxisPointer', qI), Af({ type: 'single' });var QI = sc.extend({ type: 'series.themeRiver', dependencies: ['singleAxis'], nameMap: null, init(t) {
    QI.superApply(this, 'init', arguments), this.legendVisualProvider = new qv(A(this.getData, this), A(this.getRawData, this));
  }, fixData(t) {
    let e = t.length; const i = {}; const n = ta(t, t => (i.hasOwnProperty(t[0]) || (i[t[0]] = -1), t[2])); const o = [];n.buckets.each((t, e) => {
      o.push({ name: e, dataList: t });
    });for (let a = o.length, r = 0;r < a;++r) {
      for (var s = o[r].name, l = 0;l < o[r].dataList.length;++l) {
        var u = o[r].dataList[l][0];i[u] = r;
      } for (var u in i)i.hasOwnProperty(u) && i[u] !== r && (i[u] = r, t[e] = [], t[e][0] = u, t[e][1] = 0, t[e][2] = s, e++);
    } return t;
  }, getInitialData(t, e) {
    for (var i = e.queryComponents({ mainType: 'singleAxis', index: this.get('singleAxisIndex'), id: this.get('singleAxisId') })[0].get('type'), n = M(t.data, t => void 0 !== t[2]), o = this.fixData(n || []), a = [], r = this.nameMap = Q(), s = 0, l = 0;l < o.length;++l)a.push(o[l][2]), r.get(o[l][2]) || (r.set(o[l][2], s), s++);const u = lp(o, { coordDimensions: ['single'], dimensionsDefine: [{ name: 'time', type: Rf(i) }, { name: 'value', type: 'float' }, { name: 'name', type: 'ordinal' }], encodeDefine: { single: 0, value: 1, itemName: 2 } }); const h = new Yf(u, this);return h.initData(o), h;
  }, getLayerSeries() {
    for (var i = this.getData(), t = i.count(), e = [], n = 0;n < t;++n)e[n] = n;const o = i.mapDimension('single'); const a = ta(e, t => i.get('name', t)); const r = [];return a.buckets.each((t, e) => {
      t.sort((t, e) => i.get(o, t) - i.get(o, e)), r.push({ name: e, indices: t });
    }), r;
  }, getAxisTooltipData(t, e, i) {
    L(t) || (t = t ? [t] : []);for (var n, o = this.getData(), a = this.getLayerSeries(), r = [], s = a.length, l = 0;l < s;++l) {
      for (var u = Number.MAX_VALUE, h = -1, c = a[l].indices.length, d = 0;d < c;++d) {
        const f = o.get(t[0], a[l].indices[d]); const p = Math.abs(f - e);p <= u && (n = f, u = p, h = a[l].indices[d]);
      }r.push(h);
    } return { dataIndices: r, nestestValue: n };
  }, formatTooltip(t) {
    const e = this.getData(); const i = e.getName(t); let n = e.get(e.mapDimension('value'), t);return !isNaN(n) && null != n || (n = '-'), au(`${i} : ${n}`);
  }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: 'singleAxis', boundaryGap: ['10%', '10%'], singleAxisIndex: 0, animationEasing: 'linear', label: { margin: 4, show: !0, position: 'left', color: '#000', fontSize: 11 }, emphasis: { label: { show: !0 } } } });Cf({ type: 'themeRiver', init() {
    this._layers = [];
  }, render(b, t, e) {
    const S = b.getData(); const M = this.group; const I = b.getLayerSeries(); const i = S.getLayout('layoutInfo'); const n = i.rect; const o = i.boundaryGap;function a(t) {
      return t.name;
    }M.attr('position', [0, n.y + o[0]]);const r = new kf(this._layersSeries || [], I, a, a); const T = {};function s(t, e, i) {
      const n = this._layers;if ('remove' !== t) {
        for (var o, a, r, s = [], l = [], u = I[e].indices, h = 0;h < u.length;h++) {
          const c = S.getItemLayout(u[h]); const d = c.x; const f = c.y0; const p = c.y;s.push([d, f]), l.push([d, f + p]), o = S.getItemVisual(u[h], 'color');
        } const g = S.getItemLayout(u[0]); const m = S.getItemModel(u[h - 1]); const v = m.getModel('label'); const y = v.get('margin');if ('add' === t) {
          var x = T[e] = new Ci;a = new _m({ shape: { points: s, stackedOnPoints: l, smooth: .4, stackedOnSmooth: .4, smoothConstraint: !1 }, z2: 0 }), r = new Ur({ style: { x: g.x - y, y: g.y0 + g.y / 2 } }), x.add(a), x.add(r), M.add(x), a.setClipPath(function (t, e, i) {
            const n = new rs({ shape: { x: t.x - 10, y: t.y - 10, width: 0, height: t.height + 20 } });return dl(n, { shape: { width: t.width + 20, height: t.height + 20 } }, e, i), n;
          }(a.getBoundingRect(), b, () => {
            a.removeClipPath();
          }));
        } else {
          x = n[i];a = x.childAt(0), r = x.childAt(1), M.add(x), T[e] = x, cl(a, { shape: { points: s, stackedOnPoints: l } }, b), cl(r, { style: { x: g.x - y, y: g.y0 + g.y / 2 } }, b);
        } const _ = m.getModel('emphasis.itemStyle'); const w = m.getModel('itemStyle');nl(r.style, v, { text: v.get('show') ? b.getFormattedLabel(u[h - 1], 'normal') || S.getName(u[h - 1]) : null, textVerticalAlign: 'middle' }), a.setStyle(P({ fill: o }, w.getItemStyle(['color']))), $s(a, _.getItemStyle());
      } else M.remove(n[e]);
    }r.add(A(s, this, 'add')).update(A(s, this, 'update'))
      .remove(A(s, this, 'remove'))
      .execute(), this._layersSeries = I, this._layers = T;
  }, dispose() {} });function tT(i, t, e) {
    if (i.count()) for (var n, o = t.coordinateSystem, a = t.getLayerSeries(), r = i.mapDimension('single'), s = i.mapDimension('value'), l = O(a, t => O(t.indices, (t) => {
        const e = o.dataToPoint(i.get(r, t));return e[1] = i.get(s, t), e;
      })), u = (function (t) {
        for (var e = t.length, i = t[0].length, n = [], o = [], a = 0, r = {}, s = 0;s < i;++s) {
          for (var l = 0, u = 0;l < e;++l)u += t[l][s][1];a < u && (a = u), n.push(u);
        } for (let h = 0;h < i;++h)o[h] = (a - n[h]) / 2;for (let c = a = 0;c < i;++c) {
          const d = n[c] + o[c];a < d && (a = d);
        } return r.y0 = o, r.max = a, r;
      }(l)), h = u.y0, c = e / u.max, d = a.length, f = a[0].indices.length, p = 0;p < f;++p) {
      n = h[p] * c, i.setItemLayout(a[0].indices[p], { layerIndex: 0, x: l[0][p][0], y0: n, y: l[0][p][1] * c });for (let g = 1;g < d;++g)n += l[g - 1][p][1] * c, i.setItemLayout(a[g].indices[p], { layerIndex: g, x: l[g][p][0], y0: n, y: l[g][p][1] * c });
    }
  }bf((t, e) => {
    t.eachSeriesByType('themeRiver', (t) => {
      const e = t.getData(); const i = t.coordinateSystem; const n = {}; const o = i.getRect();n.rect = o;const a = t.get('boundaryGap'); const r = i.getAxis();(n.boundaryGap = a, 'horizontal' === r.orient) ? (a[0] = El(a[0], o.height), a[1] = El(a[1], o.height), tT(e, t, o.height - a[0] - a[1])) : (a[0] = El(a[0], o.width), a[1] = El(a[1], o.width), tT(e, t, o.width - a[0] - a[1]));e.setLayout('layoutInfo', n);
    });
  }), Sf((t) => {
    t.eachSeriesByType('themeRiver', (o) => {
      const a = o.getData(); const r = o.getRawData(); const s = o.get('color'); const l = Q();a.each((t) => {
        l.set(a.getRawIndex(t), t);
      }), r.each((t) => {
        const e = r.getName(t); const i = s[(o.nameMap.get(e) - 1) % s.length];r.setItemVisual(t, 'color', i);const n = l.get(t);null != n && a.setItemVisual(n, 'color', i);
      });
    });
  }), xf(uy('themeRiver')), sc.extend({ type: 'series.sunburst', _viewRoot: null, getInitialData(t, e) {
    const i = { name: t.name, children: t.data };!(function i(t) {
      let n = 0;R(t.children, (t) => {
        i(t);let e = t.value;L(e) && (e = e[0]), n += e;
      });let e = t.value;L(e) && (e = e[0]);null != e && !isNaN(e) || (e = n);e < 0 && (e = 0);L(t.value) ? t.value[0] = e : t.value = e;
    }(i));const o = O(t.levels || [], function (t) {
      return new Cl(t, this, e);
    }, this); var a = Ax.createTree(i, this, (t) => {
      t.wrapMethod('getItemModel', (t, e) => {
        const i = a.getNodeByDataIndex(e); const n = o[i.depth];return n && (t.parentModel = n), t;
      });
    });return a.data;
  }, optionUpdated() {
    this.resetViewRoot();
  }, getDataParams(t) {
    const e = sc.prototype.getDataParams.apply(this, arguments); const i = this.getData().tree.getNodeByDataIndex(t);return e.treePathInfo = Yx(i, this), e;
  }, defaultOption: { zlevel: 0, z: 2, center: ['50%', '50%'], radius: [0, '75%'], clockwise: !0, startAngle: 90, minAngle: 0, percentPrecision: 2, stillShowZeroSum: !0, highlightPolicy: 'descendant', nodeClick: 'rootToNode', renderLabelForZeroData: !1, label: { rotate: 'radial', show: !0, opacity: 1, align: 'center', position: 'inside', distance: 5, silent: !0 }, itemStyle: { borderWidth: 1, borderColor: 'white', borderType: 'solid', shadowBlur: 0, shadowColor: 'rgba(0, 0, 0, 0.2)', shadowOffsetX: 0, shadowOffsetY: 0, opacity: 1 }, highlight: { itemStyle: { opacity: 1 } }, downplay: { itemStyle: { opacity: .5 }, label: { opacity: .6 } }, animationType: 'expansion', animationDuration: 1e3, animationDurationUpdate: 500, animationEasing: 'cubicOut', data: [], levels: [], sort: 'desc' }, getViewRoot() {
    return this._viewRoot;
  }, resetViewRoot(t) {
    t ? this._viewRoot = t : t = this._viewRoot;const e = this.getRawData().tree.root;t && (t === e || e.contains(t)) || (this._viewRoot = e);
  } });const eT = 'none'; const iT = 'ancestor'; const nT = 'self'; const oT = 2; const aT = 4;function rT(t, e, i) {
    Ci.call(this);const n = new qr({ z2: oT });n.seriesIndex = e.seriesIndex;const o = new Ur({ z2: aT, silent: t.getModel('label').get('silent') });function a() {
      o.ignore = o.hoverIgnore;
    } function r() {
      o.ignore = o.normalIgnore;
    } this.add(n), this.add(o), this.updateData(!0, t, 'normal', e, i), this.on('emphasis', a).on('normal', r)
      .on('mouseover', a)
      .on('mouseout', r);
  } const sT = rT.prototype;sT.updateData = function (t, e, i, n, o) {
    (this.node = e).piece = this, n = n || this._seriesModel, o = o || this._ecModel;const a = this.childAt(0);a.dataIndex = e.dataIndex;const r = e.getModel(); const s = e.getLayout(); const l = P({}, s);l.label = null;const u = (function (t, e, i) {
      let n = t.getVisual('color'); const o = t.getVisual('visualMeta');o && 0 !== o.length || (n = null);let a = t.getModel('itemStyle').get('color'); { if (a) return a;if (n) return n;if (0 === t.depth) return i.option.color[0];const r = i.option.color.length;a = i.option.color[(function (t) {
        let e = t;for (;1 < e.depth;)e = e.parentNode;return _(t.getAncestors()[0].children, e);
      }(t)) % r]; } return a;
    }(e, 0, o));!(function (t, e, i) {
      e.getData().setItemVisual(t.dataIndex, 'color', i);
    }(e, n, u));let h; const c = r.getModel('itemStyle').getItemStyle();'normal' === i ? h = c : h = m(r.getModel(`${i}.itemStyle`).getItemStyle(), c);h = D({ lineJoin: 'bevel', fill: h.fill || u }, h), t ? (a.setShape(l), a.shape.r = s.r0, cl(a, { shape: { r: s.r } }, n, e.dataIndex), a.useStyle(h)) : 'object' === typeof h.fill && h.fill.type || 'object' === typeof a.style.fill && a.style.fill.type ? (cl(a, { shape: l }, n), a.useStyle(h)) : cl(a, { shape: l, style: h }, n), this._updateLabel(n, u, i);const d = r.getShallow('cursor');if (d && a.attr('cursor', d), t) {
      const f = n.getShallow('highlightPolicy');this._initEvents(a, e, n, f);
    } this._seriesModel = n || this._seriesModel, this._ecModel = o || this._ecModel, $s(this);
  }, sT.onEmphasis = function (e) {
    const i = this;this.node.hostTree.root.eachNode((t) => {
      t.piece && (i.node === t ? t.piece.updateData(!1, t, 'emphasis') : !(function (t, e, i) {
        return i !== eT && (i === nT ? t === e : i === iT ? t === e || t.isAncestorOf(e) : t === e || t.isDescendantOf(e));
      }(t, i.node, e)) ? e !== eT && t.piece.childAt(0).trigger('downplay') : t.piece.childAt(0).trigger('highlight'));
    });
  }, sT.onNormal = function () {
    this.node.hostTree.root.eachNode((t) => {
      t.piece && t.piece.updateData(!1, t, 'normal');
    });
  }, sT.onHighlight = function () {
    this.updateData(!1, this.node, 'highlight');
  }, sT.onDownplay = function () {
    this.updateData(!1, this.node, 'downplay');
  }, sT._updateLabel = function (t, e, i) {
    const n = this.node.getModel(); const o = n.getModel('label'); const a = 'normal' === i || 'emphasis' === i ? o : n.getModel(`${i}.label`); const r = n.getModel('emphasis.label'); const s = a.get('formatter') ? i : 'normal'; let l = W(t.getFormattedLabel(this.node.dataIndex, s, null, null, 'label'), this.node.name);!1 === M('show') && (l = '');const u = this.node.getLayout(); let h = a.get('minAngle');null == h && (h = o.get('minAngle')), h = h / 180 * Math.PI;const c = u.endAngle - u.startAngle;null != h && Math.abs(c) < h && (l = '');const d = this.childAt(1);el(d.style, d.hoverStyle || {}, o, r, { defaultText: a.getShallow('show') ? l : null, autoColor: e, useInsideStyle: !0 });let f; const p = (u.startAngle + u.endAngle) / 2; const g = Math.cos(p); const m = Math.sin(p); const v = M('position'); const y = M('distance') || 0; let x = M('align');'outside' === v ? (f = u.r + y, x = p > Math.PI / 2 ? 'right' : 'left') : x && 'center' !== x ? 'left' === x ? (f = u.r0 + y, p > Math.PI / 2 && (x = 'right')) : 'right' === x && (f = u.r - y, p > Math.PI / 2 && (x = 'left')) : (f = (u.r + u.r0) / 2, x = 'center'), d.attr('style', { text: l, textAlign: x, textVerticalAlign: M('verticalAlign') || 'middle', opacity: M('opacity') });const _ = f * g + u.cx; const w = f * m + u.cy;d.attr('position', [_, w]);const b = M('rotate'); let S = 0;function M(t) {
      const e = a.get(t);return null == e ? o.get(t) : e;
    }'radial' === b ? (S = -p) < -Math.PI / 2 && (S += Math.PI) : 'tangential' === b ? (S = Math.PI / 2 - p) > Math.PI / 2 ? S -= Math.PI : S < -Math.PI / 2 && (S += Math.PI) : 'number' === typeof b && (S = b * Math.PI / 180), d.attr('rotation', S);
  }, sT._initEvents = function (t, e, i, n) {
    t.off('mouseover').off('mouseout')
      .off('emphasis')
      .off('normal');function o() {
      r.onEmphasis(n);
    } function a() {
      r.onNormal();
    } var r = this;i.isAnimationEnabled() && t.on('mouseover', o).on('mouseout', a)
      .on('emphasis', o)
      .on('normal', a)
      .on('downplay', () => {
        r.onDownplay();
      })
      .on('highlight', () => {
        r.onHighlight();
      });
  }, w(rT, Ci);_c.extend({ type: 'sunburst', init() {}, render(o, a, t, e) {
    const n = this;this.seriesModel = o, this.api = t, this.ecModel = a;const r = o.getData(); const s = r.tree.root; const i = o.getViewRoot(); const l = this.group; const u = o.get('renderLabelForZeroData'); const h = [];i.eachNode((t) => {
      h.push(t);
    });const c = this._oldChildren || [];if ((function (i, n) {
      if (0 === i.length && 0 === n.length) return;function t(t) {
        return t.getId();
      } function e(t, e) {
        !(function (t, e) {
          u || !t || t.getValue() || (t = null);if (t !== s && e !== s) if (e && e.piece)t ? (e.piece.updateData(!1, t, 'normal', o, a), r.setItemGraphicEl(t.dataIndex, e.piece)) : (function (t) {
            if (!t) return;t.piece && (l.remove(t.piece), t.piece = null);
          }(e));else if (t) {
            const i = new rT(t, o, a);l.add(i), r.setItemGraphicEl(t.dataIndex, i);
          }
        }(null == t ? null : i[t], null == e ? null : n[e]));
      } new kf(n, i, t, t).add(e)
        .update(e)
        .remove(T(e, null))
        .execute();
    }(h, c)), (function (t, e) {
      if (0 < e.depth) {
        n.virtualPiece ? n.virtualPiece.updateData(!1, t, 'normal', o, a) : (n.virtualPiece = new rT(t, o, a), l.add(n.virtualPiece)), e.piece._onclickEvent && e.piece.off('click', e.piece._onclickEvent);const i = function (t) {
          n._rootToNode(e.parentNode);
        };e.piece._onclickEvent = i, n.virtualPiece.on('click', i);
      } else n.virtualPiece && (l.remove(n.virtualPiece), n.virtualPiece = null);
    }(s, i)), e && e.highlight && e.highlight.piece) {
      const d = o.getShallow('highlightPolicy');e.highlight.piece.onEmphasis(d);
    } else if (e && e.unhighlight) {
      let f = this.virtualPiece;!f && s.children.length && (f = s.children[0].piece), f && f.onNormal();
    } this._initEvents(), this._oldChildren = h;
  }, dispose() {}, _initEvents() {
    function t(o) {
      let a = !1;r.seriesModel.getViewRoot().eachNode((t) => {
        if (!a && t.piece && t.piece.childAt(0) === o.target) {
          const e = t.getModel().get('nodeClick');if ('rootToNode' === e)r._rootToNode(t);else if ('link' === e) {
            const i = t.getModel(); const n = i.get('link');if (n)gu(n, i.get('target', !0) || '_blank');
          }a = !0;
        }
      });
    } var r = this;this.group._onclickEvent && this.group.off('click', this.group._onclickEvent), this.group.on('click', t), this.group._onclickEvent = t;
  }, _rootToNode(t) {
    t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({ type: 'sunburstRootToNode', from: this.uid, seriesId: this.seriesModel.id, targetNode: t });
  }, containPoint(t, e) {
    const i = e.getData().getItemLayout(0);if (i) {
      const n = t[0] - i.cx; const o = t[1] - i.cy; const a = Math.sqrt(n * n + o * o);return a <= i.r && a >= i.r0;
    }
  } });const lT = 'sunburstRootToNode';_f({ type: lT, update: 'updateView' }, (o, t) => {
    t.eachComponent({ mainType: 'series', subType: 'sunburst', query: o }, (t, e) => {
      const i = Zx(o, [lT], t);if (i) {
        const n = t.getViewRoot();n && (o.direction = Xx(n, i.node) ? 'rollUp' : 'drillDown'), t.resetViewRoot(i.node);
      }
    });
  });const uT = 'sunburstHighlight';_f({ type: uT, update: 'updateView' }, (n, t) => {
    t.eachComponent({ mainType: 'series', subType: 'sunburst', query: n }, (t, e) => {
      const i = Zx(n, [uT], t);i && (n.highlight = i.node);
    });
  });_f({ type: 'sunburstUnhighlight', update: 'updateView' }, (i, t) => {
    t.eachComponent({ mainType: 'series', subType: 'sunburst', query: i }, (t, e) => {
      i.unhighlight = !0;
    });
  });const hT = Math.PI / 180;function cT(t, e) {
    if ('function' === typeof e) return t.sort(e);const n = 'asc' === e;return t.sort((t, e) => {
      const i = (t.getValue() - e.getValue()) * (n ? 1 : -1);return 0 == i ? (t.dataIndex - e.dataIndex) * (n ? -1 : 1) : i;
    });
  } function dT(a, r) {
    return r = r || [0, 0], O(['x', 'y'], function (t, e) {
      const i = this.getAxis(t); const n = r[e]; const o = a[e] / 2;return 'category' === i.type ? i.getBandWidth() : Math.abs(i.dataToCoord(n - o) - i.dataToCoord(n + o));
    }, this);
  }Sf(T(iy, 'sunburst')), bf(T((t, e, C, i) => {
    e.eachSeriesByType(t, (t) => {
      let e = t.get('center'); let i = t.get('radius');L(i) || (i = [0, i]), L(e) || (e = [e, e]);const n = C.getWidth(); const o = C.getHeight(); const h = Math.min(n, o); const c = El(e[0], n); const d = El(e[1], o); const f = El(i[0], h / 2); const a = El(i[1], h / 2); const r = -t.get('startAngle') * hT; const p = t.get('minAngle') * hT; const g = t.getData().tree.root; const s = t.getViewRoot(); const m = s.depth; const l = t.get('sort');null != l && !(function e(t, i) {
        const n = t.children || [];t.children = cT(n, i);n.length && R(t.children, (t) => {
          e(t, i);
        });
      }(s, l));let u = 0;R(s.children, (t) => {
        isNaN(t.getValue()) || u++;
      });const v = s.getValue(); const y = Math.PI / (v || u) * 2; const x = 0 < s.depth; const _ = s.height - (x ? -1 : 1); const w = (a - f) / (_ || 1); const b = t.get('clockwise'); const S = t.get('stillShowZeroSum'); const M = b ? 1 : -1; var I = function (t, e) {
        if (t) {
          let i = e;if (t !== g) {
            const n = t.getValue(); let o = 0 === v && S ? y : n * y;o < p && (o = p), i = e + M * o;const a = t.depth - m - (x ? -1 : 1); let r = f + w * a; let s = f + w * (1 + a); const l = t.getModel();null != l.get('r0') && (r = El(l.get('r0'), h / 2)), null != l.get('r') && (s = El(l.get('r'), h / 2)), t.setLayout({ angle: o, startAngle: e, endAngle: i, clockwise: b, cx: c, cy: d, r0: r, r: s });
          } if (t.children && t.children.length) {
            let u = 0;R(t.children, (t) => {
              u += I(t, e + u);
            });
          } return i - e;
        }
      };if (x) {
        const T = f; const A = f + w; const D = 2 * Math.PI;g.setLayout({ angle: D, startAngle: r, endAngle: r + D, clockwise: b, cx: c, cy: d, r0: T, r: A });
      }I(s, r);
    });
  }, 'sunburst')), xf(T(uy, 'sunburst'));function fT(a, r) {
    return r = r || [0, 0], O([0, 1], function (t) {
      const e = r[t]; const i = a[t] / 2; const n = []; const o = [];return n[t] = e - i, o[t] = e + i, n[1 - t] = o[1 - t] = r[1 - t], Math.abs(this.dataToPoint(n)[t] - this.dataToPoint(o)[t]);
    }, this);
  } function pT(t, e) {
    const i = this.getAxis(); const n = e instanceof Array ? e[0] : e; const o = (t instanceof Array ? t[0] : t) / 2;return 'category' === i.type ? i.getBandWidth() : Math.abs(i.dataToCoord(n - o) - i.dataToCoord(n + o));
  } function gT(s, l) {
    return O(['Radius', 'Angle'], function (t, e) {
      const i = this[`get${t}Axis`](); const n = l[e]; const o = s[e] / 2; const a = `dataTo${t}`; let r = 'category' === i.type ? i.getBandWidth() : Math.abs(i[a](n - o) - i[a](n + o));return 'Angle' === t && (r = r * Math.PI / 180), r;
    }, this);
  } const mT = Ss; const vT = ['itemStyle']; const yT = ['emphasis', 'itemStyle']; const xT = ['label']; const _T = ['emphasis', 'label']; const wT = 'e\0\0'; const bT = { cartesian2d(e) {
    const t = e.grid.getRect();return { coordSys: { type: 'cartesian2d', x: t.x, y: t.y, width: t.width, height: t.height }, api: { coord(t) {
      return e.dataToPoint(t);
    }, size: A(dT, e) } };
  }, geo(e) {
    const t = e.getBoundingRect();return { coordSys: { type: 'geo', x: t.x, y: t.y, width: t.width, height: t.height, zoom: e.getZoom() }, api: { coord(t) {
      return e.dataToPoint(t);
    }, size: A(fT, e) } };
  }, singleAxis(e) {
    const t = e.getRect();return { coordSys: { type: 'singleAxis', x: t.x, y: t.y, width: t.width, height: t.height }, api: { coord(t) {
      return e.dataToPoint(t);
    }, size: A(pT, e) } };
  }, polar(o) {
    const a = o.getRadiusAxis(); const r = o.getAngleAxis(); const t = a.getExtent();return t[0] > t[1] && t.reverse(), { coordSys: { type: 'polar', cx: o.cx, cy: o.cy, r: t[1], r0: t[0] }, api: { coord: A((t) => {
      const e = a.dataToRadius(t[0]); const i = r.dataToAngle(t[1]); const n = o.coordToPoint([e, i]);return n.push(e, i * Math.PI / 180), n;
    }), size: A(gT, o) } };
  }, calendar(i) {
    const t = i.getRect(); const e = i.getRangeInfo();return { coordSys: { type: 'calendar', x: t.x, y: t.y, width: t.width, height: t.height, cellWidth: i.getCellWidth(), cellHeight: i.getCellHeight(), rangeInfo: { start: e.start, end: e.end, weeks: e.weeks, dayCount: e.allDay } }, api: { coord(t, e) {
      return i.dataToPoint(t, e);
    } } };
  } };function ST(t, e, i, n, o) {
    null == i[t] || o || (e[t] = i[t], i[t] = n[t]);
  } function MT(a, r, e, t) {
    const i = a.get('renderItem'); const n = a.coordinateSystem; let o = {};n && (o = n.prepareCustoms ? n.prepareCustoms() : bT[n.type](n));let s; let l; let u; let h; let c; const d = D({ getWidth: t.getWidth, getHeight: t.getHeight, getZr: t.getZr, getDevicePixelRatio: t.getDevicePixelRatio, value(t, e) {
      return null == e && (e = s), r.get(r.getDimension(t || 0), e);
    }, style(t, e) {
      null == e && (e = s), g(e);const i = l.getModel(vT).getItemStyle();null != c && (i.fill = c);const n = r.getItemVisual(e, 'opacity');null != n && (i.opacity = n);const o = t ? CT(t, u) : u;return nl(i, o, null, { autoColor: c, isRectText: !0 }), i.text = o.getShallow('show') ? H(a.getFormattedLabel(e, 'normal'), Ug(r, e)) : null, t && LT(i, t), i;
    }, styleEmphasis(t, e) {
      null == e && (e = s), g(e);const i = l.getModel(yT).getItemStyle(); const n = t ? CT(t, h) : h;return nl(i, n, null, { isRectText: !0 }, !0), i.text = n.getShallow('show') ? Z(a.getFormattedLabel(e, 'emphasis'), a.getFormattedLabel(e, 'normal'), Ug(r, e)) : null, t && LT(i, t), i;
    }, visual(t, e) {
      return null == e && (e = s), r.getItemVisual(e, t);
    }, barLayout(t) {
      if (n.getBaseAxis) {
        return (function (t) {
          const e = []; const i = t.axis;if ('category' === i.type) {
            for (var n = i.getBandWidth(), o = 0;o < t.count;o++)e.push(D({ bandWidth: n, axisKey: 'axis0', stackId: Cp + o }, t));const a = Rp(e); const r = [];for (o = 0;o < t.count;o++) {
              const s = a.axis0[Cp + o];s.offsetCenter = s.offset + s.width / 2, r.push(s);
            } return r;
          }
        }(D({ axis: n.getBaseAxis() }, t)));
      }
    }, currentSeriesIndices() {
      return e.getCurrentSeriesIndices();
    }, font(t) {
      return ul(t, e);
    } }, o.api || {}); const f = { context: {}, seriesId: a.id, seriesName: a.name, seriesIndex: a.seriesIndex, coordSys: o.coordSys, dataInsideLength: r.count(), encode: (function (o) {
      const a = {};return R(o.dimensions, (t, e) => {
        const i = o.getDimensionInfo(t);if (!i.isExtraCoord) {
          const n = i.coordDim;(a[n] = a[n] || [])[i.coordDimIndex] = e;
        }
      }), a;
    }(a.getData())) }; let p = !0;return function (t, e) {
      return s = t, p = !0, i && i(D({ dataIndexInside: t, dataIndex: r.getRawIndex(t), actionType: e ? e.type : null }, f), d);
    };function g(t) {
      null == t && (t = s), p && (l = r.getItemModel(t), u = l.getModel(xT), h = l.getModel(_T), c = r.getItemVisual(t, 'color'), p = !1);
    }
  } function IT(t, e, i, n, o, a) {
    return (t = TT(t, e, i, n, o, a, !0)) && a.setItemGraphicEl(e, t), t;
  } function TT(t, e, i, n, o, a, r) {
    const s = !i; const l = (i = i || {}).type; const u = i.shape; const h = i.style;if (t && (s || null != l && l !== t.__customGraphicType || 'path' === l && (function (t) {
      return t && (t.hasOwnProperty('pathData') || t.hasOwnProperty('d'));
    }(u)) && PT(u) !== t.__customPathData || 'image' === l && NT(h, 'image') && h.image !== t.__customImagePath || 'text' === l && NT(u, 'text') && h.text !== t.__customText) && (o.remove(t), t = null), !s) {
      const c = !t;return (function (e, t, i, n, o, a, r) {
        const s = {}; const l = i.style || {};if (i.shape && (s.shape = k(i.shape)), i.position && (s.position = i.position.slice()), i.scale && (s.scale = i.scale.slice()), i.origin && (s.origin = i.origin.slice()), i.rotation && (s.rotation = i.rotation), 'image' === e.type && i.style) {
          var u = s.style = {};R(['x', 'y', 'width', 'height'], (t) => {
            ST(t, u, l, e.style, a);
          });
        } if ('text' === e.type && i.style) {
          u = s.style = {};R(['x', 'y'], (t) => {
            ST(t, u, l, e.style, a);
          }), !l.hasOwnProperty('textFill') && l.fill && (l.textFill = l.fill), !l.hasOwnProperty('textStroke') && l.stroke && (l.textStroke = l.stroke);
        } if ('group' !== e.type && (e.useStyle(l), a)) {
          e.style.opacity = 0;let h = l.opacity;null == h && (h = 1), dl(e, { style: { opacity: h } }, n, t);
        }a ? e.attr(s) : cl(e, s, n, t), i.hasOwnProperty('z2') && e.attr('z2', i.z2 || 0), i.hasOwnProperty('silent') && e.attr('silent', i.silent), i.hasOwnProperty('invisible') && e.attr('invisible', i.invisible), i.hasOwnProperty('ignore') && e.attr('ignore', i.ignore), i.hasOwnProperty('info') && e.attr('info', i.info);const c = i.styleEmphasis;Us(e, c), r && Js(e, !1 !== c);
      }(t = t || (function (t) {
        let e; const i = t.type;if ('path' === i) {
          const n = t.shape; const o = null != n.width && null != n.height ? { x: n.x || 0, y: n.y || 0, width: n.width, height: n.height } : null; const a = PT(n);(e = Ps(a, null, o, n.layout || 'center')).__customPathData = a;
        } else if ('image' === i)(e = new Qn({})).__customImagePath = t.style.image;else if ('text' === i)(e = new Ur({})).__customText = t.style.text;else if ('group' === i)e = new Ci;else {
          if ('compoundPath' === i) throw new Error('"compoundPath" is not supported yet.');e = new(ks(i));
        } return e.__customGraphicType = i, e.name = t.name, e;
      }(i)), e, i, n, 0, c, r)), 'group' === l && (function (t, e, i, n, o) {
        const a = i.children; const r = a ? a.length : 0; const s = i.$mergeChildren; const l = 'byName' === s || i.diffChildrenByName; const u = !1 === s;if (!r && !l && !u) return;if (l) return (function (t) {
          new kf(t.oldChildren, t.newChildren, AT, AT, t).add(DT)
            .update(DT)
            .remove(kT)
            .execute();
        }({ oldChildren: t.children() || [], newChildren: a || [], dataIndex: e, animatableModel: n, group: t, data: o }));u && t.removeAll();for (let h = 0;h < r;h++)a[h] && TT(t.childAt(h), e, a[h], n, t, o);
      }(t, e, i, n, a)), o.add(t), t;
    }
  } function AT(t, e) {
    const i = t && t.name;return null != i ? i : wT + e;
  } function DT(t, e) {
    const i = this.context; const n = null != t ? i.newChildren[t] : null;TT(null != e ? i.oldChildren[e] : null, i.dataIndex, n, i.animatableModel, i.group, i.data);
  } function CT(i, t) {
    const n = new Cl({}, t);return R(mT, (t, e) => {
      i.hasOwnProperty(t) && (n.option[e] = i[t]);
    }), n;
  } function LT(t, e) {
    for (const i in e)!e.hasOwnProperty(i) && mT.hasOwnProperty(i) || (t[i] = e[i]);
  } function kT(t) {
    const e = this.context; const i = e.oldChildren[t];i && e.group.remove(i);
  } function PT(t) {
    return t && (t.pathData || t.d);
  } function NT(t, e) {
    return t && t.hasOwnProperty(e);
  } function OT(t) {
    return t.get('stack') || `__ec_stack_${t.seriesIndex}`;
  } function RT(t, e) {
    return e.dim + t.model.componentIndex;
  } function ET(t, e) {
    Gg.call(this, 'radius', t, e), this.type = 'category';
  }sc.extend({ type: 'series.custom', dependencies: ['grid', 'polar', 'geo', 'singleAxis', 'calendar'], defaultOption: { coordinateSystem: 'cartesian2d', zlevel: 0, z: 2, legendHoverLink: !0, useTransform: !0, clip: !1 }, getInitialData(t, e) {
    return gp(this.getSource(), this);
  }, getDataParams(t, e, i) {
    const n = sc.prototype.getDataParams.apply(this, arguments);return i && (n.info = i.info), n;
  } }), _c.extend({ type: 'custom', _data: null, render(i, t, e, n) {
    const o = this._data; const a = i.getData(); const r = this.group; const s = MT(i, a, t, e);a.diff(o).add((t) => {
      IT(null, t, s(t, n), i, r, a);
    })
      .update((t, e) => {
        IT(o.getItemGraphicEl(e), t, s(t, n), i, r, a);
      })
      .remove((t) => {
        const e = o.getItemGraphicEl(t);e && r.remove(e);
      })
      .execute();const l = i.get('clip', !0) ? Sm(i.coordinateSystem, !1, i) : null;l ? r.setClipPath(l) : r.removeClipPath(), this._data = a;
  }, incrementalPrepareRender(t, e, i) {
    this.group.removeAll(), this._data = null;
  }, incrementalRender(t, e, i, n, o) {
    const a = e.getData(); const r = MT(e, a, i, n);function s(t) {
      t.isGroup || (t.incremental = !0, t.useHoverLayer = !0);
    } for (let l = t.start;l < t.end;l++) {
      IT(null, l, r(l, o), e, this.group, a).traverse(s);
    }
  }, dispose: et, filterForExposedEvent(t, e, i, n) {
    const o = e.element;if (null == o || i.name === o) return !0;for (;(i = i.parent) && i !== this.group;) if (i.name === o) return !0;return !1;
  } }), ET.prototype = { constructor: ET, pointToData(t, e) {
    return this.polar.pointToData(t, e)['radius' === this.dim ? 0 : 1];
  }, dataToRadius: Gg.prototype.dataToCoord, radiusToData: Gg.prototype.coordToData }, w(ET, Gg);const zT = jo();function BT(t, e) {
    e = e || [0, 360], Gg.call(this, 'angle', t, e), this.type = 'category';
  }BT.prototype = { constructor: BT, pointToData(t, e) {
    return this.polar.pointToData(t, e)['radius' === this.dim ? 0 : 1];
  }, dataToAngle: Gg.prototype.dataToCoord, angleToData: Gg.prototype.coordToData, calculateCategoryInterval() {
    const t = this.getLabelModel(); const e = this.scale; const i = e.getExtent(); const n = e.count();if (i[1] - i[0] < 1) return 0;const o = i[0]; const a = this.dataToCoord(o + 1) - this.dataToCoord(o); const r = Math.abs(a); const s = gn(o, t.getFont(), 'center', 'top'); let l = Math.max(s.height, 7) / r;isNaN(l) && (l = 1 / 0);let u = Math.max(0, Math.floor(l)); const h = zT(this.model); const c = h.lastAutoInterval; const d = h.lastTickCount;return null != c && null != d && Math.abs(c - u) <= 1 && Math.abs(d - n) <= 1 && u < c ? u = c : (h.lastTickCount = n, h.lastAutoInterval = u), u;
  } }, w(BT, Gg);function VT(t) {
    this.name = t || '', this.cx = 0, this.cy = 0, this._radiusAxis = new ET, this._angleAxis = new BT, this._radiusAxis.polar = this._angleAxis.polar = this;
  }VT.prototype = { type: 'polar', axisPointerEnabled: !0, constructor: VT, dimensions: ['radius', 'angle'], model: null, containPoint(t) {
    const e = this.pointToCoord(t);return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1]);
  }, containData(t) {
    return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1]);
  }, getAxis(t) {
    return this[`_${t}Axis`];
  }, getAxes() {
    return [this._radiusAxis, this._angleAxis];
  }, getAxesByScale(t) {
    const e = []; const i = this._angleAxis; const n = this._radiusAxis;return i.scale.type === t && e.push(i), n.scale.type === t && e.push(n), e;
  }, getAngleAxis() {
    return this._angleAxis;
  }, getRadiusAxis() {
    return this._radiusAxis;
  }, getOtherAxis(t) {
    const e = this._angleAxis;return t === e ? this._radiusAxis : e;
  }, getBaseAxis() {
    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAngleAxis();
  }, getTooltipAxes(t) {
    const e = null != t && 'auto' !== t ? this.getAxis(t) : this.getBaseAxis();return { baseAxes: [e], otherAxes: [this.getOtherAxis(e)] };
  }, dataToPoint(t, e) {
    return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e)]);
  }, pointToData(t, e) {
    const i = this.pointToCoord(t);return [this._radiusAxis.radiusToData(i[0], e), this._angleAxis.angleToData(i[1], e)];
  }, pointToCoord(t) {
    let e = t[0] - this.cx; let i = t[1] - this.cy; const n = this.getAngleAxis(); const o = n.getExtent(); let a = Math.min(o[0], o[1]); let r = Math.max(o[0], o[1]);n.inverse ? a = r - 360 : r = a + 360;const s = Math.sqrt(e * e + i * i);e /= s, i /= s;for (var l = Math.atan2(-i, e) / Math.PI * 180, u = l < a ? 1 : -1;l < a || r < l;)l += 360 * u;return [s, l];
  }, coordToPoint(t) {
    const e = t[0]; const i = t[1] / 180 * Math.PI;return [Math.cos(i) * e + this.cx, -Math.sin(i) * e + this.cy];
  }, getArea() {
    const t = this.getAngleAxis(); const e = this.getRadiusAxis().getExtent()
      .slice();e[0] > e[1] && e.reverse();const i = t.getExtent(); const n = Math.PI / 180;return { cx: this.cx, cy: this.cy, r0: e[0], r: e[1], startAngle: -i[0] * n, endAngle: -i[1] * n, clockwise: t.inverse, contain(t, e) {
      const i = t - this.cx; const n = e - this.cy; const o = i * i + n * n; const a = this.r; const r = this.r0;return o <= a * a && r * r <= o;
    } };
  } };const GT = ku.extend({ type: 'polarAxis', axis: null, getCoordSysModel() {
    return this.ecModel.queryComponents({ mainType: 'polar', index: this.option.polarIndex, id: this.option.polarId })[0];
  } });m(GT.prototype, dg);const FT = { splitNumber: 5 };function WT(t, e) {
    return e.type || (e.data ? 'category' : 'value');
  } function HT(t, e) {
    const i = this; const n = i.getAngleAxis(); const o = i.getRadiusAxis();if (n.scale.setExtent(1 / 0, -1 / 0), o.scale.setExtent(1 / 0, -1 / 0), t.eachSeries((t) => {
      if (t.coordinateSystem === i) {
        const e = t.getData();R(e.mapDimension('radius', !0), (t) => {
          o.scale.unionExtentFromData(e, pp(e, t));
        }), R(e.mapDimension('angle', !0), (t) => {
          n.scale.unionExtentFromData(e, pp(e, t));
        });
      }
    }), rg(n.scale, n.model), rg(o.scale, o.model), 'category' === n.type && !n.onBand) {
      const a = n.getExtent(); const r = 360 / n.scale.count();n.inverse ? a[1] += r : a[1] -= r, n.setExtent(a[0], a[1]);
    }
  } function ZT(t, e) {
    if (t.type = e.get('type'), t.scale = sg(e), t.onBand = e.get('boundaryGap') && 'category' === t.type, t.inverse = e.get('inverse'), 'angleAxis' === e.mainType) {
      t.inverse ^= e.get('clockwise');const i = e.get('startAngle');t.setExtent(i, i + (t.inverse ? -360 : 360));
    }(e.axis = t).model = e;
  }Gm('angle', GT, WT, { startAngle: 90, clockwise: !0, splitNumber: 12, axisLabel: { rotate: !1 } }), Gm('radius', GT, WT, FT), Tf({ type: 'polar', dependencies: ['polarAxis', 'angleAxis'], coordinateSystem: null, findAxisModel(t) {
    let e;return this.ecModel.eachComponent(t, function (t) {
      t.getCoordSysModel() === this && (e = t);
    }, this), e;
  }, defaultOption: { zlevel: 0, z: 0, center: ['50%', '50%'], radius: '80%' } }), lh.register('polar', { dimensions: VT.prototype.dimensions, create(i, s) {
    const l = [];return i.eachComponent('polar', (t, e) => {
      const i = new VT(e);i.update = HT;const n = i.getRadiusAxis(); const o = i.getAngleAxis(); const a = t.findAxisModel('radiusAxis'); const r = t.findAxisModel('angleAxis');ZT(n, a), ZT(o, r), (function (t, e, i) {
        const n = e.get('center'); const o = i.getWidth(); const a = i.getHeight();t.cx = El(n[0], o), t.cy = El(n[1], a);const r = t.getRadiusAxis(); const s = Math.min(o, a) / 2; let l = e.get('radius');null == l ? l = [0, '100%'] : L(l) || (l = [0, l]), l = [El(l[0], s), El(l[1], s)], r.inverse ? r.setExtent(l[1], l[0]) : r.setExtent(l[0], l[1]);
      }(i, t, s)), l.push(i), (t.coordinateSystem = i).model = t;
    }), i.eachSeries((t) => {
      if ('polar' === t.get('coordinateSystem')) {
        const e = i.queryComponents({ mainType: 'polar', index: t.get('polarIndex'), id: t.get('polarId') })[0];t.coordinateSystem = e.coordinateSystem;
      }
    }), l;
  } });const UT = ['axisLine', 'axisLabel', 'axisTick', 'minorTick', 'splitLine', 'minorSplitLine', 'splitArea'];function XT(t, e, i) {
    e[1] > e[0] && (e = e.slice().reverse());const n = t.coordToPoint([e[0], i]); const o = t.coordToPoint([e[1], i]);return { x1: n[0], y1: n[1], x2: o[0], y2: o[1] };
  } function YT(t) {
    return t.getRadiusAxis().inverse ? 0 : 1;
  } function jT(t) {
    const e = t[0]; const i = t[t.length - 1];e && i && Math.abs(Math.abs(e.coord - i.coord) - 360) < 1e-4 && t.pop();
  }mv.extend({ type: 'angleAxis', axisPointerClass: 'PolarAxisPointer', render(e, t) {
    if (this.group.removeAll(), e.get('show')) {
      const i = e.axis; const n = i.polar; const o = n.getRadiusAxis().getExtent(); const a = i.getTicksCoords(); const r = i.getMinorTicksCoords(); const s = O(i.getViewLabels(), t => ((t = k(t)).coord = i.dataToCoord(t.tickValue), t));jT(s), jT(a), R(UT, function (t) {
        !e.get(`${t}.show`) || i.scale.isBlank() && 'axisLine' !== t || this[`_${t}`](e, n, a, r, o, s);
      }, this);
    }
  }, _axisLine(t, e, i, n, o) {
    let a; const r = t.getModel('axisLine.lineStyle'); const s = YT(e); const l = s ? 0 : 1;(a = 0 === o[l] ? new Yr({ shape: { cx: e.cx, cy: e.cy, r: o[s] }, style: r.getLineStyle(), z2: 1, silent: !0 }) : new Kr({ shape: { cx: e.cx, cy: e.cy, r: o[s], r0: o[l] }, style: r.getLineStyle(), z2: 1, silent: !0 })).style.fill = null, this.group.add(a);
  }, _axisTick(t, e, i, n, o) {
    const a = t.getModel('axisTick'); const r = (a.get('inside') ? -1 : 1) * a.get('length'); const s = o[YT(e)]; const l = O(i, t => new ls({ shape: XT(e, [s, s + r], t.coord) }));this.group.add(Rs(l, { style: D(a.getModel('lineStyle').getLineStyle(), { stroke: t.get('axisLine.lineStyle.color') }) }));
  }, _minorTick(t, e, i, n, o) {
    if (n.length) {
      for (var a = t.getModel('axisTick'), r = t.getModel('minorTick'), s = (a.get('inside') ? -1 : 1) * r.get('length'), l = o[YT(e)], u = [], h = 0;h < n.length;h++) for (let c = 0;c < n[h].length;c++)u.push(new ls({ shape: XT(e, [l, l + s], n[h][c].coord) }));this.group.add(Rs(u, { style: D(r.getModel('lineStyle').getLineStyle(), D(a.getLineStyle(), { stroke: t.get('axisLine.lineStyle.color') })) }));
    }
  }, _axisLabel(c, d, t, e, f, i) {
    const p = c.getCategories(!0); const g = c.getModel('axisLabel'); const m = g.get('margin'); const v = c.get('triggerEvent');R(i, function (t, e) {
      let i = g; const n = t.tickValue; const o = f[YT(d)]; const a = d.coordToPoint([o + m, t.coord]); const r = d.cx; const s = d.cy; const l = Math.abs(a[0] - r) / o < .3 ? 'center' : a[0] > r ? 'left' : 'right'; const u = Math.abs(a[1] - s) / o < .3 ? 'middle' : a[1] > s ? 'top' : 'bottom';p && p[n] && p[n].textStyle && (i = new Cl(p[n].textStyle, g, g.ecModel));const h = new Ur({ silent: Qm.isLabelSilent(c) });this.group.add(h), nl(h.style, i, { x: a[0], y: a[1], textFill: i.getTextColor() || c.get('axisLine.lineStyle.color'), text: t.formattedLabel, textAlign: l, textVerticalAlign: u }), v && (h.eventData = Qm.makeAxisEventDataBase(c), h.eventData.targetType = 'axisLabel', h.eventData.value = t.rawLabel);
    }, this);
  }, _splitLine(t, e, i, n, o) {
    const a = t.getModel('splitLine').getModel('lineStyle'); let r = a.get('color'); let s = 0;r = r instanceof Array ? r : [r];for (var l = [], u = 0;u < i.length;u++) {
      const h = s++ % r.length;l[h] = l[h] || [], l[h].push(new ls({ shape: XT(e, o, i[u].coord) }));
    } for (u = 0;u < l.length;u++) this.group.add(Rs(l[u], { style: D({ stroke: r[u % r.length] }, a.getLineStyle()), silent: !0, z: t.get('z') }));
  }, _minorSplitLine(t, e, i, n, o) {
    if (n.length) {
      for (var a = t.getModel('minorSplitLine').getModel('lineStyle'), r = [], s = 0;s < n.length;s++) for (let l = 0;l < n[s].length;l++)r.push(new ls({ shape: XT(e, o, n[s][l].coord) }));this.group.add(Rs(r, { style: a.getLineStyle(), silent: !0, z: t.get('z') }));
    }
  }, _splitArea(t, e, i, n, o) {
    if (i.length) {
      const a = t.getModel('splitArea').getModel('areaStyle'); let r = a.get('color'); let s = 0;r = r instanceof Array ? r : [r];for (var l = [], u = Math.PI / 180, h = -i[0].coord * u, c = Math.min(o[0], o[1]), d = Math.max(o[0], o[1]), f = t.get('clockwise'), p = 1;p < i.length;p++) {
        const g = s++ % r.length;l[g] = l[g] || [], l[g].push(new qr({ shape: { cx: e.cx, cy: e.cy, r0: c, r: d, startAngle: h, endAngle: -i[p].coord * u, clockwise: f }, silent: !0 })), h = -i[p].coord * u;
      } for (p = 0;p < l.length;p++) this.group.add(Rs(l[p], { style: D({ fill: r[p % r.length] }, a.getAreaStyle()), silent: !0 }));
    }
  } });const qT = ['axisLine', 'axisTickLabel', 'axisName']; const KT = ['splitLine', 'splitArea', 'minorSplitLine'];mv.extend({ type: 'radiusAxis', axisPointerClass: 'PolarAxisPointer', render(e, t) {
    if (this.group.removeAll(), e.get('show')) {
      const i = e.axis; const n = i.polar; const o = n.getAngleAxis(); const a = i.getTicksCoords(); const r = i.getMinorTicksCoords(); const s = o.getExtent()[0]; const l = i.getExtent(); const u = (function (t, e, i) {
        return { position: [t.cx, t.cy], rotation: i / 180 * Math.PI, labelDirection: -1, tickDirection: -1, nameDirection: 1, labelRotate: e.getModel('axisLabel').get('rotate'), z2: 1 };
      }(n, e, s)); const h = new Qm(e, u);R(qT, h.add, h), this.group.add(h.getGroup()), R(KT, function (t) {
        e.get(`${t}.show`) && !i.scale.isBlank() && this[`_${t}`](e, n, s, l, a, r);
      }, this);
    }
  }, _splitLine(t, e, i, n, o) {
    const a = t.getModel('splitLine').getModel('lineStyle'); let r = a.get('color'); let s = 0;r = r instanceof Array ? r : [r];for (var l = [], u = 0;u < o.length;u++) {
      const h = s++ % r.length;l[h] = l[h] || [], l[h].push(new Yr({ shape: { cx: e.cx, cy: e.cy, r: o[u].coord } }));
    } for (u = 0;u < l.length;u++) this.group.add(Rs(l[u], { style: D({ stroke: r[u % r.length], fill: null }, a.getLineStyle()), silent: !0 }));
  }, _minorSplitLine(t, e, i, n, o, a) {
    if (a.length) {
      for (var r = t.getModel('minorSplitLine').getModel('lineStyle'), s = [], l = 0;l < a.length;l++) for (let u = 0;u < a[l].length;u++)s.push(new Yr({ shape: { cx: e.cx, cy: e.cy, r: a[l][u].coord } }));this.group.add(Rs(s, { style: D({ fill: null }, r.getLineStyle()), silent: !0 }));
    }
  }, _splitArea(t, e, i, n, o) {
    if (o.length) {
      const a = t.getModel('splitArea').getModel('areaStyle'); let r = a.get('color'); let s = 0;r = r instanceof Array ? r : [r];for (var l = [], u = o[0].coord, h = 1;h < o.length;h++) {
        const c = s++ % r.length;l[c] = l[c] || [], l[c].push(new qr({ shape: { cx: e.cx, cy: e.cy, r0: u, r: o[h].coord, startAngle: 0, endAngle: 2 * Math.PI }, silent: !0 })), u = o[h].coord;
      } for (h = 0;h < l.length;h++) this.group.add(Rs(l[h], { style: D({ fill: r[h % r.length] }, a.getAreaStyle()), silent: !0 }));
    }
  } });const $T = LI.extend({ makeElOption(t, e, i, n, o) {
    const a = i.axis;'angle' === a.dim && (this.animationThreshold = Math.PI / 18);let r; const s = a.polar; const l = s.getOtherAxis(a).getExtent();r = a[`dataTo${fu(a.dim)}`](e);const u = n.get('type');if (u && 'none' !== u) {
      const h = RI(n); const c = JT[u](a, s, r, l, h);c.style = h, t.graphicKey = c.type, t.pointer = c;
    } const d = n.get('label.margin');EI(t, i, n, o, (function (t, e, i, n, o) {
      const a = e.axis; const r = a.dataToCoord(t); let s = n.getAngleAxis().getExtent()[0];s = s / 180 * Math.PI;let l; let u; let h; const c = n.getRadiusAxis().getExtent();if ('radius' === a.dim) {
        const d = ae();he(d, d, s), ue(d, d, [n.cx, n.cy]), l = pl([r, -o], d);const f = e.getModel('axisLabel').get('rotate') || 0; const p = Qm.innerTextLayout(s, f * Math.PI / 180, -1);u = p.textAlign, h = p.textVerticalAlign;
      } else {
        const g = c[1];l = n.coordToPoint([g + o, r]);const m = n.cx; const v = n.cy;u = Math.abs(l[0] - m) / g < .3 ? 'center' : l[0] > m ? 'left' : 'right', h = Math.abs(l[1] - v) / g < .3 ? 'middle' : l[1] > v ? 'top' : 'bottom';
      } return { position: l, align: u, verticalAlign: h };
    }(e, i, 0, s, d)));
  } });var JT = { line(t, e, i, n, o) {
    return 'angle' === t.dim ? { type: 'Line', shape: GI(e.coordToPoint([n[0], i]), e.coordToPoint([n[1], i])) } : { type: 'Circle', shape: { cx: e.cx, cy: e.cy, r: i } };
  }, shadow(t, e, i, n, o) {
    const a = Math.max(1, t.getBandWidth()); const r = Math.PI / 180;return 'angle' === t.dim ? { type: 'Sector', shape: WI(e.cx, e.cy, n[0], n[1], (-i - a / 2) * r, (a / 2 - i) * r) } : { type: 'Sector', shape: WI(e.cx, e.cy, i - a / 2, i + a / 2, 0, 2 * Math.PI) };
  } };function QT(n, t) {
    t.update = 'updateView', _f(t, (t, e) => {
      const i = {};return e.eachComponent({ mainType: 'geo', query: t }, (e) => {
        e[n](t.name), R(e.coordinateSystem.regions, (t) => {
          i[t.name] = e.isSelected(t.name) || !1;
        });
      }), { selected: i, name: t.name };
    });
  }mv.registerAxisPointerClass('PolarAxisPointer', $T), bf(T(function (t, e, i) {
    const N = {}; const O = (function (t) {
      const g = {};R(t, (t, e) => {
        const i = t.getData(); const n = t.coordinateSystem; const o = n.getBaseAxis(); const a = RT(n, o); const r = o.getExtent(); const s = 'category' === o.type ? o.getBandWidth() : Math.abs(r[1] - r[0]) / i.count(); const l = g[a] || { bandWidth: s, remainedWidth: s, autoWidthCount: 0, categoryGap: '20%', gap: '30%', stacks: {} }; const u = l.stacks;g[a] = l;const h = OT(t);u[h] || l.autoWidthCount++, u[h] = u[h] || { width: 0, maxWidth: 0 };let c = El(t.get('barWidth'), s); const d = El(t.get('barMaxWidth'), s); const f = t.get('barGap'); const p = t.get('barCategoryGap');c && !u[h].width && (c = Math.min(l.remainedWidth, c), u[h].width = c, l.remainedWidth -= c), d && (u[h].maxWidth = d), null != f && (l.gap = f), null != p && (l.categoryGap = p);
      });const d = {};return R(g, (t, i) => {
        d[i] = {};const e = t.stacks; const n = t.bandWidth; const o = El(t.categoryGap, n); const a = El(t.gap, 1); let r = t.remainedWidth; let s = t.autoWidthCount; let l = (r - o) / (s + (s - 1) * a);l = Math.max(l, 0), R(e, (t, e) => {
          let i = t.maxWidth;i && i < l && (i = Math.min(i, r), t.width && (i = Math.min(i, t.width)), r -= i, t.width = i, s--);
        }), l = (r - o) / (s + (s - 1) * a), l = Math.max(l, 0);let u; let h = 0;R(e, (t, e) => {
          t.width || (t.width = l), h += (u = t).width * (1 + a);
        }), u && (h -= u.width * a);let c = -h / 2;R(e, (t, e) => {
          d[i][e] = d[i][e] || { offset: c, width: t.width }, c += t.width * (1 + a);
        });
      }), d;
    }(M(e.getSeriesByType(t), t => !e.isSeriesFiltered(t) && t.coordinateSystem && 'polar' === t.coordinateSystem.type)));e.eachSeriesByType(t, (t) => {
      if ('polar' === t.coordinateSystem.type) {
        const e = t.getData(); const i = t.coordinateSystem; const n = i.getBaseAxis(); const o = RT(i, n); const a = OT(t); const r = O[o][a]; const s = r.offset; const l = r.width; const u = i.getOtherAxis(n); const h = t.coordinateSystem.cx; const c = t.coordinateSystem.cy; const d = t.get('barMinHeight') || 0; const f = t.get('barMinAngle') || 0;N[a] = N[a] || [];for (let p = e.mapDimension(u.dim), g = e.mapDimension(n.dim), m = fp(e, p), v = 'radius' !== n.dim || !t.get('roundCap', !0), y = 'radius' === u.dim ? u.dataToRadius(0) : u.dataToAngle(0), x = 0, _ = e.count();x < _;x++) {
          var w; var b; var S; var M; const I = e.get(p, x); const T = e.get(g, x); const A = 0 <= I ? 'p' : 'n'; let D = y;if (m && (N[a][T] || (N[a][T] = { p: y, n: y }), D = N[a][T][A]), 'radius' === u.dim) {
            let C = u.dataToRadius(I) - y; const L = n.dataToAngle(T);Math.abs(C) < d && (C = (C < 0 ? -1 : 1) * d), b = (w = D) + C, M = (S = L - s) - l, m && (N[a][T][A] = b);
          } else {
            let k = u.dataToAngle(I, v) - y; const P = n.dataToRadius(T);Math.abs(k) < f && (k = (k < 0 ? -1 : 1) * f), b = (w = P + s) + l, M = (S = D) + k, m && (N[a][T][A] = M);
          }e.setItemLayout(x, { cx: h, cy: c, r0: w, r: b, startAngle: -S * Math.PI / 180, endAngle: -M * Math.PI / 180 });
        }
      }
    }, this);
  }, 'bar')), Af({ type: 'polar' }), b(ku.extend({ type: 'geo', coordinateSystem: null, layoutMode: 'box', init(t) {
    ku.prototype.init.apply(this, arguments), Go(t, 'label', ['show']);
  }, optionUpdated() {
    const t = this.option; const i = this;t.regions = px.getFilledRegions(t.regions, t.map, t.nameMap), this._optionModelMap = S(t.regions || [], (t, e) => (e.name && t.set(e.name, new Cl(e, i)), t), Q()), this.updateSelectedMap(t.regions);
  }, defaultOption: { zlevel: 0, z: 0, show: !0, left: 'center', top: 'center', aspectScale: null, silent: !1, map: '', boundingCoords: null, center: null, zoom: 1, scaleLimit: null, label: { show: !1, color: '#000' }, itemStyle: { borderWidth: .5, borderColor: '#444', color: '#eee' }, emphasis: { label: { show: !0, color: 'rgb(100,0,0)' }, itemStyle: { color: 'rgba(255,215,0,0.8)' } }, regions: [] }, getRegionModel(t) {
    return this._optionModelMap.get(t) || new Cl(null, this, this.ecModel);
  }, getFormattedLabel(t, e) {
    e = e || 'normal';const i = this.getRegionModel(t).get(`${'normal' === e ? '' : `${e}.`}label.formatter`); const n = { name: t };return 'function' === typeof i ? (n.status = e, i(n)) : 'string' === typeof i ? i.replace('{a}', null != t ? t : '') : void 0;
  }, setZoom(t) {
    this.option.zoom = t;
  }, setCenter(t) {
    this.option.center = t;
  } }), jv), Af({ type: 'geo', init(t, e) {
    const i = new tx(e, !0);this._mapDraw = i, this.group.add(i.group);
  }, render(t, e, i, n) {
    if (!n || 'geoToggleSelect' !== n.type || n.from !== this.uid) {
      const o = this._mapDraw;t.get('show') ? o.draw(t, e, i, this, n) : this._mapDraw.group.removeAll(), this.group.silent = t.get('silent');
    }
  }, dispose() {
    this._mapDraw && this._mapDraw.remove();
  } }), QT('toggleSelected', { type: 'geoToggleSelect', event: 'geoselectchanged' }), QT('select', { type: 'geoSelect', event: 'geoselected' }), QT('unSelect', { type: 'geoUnSelect', event: 'geounselected' });function tA(t, e, i) {
    this._model = t;
  } function eA(t, e, i, n) {
    const o = i.calendarModel; const a = i.seriesModel; const r = o ? o.coordinateSystem : a ? a.coordinateSystem : null;return r === this ? r[t](n) : null;
  }tA.prototype = { constructor: tA, type: 'calendar', dimensions: ['time', 'value'], getDimensionsInfo() {
    return [{ name: 'time', type: 'time' }, 'value'];
  }, getRangeInfo() {
    return this._rangeInfo;
  }, getModel() {
    return this._model;
  }, getRect() {
    return this._rect;
  }, getCellWidth() {
    return this._sw;
  }, getCellHeight() {
    return this._sh;
  }, getOrient() {
    return this._orient;
  }, getFirstDayOfWeek() {
    return this._firstDayOfWeek;
  }, getDateInfo(t) {
    const e = (t = Yl(t)).getFullYear(); let i = t.getMonth() + 1;i = i < 10 ? `0${i}` : i;let n = t.getDate();n = n < 10 ? `0${n}` : n;let o = t.getDay();return { y: e, m: i, d: n, day: o = Math.abs((o + 7 - this.getFirstDayOfWeek()) % 7), time: t.getTime(), formatedDate: `${e}-${i}-${n}`, date: t };
  }, getNextNDay(t, e) {
    return 0 === (e = e || 0) || (t = new Date(this.getDateInfo(t).time)).setDate(t.getDate() + e), this.getDateInfo(t);
  }, update(t, e) {
    this._firstDayOfWeek = +this._model.getModel('dayLabel').get('firstDay'), this._orient = this._model.get('orient'), this._lineWidth = this._model.getModel('itemStyle').getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());const i = this._rangeInfo.weeks || 1; const n = ['width', 'height']; const o = this._model.get('cellSize').slice(); const a = this._model.getBoxLayoutParams(); const r = 'horizontal' === this._orient ? [i, 7] : [7, i];R([0, 1], (t) => {
      u(o, t) && (a[n[t]] = o[t] * r[t]);
    });const s = { width: e.getWidth(), height: e.getHeight() }; const l = this._rect = bu(a, s);function u(t, e) {
      return null != t[e] && 'auto' !== t[e];
    }R([0, 1], (t) => {
      u(o, t) || (o[t] = l[n[t]] / r[t]);
    }), this._sw = o[0], this._sh = o[1];
  }, dataToPoint(t, e) {
    L(t) && (t = t[0]), null == e && (e = !0);const i = this.getDateInfo(t); const n = this._rangeInfo; const o = i.formatedDate;if (e && !(i.time >= n.start.time && i.time < n.end.time + 864e5)) return [NaN, NaN];const a = i.day; const r = this._getRangeInfo([n.start.time, o]).nthWeek;return 'vertical' === this._orient ? [this._rect.x + a * this._sw + this._sw / 2, this._rect.y + r * this._sh + this._sh / 2] : [this._rect.x + r * this._sw + this._sw / 2, this._rect.y + a * this._sh + this._sh / 2];
  }, pointToData(t) {
    const e = this.pointToDate(t);return e && e.time;
  }, dataToRect(t, e) {
    const i = this.dataToPoint(t, e);return { contentShape: { x: i[0] - (this._sw - this._lineWidth) / 2, y: i[1] - (this._sh - this._lineWidth) / 2, width: this._sw - this._lineWidth, height: this._sh - this._lineWidth }, center: i, tl: [i[0] - this._sw / 2, i[1] - this._sh / 2], tr: [i[0] + this._sw / 2, i[1] - this._sh / 2], br: [i[0] + this._sw / 2, i[1] + this._sh / 2], bl: [i[0] - this._sw / 2, i[1] + this._sh / 2] };
  }, pointToDate(t) {
    const e = Math.floor((t[0] - this._rect.x) / this._sw) + 1; const i = Math.floor((t[1] - this._rect.y) / this._sh) + 1; const n = this._rangeInfo.range;return 'vertical' === this._orient ? this._getDateByWeeksAndDay(i, e - 1, n) : this._getDateByWeeksAndDay(e, i - 1, n);
  }, convertToPixel: T(eA, 'dataToPoint'), convertFromPixel: T(eA, 'pointToData'), _initRangeOption() {
    let t = this._model.get('range'); let e = t;if (L(e) && 1 === e.length && (e = e[0]), /^\d{4}$/.test(e) && (t = [`${e}-01-01`, `${e}-12-31`]), /^\d{4}[\/|-]\d{1,2}$/.test(e)) {
      const i = this.getDateInfo(e); const n = i.date;n.setMonth(n.getMonth() + 1);const o = this.getNextNDay(n, -1);t = [i.formatedDate, o.formatedDate];
    }/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(e) && (t = [e, e]);const a = this._getRangeInfo(t);return a.start.time > a.end.time && t.reverse(), t;
  }, _getRangeInfo(t) {
    let e;(t = [this.getDateInfo(t[0]), this.getDateInfo(t[1])])[0].time > t[1].time && (e = !0, t.reverse());let i = Math.floor(t[1].time / 864e5) - Math.floor(t[0].time / 864e5) + 1; const n = new Date(t[0].time); const o = n.getDate(); const a = t[1].date.getDate();n.setDate(o + i - 1);let r = n.getDate();if (r !== a) for (let s = 0 < n.getTime() - t[1].time ? 1 : -1;(r = n.getDate()) !== a && 0 < (n.getTime() - t[1].time) * s;)i -= s, n.setDate(r - s);const l = Math.floor((i + t[0].day + 6) / 7); const u = e ? 1 - l : l - 1;return e && t.reverse(), { range: [t[0].formatedDate, t[1].formatedDate], start: t[0], end: t[1], allDay: i, weeks: l, nthWeek: u, fweek: t[0].day, lweek: t[1].day };
  }, _getDateByWeeksAndDay(t, e, i) {
    const n = this._getRangeInfo(i);if (t > n.weeks || 0 === t && e < n.fweek || t === n.weeks && e > n.lweek) return !1;const o = 7 * (t - 1) - n.fweek + e; const a = new Date(n.start.time);return a.setDate(n.start.d + o), this.getDateInfo(a);
  } }, tA.dimensions = tA.prototype.dimensions, tA.getDimensionsInfo = tA.prototype.getDimensionsInfo, tA.create = function (i, n) {
    const o = [];return i.eachComponent('calendar', (t) => {
      const e = new tA(t, i, n);o.push(e), t.coordinateSystem = e;
    }), i.eachSeries((t) => {
      'calendar' === t.get('coordinateSystem') && (t.coordinateSystem = o[t.get('calendarIndex') || 0]);
    }), o;
  }, lh.register('calendar', tA);var iA = ku.extend({ type: 'calendar', coordinateSystem: null, defaultOption: { zlevel: 0, z: 2, left: 80, top: 60, cellSize: 20, orient: 'horizontal', splitLine: { show: !0, lineStyle: { color: '#000', width: 1, type: 'solid' } }, itemStyle: { color: '#fff', borderWidth: 1, borderColor: '#ccc' }, dayLabel: { show: !0, firstDay: 0, position: 'start', margin: '50%', nameMap: 'en', color: '#000' }, monthLabel: { show: !0, position: 'start', margin: 5, align: 'center', nameMap: 'en', formatter: null, color: '#000' }, yearLabel: { show: !0, position: null, margin: 30, formatter: null, color: '#ccc', fontFamily: 'sans-serif', fontWeight: 'bolder', fontSize: 20 } }, init(t, e, i, n) {
    const o = Iu(t);iA.superApply(this, 'init', arguments), nA(t, o);
  }, mergeOption(t, e) {
    iA.superApply(this, 'mergeOption', arguments), nA(this.option, t);
  } });function nA(t, e) {
    let i = t.cellSize;L(i) ? 1 === i.length && (i[1] = i[0]) : i = t.cellSize = [i, i];const n = O([0, 1], t => ((function (t, e) {
      return null != t[xu[e][0]] || null != t[xu[e][1]] && null != t[xu[e][2]];
    }(e, t)) && (i[t] = 'auto'), null != i[t] && 'auto' !== i[t]));Mu(t, e, { type: 'box', ignoreSize: n });
  } const oA = { EN: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], CN: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'] }; const aA = { EN: ['S', 'M', 'T', 'W', 'T', 'F', 'S'], CN: ['日', '一', '二', '三', '四', '五', '六'] };Af({ type: 'calendar', _tlpoints: null, _blpoints: null, _firstDayOfMonth: null, _firstDayPoints: null, render(t, e, i) {
    const n = this.group;n.removeAll();const o = t.coordinateSystem; const a = o.getRangeInfo(); const r = o.getOrient();this._renderDayRect(t, a, n), this._renderLines(t, a, r, n), this._renderYearText(t, a, r, n), this._renderMonthText(t, r, n), this._renderWeekText(t, a, r, n);
  }, _renderDayRect(t, e, i) {
    for (let n = t.coordinateSystem, o = t.getModel('itemStyle').getItemStyle(), a = n.getCellWidth(), r = n.getCellHeight(), s = e.start.time;s <= e.end.time;s = n.getNextNDay(s, 1).time) {
      const l = n.dataToRect([s], !1).tl; const u = new rs({ shape: { x: l[0], y: l[1], width: a, height: r }, cursor: 'default', style: o });i.add(u);
    }
  }, _renderLines(i, t, n, o) {
    const a = this; const r = i.coordinateSystem; const s = i.getModel('splitLine.lineStyle').getLineStyle(); const l = i.get('splitLine.show'); const e = s.lineWidth;this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];for (let u = t.start, h = 0;u.time <= t.end.time;h++) {
      d(u.formatedDate), 0 === h && (u = r.getDateInfo(`${t.start.y}-${t.start.m}`));const c = u.date;c.setMonth(c.getMonth() + 1), u = r.getDateInfo(c);
    } function d(t) {
      a._firstDayOfMonth.push(r.getDateInfo(t)), a._firstDayPoints.push(r.dataToRect([t], !1).tl);const e = a._getLinePointsOfOneWeek(i, t, n);a._tlpoints.push(e[0]), a._blpoints.push(e[e.length - 1]), l && a._drawSplitline(e, s, o);
    }d(r.getNextNDay(t.end.time, 1).formatedDate), l && this._drawSplitline(a._getEdgesPoints(a._tlpoints, e, n), s, o), l && this._drawSplitline(a._getEdgesPoints(a._blpoints, e, n), s, o);
  }, _getEdgesPoints(t, e, i) {
    const n = [t[0].slice(), t[t.length - 1].slice()]; const o = 'horizontal' === i ? 0 : 1;return n[0][o] = n[0][o] - e / 2, n[1][o] = n[1][o] + e / 2, n;
  }, _drawSplitline(t, e, i) {
    const n = new ts({ z2: 20, shape: { points: t }, style: e });i.add(n);
  }, _getLinePointsOfOneWeek(t, e, i) {
    const n = t.coordinateSystem;e = n.getDateInfo(e);for (var o = [], a = 0;a < 7;a++) {
      const r = n.getNextNDay(e.time, a); const s = n.dataToRect([r.time], !1);o[2 * r.day] = s.tl, o[2 * r.day + 1] = s['horizontal' === i ? 'bl' : 'tr'];
    } return o;
  }, _formatterLabel(t, e) {
    return 'string' === typeof t && t ? uu(t, e) : 'function' === typeof t ? t(e) : e.nameMap;
  }, _yearTextPositionControl(t, e, i, n, o) {
    e = e.slice();let a = ['center', 'bottom'];'bottom' === n ? (e[1] += o, a = ['center', 'top']) : 'left' === n ? e[0] -= o : 'right' === n ? (e[0] += o, a = ['center', 'top']) : e[1] -= o;let r = 0;return 'left' !== n && 'right' !== n || (r = Math.PI / 2), { rotation: r, position: e, style: { textAlign: a[0], textVerticalAlign: a[1] } };
  }, _renderYearText(t, e, i, n) {
    const o = t.getModel('yearLabel');if (o.get('show')) {
      const a = o.get('margin'); let r = o.get('position');r = r || ('horizontal' !== i ? 'top' : 'left');const s = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]]; const l = (s[0][0] + s[1][0]) / 2; const u = (s[0][1] + s[1][1]) / 2; const h = 'horizontal' === i ? 0 : 1; const c = { top: [l, s[h][1]], bottom: [l, s[1 - h][1]], left: [s[1 - h][0], u], right: [s[h][0], u] }; let d = e.start.y;+e.end.y > +e.start.y && (d = `${d}-${e.end.y}`);const f = o.get('formatter'); const p = { start: e.start.y, end: e.end.y, nameMap: d }; const g = this._formatterLabel(f, p); const m = new Ur({ z2: 30 });nl(m.style, o, { text: g }), m.attr(this._yearTextPositionControl(m, c[r], i, r, a)), n.add(m);
    }
  }, _monthTextPositionControl(t, e, i, n, o) {
    let a = 'left'; let r = 'top'; let s = t[0]; let l = t[1];return 'horizontal' === i ? (l += o, e && (a = 'center'), 'start' === n && (r = 'bottom')) : (s += o, e && (r = 'middle'), 'start' === n && (a = 'right')), { x: s, y: l, textAlign: a, textVerticalAlign: r };
  }, _renderMonthText(t, e, i) {
    const n = t.getModel('monthLabel');if (n.get('show')) {
      let o = n.get('nameMap'); let a = n.get('margin'); const r = n.get('position'); const s = n.get('align'); const l = [this._tlpoints, this._blpoints];E(o) && (o = oA[o.toUpperCase()] || []);const u = 'start' === r ? 0 : 1; const h = 'horizontal' === e ? 0 : 1;a = 'start' === r ? -a : a;for (let c = 'center' === s, d = 0;d < l[u].length - 1;d++) {
        const f = l[u][d].slice(); const p = this._firstDayOfMonth[d];if (c) {
          const g = this._firstDayPoints[d];f[h] = (g[h] + l[0][d + 1][h]) / 2;
        } const m = n.get('formatter'); const v = o[+p.m - 1]; const y = { yyyy: p.y, yy: (`${p.y}`).slice(2), MM: p.m, M: +p.m, nameMap: v }; const x = this._formatterLabel(m, y); const _ = new Ur({ z2: 30 });P(nl(_.style, n, { text: x }), this._monthTextPositionControl(f, c, e, r, a)), i.add(_);
      }
    }
  }, _weekTextPositionControl(t, e, i, n, o) {
    let a = 'center'; let r = 'middle'; let s = t[0]; let l = t[1]; const u = 'start' === i;return 'horizontal' === e ? (s = s + n + (u ? 1 : -1) * o[0] / 2, a = u ? 'right' : 'left') : (l = l + n + (u ? 1 : -1) * o[1] / 2, r = u ? 'bottom' : 'top'), { x: s, y: l, textAlign: a, textVerticalAlign: r };
  }, _renderWeekText(t, e, i, n) {
    const o = t.getModel('dayLabel');if (o.get('show')) {
      const a = t.coordinateSystem; const r = o.get('position'); let s = o.get('nameMap'); let l = o.get('margin'); const u = a.getFirstDayOfWeek();E(s) && (s = aA[s.toUpperCase()] || []);let h = a.getNextNDay(e.end.time, 7 - e.lweek).time; const c = [a.getCellWidth(), a.getCellHeight()];l = El(l, c['horizontal' === i ? 0 : 1]), 'start' === r && (h = a.getNextNDay(e.start.time, -(7 + e.fweek)).time, l = -l);for (let d = 0;d < 7;d++) {
        var f; const p = a.getNextNDay(h, d); const g = a.dataToRect([p.time], !1).center;f = Math.abs((d + u) % 7);const m = new Ur({ z2: 30 });P(nl(m.style, o, { text: s[f] }), this._weekTextPositionControl(g, i, r, l, c)), n.add(m);
      }
    }
  } });const rA = { path: null, compoundPath: null, group: Ci, image: Qn, text: Ur };yf((t) => {
    const e = t.graphic;L(e) ? e[0] && e[0].elements ? t.graphic = [t.graphic[0]] : t.graphic = [{ elements: e }] : e && !e.elements && (t.graphic = [{ elements: [e] }]);
  });var sA = Tf({ type: 'graphic', defaultOption: { elements: [], parentId: null }, _elOptionsToUpdate: null, mergeOption(t) {
    const e = this.option.elements;this.option.elements = null, sA.superApply(this, 'mergeOption', arguments), this.option.elements = e;
  }, optionUpdated(t, e) {
    const i = this.option; const n = (e ? i : t).elements; const o = i.elements = e ? [] : i.elements; const a = [];this._flatten(n, a);const r = Ho(o, a);Zo(r);const s = this._elOptionsToUpdate = [];R(r, (t, e) => {
      const i = t.option;i && (s.push(i), (function (t, e) {
        const i = t.exist;if (e.id = t.keyInfo.id, !e.type && i && (e.type = i.type), null == e.parentId) {
          const n = e.parentOption;n ? e.parentId = n.id : i && (e.parentId = i.parentId);
        }e.parentOption = null;
      }(t, i)), (function (t, e, i) {
        const n = P({}, i); const o = t[e]; const a = i.$action || 'merge';'merge' === a ? o ? (m(o, n, !0), Mu(o, n, { ignoreSize: !0 }), Tu(i, o)) : t[e] = n : 'replace' === a ? t[e] = n : 'remove' === a && o && (t[e] = null);
      }(o, e, i)), (function (t, e) {
        if (!t) return;t.hv = e.hv = [hA(e, ['left', 'right']), hA(e, ['top', 'bottom'])], 'group' === t.type && (null == t.width && (t.width = e.width = 0), null == t.height && (t.height = e.height = 0));
      }(o[e], i)));
    }, this);for (let l = o.length - 1;0 <= l;l--)null == o[l] ? o.splice(l, 1) : delete o[l].$action;
  }, _flatten(t, i, n) {
    R(t, function (t) {
      if (t) {
        n && (t.parentOption = n), i.push(t);const e = t.children;'group' === t.type && e && this._flatten(e, i, t), delete t.children;
      }
    }, this);
  }, useElOptionsToUpdate() {
    const t = this._elOptionsToUpdate;return this._elOptionsToUpdate = null, t;
  } });function lA(t, e, i, n) {
    const o = i.type; const a = new(rA.hasOwnProperty(o) ? rA[o] : ks(o))(i);e.add(a), n.set(t, a), a.__ecGraphicId = t;
  } function uA(t, e) {
    const i = t && t.parent;i && ('group' === t.type && t.traverse((t) => {
      uA(t, e);
    }), e.removeKey(t.__ecGraphicId), i.remove(t));
  } function hA(e, t) {
    let i;return R(t, (t) => {
      null != e[t] && 'auto' !== e[t] && (i = !0);
    }), i;
  }Af({ type: 'graphic', init(t, e) {
    this._elMap = Q(), this._lastGraphicModel;
  }, render(t, e, i) {
    t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, i);
  }, _updateElements(u) {
    const t = u.useElOptionsToUpdate();if (t) {
      const h = this._elMap; const c = this.group;R(t, (t) => {
        const e = t.$action; const i = t.id; const n = h.get(i); const o = t.parentId; const a = null != o ? h.get(o) : c; const r = t.style;'text' === t.type && r && (t.hv && t.hv[1] && (r.textVerticalAlign = r.textBaseline = null), !r.hasOwnProperty('textFill') && r.fill && (r.textFill = r.fill), !r.hasOwnProperty('textStroke') && r.stroke && (r.textStroke = r.stroke));const s = (function (e) {
          return e = P({}, e), R(['id', 'parentId', '$action', 'hv', 'bounding'].concat(yu), (t) => {
            delete e[t];
          }), e;
        }(t));e && 'merge' !== e ? 'replace' === e ? (uA(n, h), lA(i, a, s, h)) : 'remove' === e && uA(n, h) : n ? n.attr(s) : lA(i, a, s, h);const l = h.get(i);l && (l.__ecGraphicWidthOption = t.width, l.__ecGraphicHeightOption = t.height, (function (t, e) {
          let i = t.eventData;t.silent || t.ignore || i || (i = t.eventData = { componentType: 'graphic', componentIndex: e.componentIndex, name: t.name });i && (i.info = t.info);
        }(l, u)));
      });
    }
  }, _relocate(t, e) {
    for (var i = t.option.elements, n = this.group, o = this._elMap, a = e.getWidth(), r = e.getHeight(), s = 0;s < i.length;s++) {
      var l = i[s];if ((h = o.get(l.id)) && h.isGroup) {
        const u = (c = h.parent) === n;h.__ecGraphicWidth = El(h.__ecGraphicWidthOption, u ? a : c.__ecGraphicWidth) || 0, h.__ecGraphicHeight = El(h.__ecGraphicHeightOption, u ? r : c.__ecGraphicHeight) || 0;
      }
    } for (s = i.length - 1;0 <= s;s--) {
      var h; var c;l = i[s];if (h = o.get(l.id))Su(h, l, (c = h.parent) === n ? { width: a, height: r } : { width: c.__ecGraphicWidth, height: c.__ecGraphicHeight }, null, { hv: l.hv, boundingMode: l.bounding });
    }
  }, _clear() {
    const e = this._elMap;e.each((t) => {
      uA(t, e);
    }), this._elMap = Q();
  }, dispose() {
    this._clear();
  } });const cA = {};function dA(t, e) {
    cA[t] = e;
  } function fA(t) {
    return cA[t];
  } var pA = Tf({ type: 'toolbox', layoutMode: { type: 'box', ignoreSize: !0 }, optionUpdated() {
    pA.superApply(this, 'optionUpdated', arguments), R(this.option.feature, (t, e) => {
      const i = fA(e);i && m(t, i.defaultOption);
    });
  }, defaultOption: { show: !0, z: 6, zlevel: 0, orient: 'horizontal', left: 'right', top: 'top', backgroundColor: 'transparent', borderColor: '#ccc', borderRadius: 0, borderWidth: 0, padding: 5, itemSize: 15, itemGap: 8, showTitle: !0, iconStyle: { borderColor: '#666', color: 'none' }, emphasis: { iconStyle: { borderColor: '#3E98C5' } }, tooltip: { show: !1 } } });function gA(t, e) {
    const i = iu(e.get('padding')); const n = e.getItemStyle(['color', 'opacity']);return n.fill = e.get('backgroundColor'), t = new rs({ shape: { x: t.x - i[3], y: t.y - i[0], width: t.width + i[1] + i[3], height: t.height + i[0] + i[2], r: e.get('borderRadius') }, style: n, silent: !0, z2: -1 });
  }Af({ type: 'toolbox', render(h, c, d, l) {
    const f = this.group;if (f.removeAll(), h.get('show')) {
      var p = +h.get('itemSize'); var u = h.get('feature') || {}; var g = this._features || (this._features = {}); var m = [];R(u, (t, e) => {
        m.push(e);
      }), new kf(this._featureNames || [], m).add(t)
        .update(t)
        .remove(T(t, null))
        .execute(), this._featureNames = m, (function (t, e, i) {
        const n = e.getBoxLayoutParams(); const o = e.get('padding'); const a = { width: i.getWidth(), height: i.getHeight() }; const r = bu(n, a, o);wu(e.get('orient'), t, e.get('itemGap'), r.width, r.height), Su(t, n, a, o);
      }(f, h, d)), f.add(gA(f.getBoundingRect(), h)), f.eachChild((t) => {
        const e = t.__title; const i = t.hoverStyle;if (i && e) {
          const n = gn(e, An(i)); const o = t.position[0] + f.position[0]; let a = !1;t.position[1] + f.position[1] + p + n.height > d.getHeight() && (i.textPosition = 'top', a = !0);const r = a ? -5 - n.height : p + 8;o + n.width / 2 > d.getWidth() ? (i.textPosition = ['100%', r], i.textAlign = 'right') : o - n.width / 2 < 0 && (i.textPosition = [0, r], i.textAlign = 'left');
        }
      });
    } function t(t, e) {
      let i; const n = m[t]; const o = m[e]; const a = u[n]; const r = new Cl(a, h, h.ecModel);if (l && null != l.newTitle && l.featureName === n && (a.title = l.newTitle), n && !o) {
        if (function (t) {
          return 0 === t.indexOf('my');
        }(n))i = { model: r, onclick: r.option.onclick, featureName: n };else {
          const s = fA(n);if (!s) return;i = new s(r, c, d);
        }g[n] = i;
      } else {
        if (!(i = g[o])) return;i.model = r, i.ecModel = c, i.api = d;
      }n || !o ? r.get('show') && !i.unusable ? ((function (o, a, t) {
        const r = o.getModel('iconStyle'); const s = o.getModel('emphasis.iconStyle'); let e = a.getIcons ? a.getIcons() : o.get('icon'); let l = o.get('title') || {};if ('string' === typeof e) {
          const i = e; const n = l;l = {}, (e = {})[t] = i, l[t] = n;
        } const u = o.iconPaths = {};R(e, (t, e) => {
          const i = yl(t, {}, { x: -p / 2, y: -p / 2, width: p, height: p });i.setStyle(r.getItemStyle()), i.hoverStyle = s.getItemStyle(), i.setStyle({ text: l[e], textAlign: s.get('textAlign'), textBorderRadius: s.get('textBorderRadius'), textPadding: s.get('textPadding'), textFill: null });const n = h.getModel('tooltip');n && n.get('show') && i.attr('tooltip', P({ content: l[e], formatter: n.get('formatter', !0) || function () {
            return l[e];
          }, formatterParams: { componentType: 'toolbox', name: e, title: l[e], $vars: ['name', 'title'] }, position: n.get('position', !0) || 'bottom' }, n.option)), $s(i), h.get('showTitle') && (i.__title = l[e], i.on('mouseover', () => {
            const t = s.getItemStyle(); const e = 'vertical' === h.get('orient') ? null == h.get('right') ? 'right' : 'left' : null == h.get('bottom') ? 'bottom' : 'top';i.setStyle({ textFill: s.get('textFill') || t.fill || t.stroke || '#000', textBackgroundColor: s.get('textBackgroundColor'), textPosition: s.get('textPosition') || e });
          }).on('mouseout', () => {
            i.setStyle({ textFill: null, textBackgroundColor: null });
          })), i.trigger(o.get(`iconStatus.${e}`) || 'normal'), f.add(i), i.on('click', A(a.onclick, a, c, d, e)), u[e] = i;
        });
      }(r, i, n)), r.setIconStatus = function (t, e) {
        const i = this.option; const n = this.iconPaths;i.iconStatus = i.iconStatus || {}, i.iconStatus[t] = e, n[t] && n[t].trigger(e);
      }, i.render && i.render(r, c, d, l)) : i.remove && i.remove(c, d) : i.dispose && i.dispose(c, d);
    }
  }, updateView(t, e, i, n) {
    R(this._features, (t) => {
      t.updateView && t.updateView(t.model, e, i, n);
    });
  }, remove(e, i) {
    R(this._features, (t) => {
      t.remove && t.remove(e, i);
    }), this.group.removeAll();
  }, dispose(e, i) {
    R(this._features, (t) => {
      t.dispose && t.dispose(e, i);
    });
  } });const mA = Oc.toolbox.saveAsImage;function vA(t) {
    this.model = t;
  }vA.defaultOption = { show: !0, icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0', title: mA.title, type: 'png', connectedBackgroundColor: '#fff', name: '', excludeComponents: ['toolbox'], pixelRatio: 1, lang: mA.lang.slice() }, vA.prototype.unusable = !v.canvasSupported, vA.prototype.onclick = function (t, e) {
    const i = this.model; const n = i.get('name') || t.get('title.0.text') || 'echarts'; const o = 'svg' === e.getZr().painter.getType() ? 'svg' : i.get('type', !0) || 'png'; const a = e.getConnectedDataURL({ type: o, backgroundColor: i.get('backgroundColor', !0) || t.get('backgroundColor') || '#fff', connectedBackgroundColor: i.get('connectedBackgroundColor'), excludeComponents: i.get('excludeComponents'), pixelRatio: i.get('pixelRatio') });if ('function' !== typeof MouseEvent || v.browser.ie || v.browser.edge) if (window.navigator.msSaveOrOpenBlob) {
      for (var r = atob(a.split(',')[1]), s = r.length, l = new Uint8Array(s);s--;)l[s] = r.charCodeAt(s);const u = new Blob([l]);window.navigator.msSaveOrOpenBlob(u, `${n}.${o}`);
    } else {
      const h = i.get('lang'); const c = `<body style="margin:0;"><img src="${a}" style="max-width:100%;" title="${h && h[0] || ''}" /></body>`;window.open().document.write(c);
    } else {
      const d = document.createElement('a');d.download = `${n}.${o}`, d.target = '_blank', d.href = a;const f = new MouseEvent('click', { view: document.defaultView, bubbles: !0, cancelable: !1 });d.dispatchEvent(f);
    }
  }, dA('saveAsImage', vA);const yA = Oc.toolbox.magicType; const xA = '__ec_magicType_stack__';function _A(t) {
    this.model = t;
  }_A.defaultOption = { show: !0, type: [], icon: { line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4', bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7', stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z' }, title: k(yA.title), option: {}, seriesIndex: {} };const wA = _A.prototype;wA.getIcons = function () {
    const t = this.model; const e = t.get('icon'); const i = {};return R(t.get('type'), (t) => {
      e[t] && (i[t] = e[t]);
    }), i;
  };const bA = { line(t, e, i, n) {
    if ('bar' === t) return m({ id: e, type: 'line', data: i.get('data'), stack: i.get('stack'), markPoint: i.get('markPoint'), markLine: i.get('markLine') }, n.get('option.line') || {}, !0);
  }, bar(t, e, i, n) {
    if ('line' === t) return m({ id: e, type: 'bar', data: i.get('data'), stack: i.get('stack'), markPoint: i.get('markPoint'), markLine: i.get('markLine') }, n.get('option.bar') || {}, !0);
  }, stack(t, e, i, n) {
    const o = i.get('stack') === xA;if ('line' === t || 'bar' === t) return n.setIconStatus('stack', o ? 'normal' : 'emphasis'), m({ id: e, stack: o ? '' : xA }, n.get('option.stack') || {}, !0);
  } }; const SA = [['line', 'bar'], ['stack']];wA.onclick = function (u, t, h) {
    const c = this.model; const e = c.get(`seriesIndex.${h}`);if (bA[h]) {
      let i; const d = { series: [] };if (R(SA, (t) => {
        0 <= _(t, h) && R(t, (t) => {
          c.setIconStatus(t, 'normal');
        });
      }), c.setIconStatus(h, 'emphasis'), u.eachComponent({ mainType: 'series', query: null == e ? null : { seriesIndex: e } }, (t) => {
        const e = t.subType; const i = t.id; const n = bA[h](e, i, t, c);n && (D(n, t.option), d.series.push(n));const o = t.coordinateSystem;if (o && 'cartesian2d' === o.type && ('line' === h || 'bar' === h)) {
          const a = o.getAxesByScale('ordinal')[0];if (a) {
            const r = `${a.dim}Axis`; const s = u.queryComponents({ mainType: r, index: t.get(`${name}Index`), id: t.get(`${name}Id`) })[0].componentIndex;d[r] = d[r] || [];for (let l = 0;l <= s;l++)d[r][s] = d[r][s] || {};d[r][s].boundaryGap = 'bar' === h;
          }
        }
      }), 'stack' === h)i = d.series && d.series[0] && d.series[0].stack === xA ? m({ stack: yA.title.tiled }, yA.title) : k(yA.title);t.dispatchAction({ type: 'changeMagicType', currentType: h, newOption: d, newTitle: i, featureName: 'magicType' });
    }
  }, _f({ type: 'changeMagicType', event: 'magicTypeChanged', update: 'prepareAndUpdate' }, (t, e) => {
    e.mergeOption(t.newOption);
  }), dA('magicType', _A);const MA = Oc.toolbox.dataView; const IA = new Array(60).join('-'); const TA = '\t';function AA(t) {
    const e = (function (t) {
      const o = {}; const a = []; const r = [];return t.eachRawSeries((t) => {
        const e = t.coordinateSystem;if (!e || 'cartesian2d' !== e.type && 'polar' !== e.type)a.push(t);else {
          const i = e.getBaseAxis();if ('category' === i.type) {
            const n = `${i.dim}_${i.index}`;o[n] || (o[n] = { categoryAxis: i, valueAxis: e.getOtherAxis(i), series: [] }, r.push({ axisDim: i.dim, axisIndex: i.index })), o[n].series.push(t);
          } else a.push(t);
        }
      }), { seriesGroupByCategoryAxis: o, other: a, meta: r };
    }(t));return { value: M([(function (t) {
      const h = [];return R(t, (t, e) => {
        const i = t.categoryAxis; const n = t.valueAxis.dim; const o = [' '].concat(O(t.series, t => t.name)); const a = [i.model.getCategories()];R(t.series, (t) => {
          const e = t.getRawData();a.push(t.getRawData().mapArray(e.mapDimension(n), t => t));
        });for (var r = [o.join(TA)], s = 0;s < a[0].length;s++) {
          for (var l = [], u = 0;u < a.length;u++)l.push(a[u][s]);r.push(l.join(TA));
        }h.push(r.join('\n'));
      }), h.join(`\n\n${IA}\n\n`);
    }(e.seriesGroupByCategoryAxis)), (function (t) {
      return O(t, (t) => {
        const o = t.getRawData(); const a = [t.name]; const r = [];return o.each(o.dimensions, function () {
          for (var t = arguments.length, e = arguments[t - 1], i = o.getName(e), n = 0;n < t - 1;n++)r[n] = arguments[n];a.push((i ? i + TA : '') + r.join(TA));
        }), a.join('\n');
      }).join(`\n\n${IA}\n\n`);
    }(e.other))], t => t.replace(/[\n\t\s]/g, '')).join(`\n\n${IA}\n\n`), meta: e.meta };
  } function DA(t) {
    return t.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  } const CA = new RegExp(`[${TA}]+`, 'g');function LA(t, a) {
    const e = t.split(new RegExp(`\n*${IA}\n*`, 'g')); const r = { series: [] };return R(e, (t, e) => {
      if (function (t) {
        if (0 <= t.slice(0, t.indexOf('\n')).indexOf(TA)) return !0;
      }(t)) {
        var i = (function (t) {
          for (var e = t.split(/\n+/g), i = [], n = O(DA(e.shift()).split(CA), t => ({ name: t, data: [] })), o = 0;o < e.length;o++) {
            const a = DA(e[o]).split(CA);i.push(a.shift());for (let r = 0;r < a.length;r++)n[r] && (n[r].data[o] = a[r]);
          } return { series: n, categories: i };
        }(t)); const n = a[e]; const o = `${n.axisDim}Axis`;n && (r[o] = r[o] || [], r[o][n.axisIndex] = { data: i.categories }, r.series = r.series.concat(i.series));
      } else {
        i = (function (t) {
          for (var e = t.split(/\n+/g), i = DA(e.shift()), n = [], o = 0;o < e.length;o++) {
            const a = DA(e[o]);if (a) {
              var r; let s = a.split(CA); let l = ''; let u = !1;r = isNaN(s[0]) ? (u = !0, l = s[0], s = s.slice(1), n[o] = { name: l, value: [] }, n[o].value) : n[o] = [];for (let h = 0;h < s.length;h++)r.push(+s[h]);1 === r.length && (u ? n[o].value = r[0] : n[o] = r[0]);
            }
          } return { name: i, data: n };
        }(t));r.series.push(i);
      }
    }), r;
  } function kA(t) {
    this._dom = null, this.model = t;
  }kA.defaultOption = { show: !0, readOnly: !1, optionToContent: null, contentToOption: null, icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28', title: k(MA.title), lang: k(MA.lang), backgroundColor: '#fff', textColor: '#000', textareaColor: '#fff', textareaBorderColor: '#333', buttonColor: '#c23531', buttonTextColor: '#fff' }, kA.prototype.onclick = function (t, e) {
    const i = e.getDom(); const n = this.model;this._dom && i.removeChild(this._dom);const o = document.createElement('div');o.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;', o.style.backgroundColor = n.get('backgroundColor') || '#fff';const a = document.createElement('h4'); const r = n.get('lang') || [];a.innerHTML = r[0] || n.get('title'), a.style.cssText = 'margin: 10px 20px;', a.style.color = n.get('textColor');const s = document.createElement('div'); const l = document.createElement('textarea');s.style.cssText = 'display:block;width:100%;overflow:auto;';const u = n.get('optionToContent'); const h = n.get('contentToOption'); const c = AA(t);if ('function' === typeof u) {
      const d = u(e.getOption());'string' === typeof d ? s.innerHTML = d : G(d) && s.appendChild(d);
    } else s.appendChild(l), l.readOnly = n.get('readOnly'), l.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;', l.style.color = n.get('textColor'), l.style.borderColor = n.get('textareaBorderColor'), l.style.backgroundColor = n.get('textareaColor'), l.value = c.value;const f = c.meta; const p = document.createElement('div');p.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';let g = 'float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px'; const m = document.createElement('div'); const v = document.createElement('div');g += `;background-color:${n.get('buttonColor')}`, g += `;color:${n.get('buttonTextColor')}`;const y = this;function x() {
      i.removeChild(o), y._dom = null;
    }Ut(m, 'click', x), Ut(v, 'click', () => {
      let t;try {
        t = 'function' === typeof h ? h(s, e.getOption()) : LA(l.value, f);
      } catch (t) {
        throw x(), new Error(`Data view format error ${t}`);
      }t && e.dispatchAction({ type: 'changeDataView', newOption: t }), x();
    }), m.innerHTML = r[1], v.innerHTML = r[2], v.style.cssText = g, m.style.cssText = g, n.get('readOnly') || p.appendChild(v), p.appendChild(m), o.appendChild(a), o.appendChild(s), o.appendChild(p), s.style.height = `${i.clientHeight - 80}px`, i.appendChild(o), this._dom = o;
  }, kA.prototype.remove = function (t, e) {
    this._dom && e.getDom().removeChild(this._dom);
  }, kA.prototype.dispose = function (t, e) {
    this.remove(t, e);
  }, dA('dataView', kA), _f({ type: 'changeDataView', event: 'dataViewChanged', update: 'prepareAndUpdate' }, (t, n) => {
    const o = [];R(t.newOption.series, (t) => {
      const e = n.getSeriesByName(t.name)[0];if (e) {
        const i = e.get('data');o.push({ name: t.name, data: (function (t, o) {
          return O(t, (t, e) => {
            const i = o && o[e];if (!z(i) || L(i)) return t;z(t) && !L(t) || (t = { value: t });const n = null != i.name && null == t.name;return t = D(t, i), n && delete t.name, t;
          });
        }(t.data, i)) });
      } else o.push(P({ type: 'scatter' }, t));
    }), n.mergeOption(D({ series: o }, t.newOption));
  });const PA = R; const NA = _; const OA = T; const RA = ['dataToPoint', 'pointToData']; const EA = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];function zA(t, e, i) {
    const n = this._targetInfoList = []; const o = {}; const a = GA(e, t);PA(FA, (t, e) => {
      i && i.include && !(0 <= NA(i.include, e)) || t(a, n, o);
    });
  } const BA = zA.prototype;function VA(t) {
    return t[0] > t[1] && t.reverse(), t;
  } function GA(t, e) {
    return Ko(t, e, { includeMainTypes: EA });
  }BA.setOutputRanges = function (t, e) {
    this.matchOutputRanges(t, e, (t, e, i) => {
      if ((t.coordRanges || (t.coordRanges = [])).push(e), !t.coordRange) {
        t.coordRange = e;const n = ZA[t.brushType](0, i, e);t.__rangeOffset = { offset: XA[t.brushType](n.values, t.range, [1, 1]), xyMinMax: n.xyMinMax };
      }
    });
  }, BA.matchOutputRanges = function (t, n, o) {
    PA(t, function (i) {
      const t = this.findTargetInfo(i, n);t && !0 !== t && R(t.coordSyses, (t) => {
        const e = ZA[i.brushType](1, t, i.range);o(i, e.values, t, n);
      });
    }, this);
  }, BA.setInputRanges = function (t, o) {
    PA(t, function (t) {
      const e = this.findTargetInfo(t, o);if (t.range = t.range || [], e && !0 !== e) {
        t.panelId = e.panelId;const i = ZA[t.brushType](0, e.coordSys, t.coordRange); const n = t.__rangeOffset;t.range = n ? XA[t.brushType](i.values, n.offset, (function (t, e) {
          const i = jA(t); const n = jA(e); const o = [i[0] / n[0], i[1] / n[1]];return isNaN(o[0]) && (o[0] = 1), isNaN(o[1]) && (o[1] = 1), o;
        }(i.xyMinMax, n.xyMinMax))) : i.values;
      }
    }, this);
  }, BA.makePanelOpts = function (i, n) {
    return O(this._targetInfoList, (t) => {
      const e = t.getPanelRect();return { panelId: t.panelId, defaultBrushType: n && n(t), clipPath: hS(e), isTargetByCursor: dS(e, i, t.coordSysModel), getLinearBrushOtherExtent: cS(e) };
    });
  }, BA.controlSeries = function (t, e, i) {
    const n = this.findTargetInfo(t, i);return !0 === n || n && 0 <= NA(n.coordSyses, e.coordinateSystem);
  }, BA.findTargetInfo = function (t, e) {
    for (let i = this._targetInfoList, n = GA(e, t), o = 0;o < i.length;o++) {
      const a = i[o]; const r = t.panelId;if (r) {
        if (a.panelId === r) return a;
      } else for (o = 0;o < WA.length;o++) if (WA[o](n, a)) return a;
    } return !0;
  };var FA = { grid(t, n) {
    const o = t.xAxisModels; const a = t.yAxisModels; const e = t.gridModels; const i = Q(); const r = {}; const s = {};(o || a || e) && (PA(o, (t) => {
      const e = t.axis.grid.model;i.set(e.id, e), r[e.id] = !0;
    }), PA(a, (t) => {
      const e = t.axis.grid.model;i.set(e.id, e), s[e.id] = !0;
    }), PA(e, (t) => {
      i.set(t.id, t), r[t.id] = !0, s[t.id] = !0;
    }), i.each((t) => {
      const e = t.coordinateSystem; const i = [];PA(e.getCartesians(), (t, e) => {
        (0 <= NA(o, t.getAxis('x').model) || 0 <= NA(a, t.getAxis('y').model)) && i.push(t);
      }), n.push({ panelId: `grid--${t.id}`, gridModel: t, coordSysModel: t, coordSys: i[0], coordSyses: i, getPanelRect: HA.grid, xAxisDeclared: r[t.id], yAxisDeclared: s[t.id] });
    }));
  }, geo(t, i) {
    PA(t.geoModels, (t) => {
      const e = t.coordinateSystem;i.push({ panelId: `geo--${t.id}`, geoModel: t, coordSysModel: t, coordSys: e, coordSyses: [e], getPanelRect: HA.geo });
    });
  } }; var WA = [function (t, e) {
    const i = t.xAxisModel; const n = t.yAxisModel; let o = t.gridModel;return !o && i && (o = i.axis.grid.model), !o && n && (o = n.axis.grid.model), o && o === e.gridModel;
  }, function (t, e) {
    const i = t.geoModel;return i && i === e.geoModel;
  }]; var HA = { grid() {
    return this.coordSys.grid.getRect().clone();
  }, geo() {
    const t = this.coordSys; const e = t.getBoundingRect().clone();return e.applyTransform(fl(t)), e;
  } }; var ZA = { lineX: OA(UA, 0), lineY: OA(UA, 1), rect(t, e, i) {
    const n = e[RA[t]]([i[0][0], i[1][0]]); const o = e[RA[t]]([i[0][1], i[1][1]]); const a = [VA([n[0], o[0]]), VA([n[1], o[1]])];return { values: a, xyMinMax: a };
  }, polygon(i, n, t) {
    const o = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];return { values: O(t, (t) => {
      const e = n[RA[i]](t);return o[0][0] = Math.min(o[0][0], e[0]), o[1][0] = Math.min(o[1][0], e[1]), o[0][1] = Math.max(o[0][1], e[0]), o[1][1] = Math.max(o[1][1], e[1]), e;
    }), xyMinMax: o };
  } };function UA(t, e, i, n) {
    const o = i.getAxis(['x', 'y'][t]); const a = VA(O([0, 1], t => (e ? o.coordToData(o.toLocalCoord(n[t])) : o.toGlobalCoord(o.dataToCoord(n[t]))))); const r = [];return r[t] = a, r[1 - t] = [NaN, NaN], { values: a, xyMinMax: r };
  } var XA = { lineX: OA(YA, 0), lineY: OA(YA, 1), rect(t, e, i) {
    return [[t[0][0] - i[0] * e[0][0], t[0][1] - i[0] * e[0][1]], [t[1][0] - i[1] * e[1][0], t[1][1] - i[1] * e[1][1]]];
  }, polygon(t, i, n) {
    return O(t, (t, e) => [t[0] - n[0] * i[e][0], t[1] - n[1] * i[e][1]]);
  } };function YA(t, e, i, n) {
    return [e[0] - n[t] * i[0], e[1] - n[t] * i[1]];
  } function jA(t) {
    return t ? [t[0][1] - t[0][0], t[1][1] - t[1][0]] : [NaN, NaN];
  } const qA = R; const KA = '\0_ec_hist_store';function $A(t) {
    let e = t[KA];return e = e || (t[KA] = [{}]);
  }ku.registerSubTypeDefaulter('dataZoom', () => 'slider');const JA = ['cartesian2d', 'polar', 'singleAxis'];let QA; let tD; let eD; let iD; const nD = (tD = ['axisIndex', 'axis', 'index', 'id'], eD = O(QA = (QA = ['x', 'y', 'z', 'radius', 'angle', 'single']).slice(), fu), iD = O(tD = (tD || []).slice(), fu), function (o, a) {
    R(QA, (t, e) => {
      for (var i = { name: t, capital: eD[e] }, n = 0;n < tD.length;n++)i[tD[n]] = t + iD[n];o.call(a, i);
    });
  });function oD(o, a, r) {
    return function (t) {
      let e; const i = { nodes: [], records: {} };if (a((t) => {
        i.records[t.name] = {};
      }), !t) return i;for (s(t, i);e = !1, o(n), e;);function n(t) {
        !(function (t, e) {
          return 0 <= _(e.nodes, t);
        }(t, i)) && (function (t, i) {
          let n = !1;return a((e) => {
            R(r(t, e) || [], (t) => {
              i.records[e.name][t] && (n = !0);
            });
          }), n;
        }(t, i)) && (s(t, i), e = !0);
      } return i;
    };function s(t, i) {
      i.nodes.push(t), a((e) => {
        R(r(t, e) || [], (t) => {
          i.records[e.name][t] = !0;
        });
      });
    }
  } function aD(t, e, i, n) {
    this._dimName = t, this._axisIndex = e, this._valueWindow, this._percentWindow, this._dataExtent, this._minMaxSpan, this.ecModel = n, this._dataZoomModel = i;
  } const rD = R; const sD = Bl;function lD(t, e) {
    const i = t.getAxisModel(); const n = t._percentWindow; const o = t._valueWindow;if (n) {
      let a = Fl(o, [0, 500]);a = Math.min(a, 20);const r = e || 0 === n[0] && 100 === n[1];i.setRange(r ? null : +o[0].toFixed(a), r ? null : +o[1].toFixed(a));
    }
  }aD.prototype = { constructor: aD, hostedBy(t) {
    return this._dataZoomModel === t;
  }, getDataValueWindow() {
    return this._valueWindow.slice();
  }, getDataPercentWindow() {
    return this._percentWindow.slice();
  }, getTargetSeriesModels() {
    const n = []; const o = this.ecModel;return o.eachSeries(function (t) {
      if (function (t) {
        return 0 <= _(JA, t);
      }(t.get('coordinateSystem'))) {
        const e = this._dimName; const i = o.queryComponents({ mainType: `${e}Axis`, index: t.get(`${e}AxisIndex`), id: t.get(`${e}AxisId`) })[0];this._axisIndex === (i && i.componentIndex) && n.push(t);
      }
    }, this), n;
  }, getAxisModel() {
    return this.ecModel.getComponent(`${this._dimName}Axis`, this._axisIndex);
  }, getOtherAxisModel() {
    let t; let e; let i; const n = this._dimName; const o = this.ecModel; const a = this.getAxisModel();return t = 'x' === n || 'y' === n ? (e = 'gridIndex', 'x' === n ? 'y' : 'x') : (e = 'polarIndex', 'angle' === n ? 'radius' : 'angle'), o.eachComponent(`${t}Axis`, (t) => {
      (t.get(e) || 0) === (a.get(e) || 0) && (i = t);
    }), i;
  }, getMinMaxSpan() {
    return k(this._minMaxSpan);
  }, calculateDataWindow(o) {
    let a; const r = this._dataExtent; const s = this.getAxisModel().axis.scale; const l = this._dataZoomModel.getRangePropMode(); const u = [0, 100]; const h = []; const c = [];rD(['start', 'end'], (t, e) => {
      let i = o[t]; let n = o[`${t}Value`];'percent' === l[e] ? (null == i && (i = u[e]), n = s.parse(Rl(i, u, r))) : (a = !0, i = Rl(n = null == n ? r[e] : s.parse(n), r, u)), c[e] = n, h[e] = i;
    }), sD(c), sD(h);const d = this._minMaxSpan;function t(t, e, i, n, o) {
      const a = o ? 'Span' : 'ValueSpan';sb(0, t, i, 'all', d[`min${a}`], d[`max${a}`]);for (let r = 0;r < 2;r++)e[r] = Rl(t[r], i, n, !0), o && (e[r] = s.parse(e[r]));
    } return a ? t(c, h, r, u, !1) : t(h, c, u, r, !0), { valueWindow: c, percentWindow: h };
  }, reset(t) {
    if (t === this._dataZoomModel) {
      const e = this.getTargetSeriesModels();this._dataExtent = (function (t, e, i) {
        let n = [1 / 0, -1 / 0];rD(i, (t) => {
          const i = t.getData();i && rD(i.mapDimension(e, !0), (t) => {
            const e = i.getApproximateExtent(t);e[0] < n[0] && (n[0] = e[0]), e[1] > n[1] && (n[1] = e[1]);
          });
        }), n[1] < n[0] && (n = [NaN, NaN]);return (function (t, e) {
          const i = t.getAxisModel(); const n = i.getMin(!0); const o = 'category' === i.get('type'); const a = o && i.getCategories().length;null != n && 'dataMin' !== n && 'function' !== typeof n ? e[0] = n : o && (e[0] = 0 < a ? 0 : NaN);const r = i.getMax(!0);null != r && 'dataMax' !== r && 'function' !== typeof r ? e[1] = r : o && (e[1] = 0 < a ? a - 1 : NaN);i.get('scale', !0) || (0 < e[0] && (e[0] = 0), e[1] < 0 && (e[1] = 0));
        }(t, n)), n;
      }(this, this._dimName, e)), (function (n) {
        const o = n._minMaxSpan = {}; const a = n._dataZoomModel; const r = n._dataExtent;rD(['min', 'max'], (t) => {
          let e = a.get(`${t}Span`); let i = a.get(`${t}ValueSpan`);null != i && (i = n.getAxisModel().axis.scale.parse(i)), null != i ? e = Rl(r[0] + i, r, [0, 100], !0) : null != e && (i = Rl(e, [0, 100], r, !0) - r[0]), o[`${t}Span`] = e, o[`${t}ValueSpan`] = i;
        });
      }(this));const i = this.calculateDataWindow(t.settledOption);this._valueWindow = i.valueWindow, this._percentWindow = i.percentWindow, lD(this);
    }
  }, restore(t) {
    t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, lD(this, !0));
  }, filterData(t, e) {
    if (t === this._dataZoomModel) {
      const n = this._dimName; const i = this.getTargetSeriesModels(); const o = t.get('filterMode'); const c = this._valueWindow;'none' !== o && rD(i, (i) => {
        let u = i.getData(); const h = u.mapDimension(n, !0);h.length && ('weakFilter' === o ? u.filterSelf((t) => {
          for (var e, i, n, o = 0;o < h.length;o++) {
            const a = u.get(h[o], t); const r = !isNaN(a); const s = a < c[0]; const l = a > c[1];if (r && !s && !l) return !0;r && (n = !0), s && (e = !0), l && (i = !0);
          } return n && e && i;
        }) : rD(h, (t) => {
          if ('empty' === o)i.setData(u = u.map(t, t => ((function (t) {
            return t >= c[0] && t <= c[1];
          }(t)) ? t : NaN)));else {
            const e = {};e[t] = c, u.selectRange(e);
          }
        }), rD(h, (t) => {
          u.setApproximateExtent(c, t);
        }));
      });
    }
  } };const uD = R; const hD = nD; const cD = Tf({ type: 'dataZoom', dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'], defaultOption: { zlevel: 0, z: 4, orient: null, xAxisIndex: null, yAxisIndex: null, filterMode: 'filter', throttle: null, start: 0, end: 100, startValue: null, endValue: null, minSpan: null, maxSpan: null, minValueSpan: null, maxValueSpan: null, rangeMode: null }, init(t, e, i) {
    this._dataIntervalByAxis = {}, this._dataInfo = {}, this._axisProxies = {}, this.textStyleModel, this._autoThrottle = !0, this._rangePropMode = ['percent', 'percent'];const n = dD(t);this.settledOption = n, this.mergeDefaultAndTheme(t, i), this.doInit(n);
  }, mergeOption(t) {
    const e = dD(t);m(this.option, t, !0), m(this.settledOption, e, !0), this.doInit(e);
  }, doInit(t) {
    const i = this.option;v.canvasSupported || (i.realtime = !1), this._setDefaultThrottle(t), fD(this, t);const n = this.settledOption;uD([['start', 'startValue'], ['end', 'endValue']], function (t, e) {
      'value' === this._rangePropMode[e] && (i[t[0]] = n[t[0]] = null);
    }, this), this.textStyleModel = this.getModel('textStyle'), this._resetTarget(), this._giveAxisProxies();
  }, _giveAxisProxies() {
    const r = this._axisProxies;this.eachTargetAxis(function (t, e, i, n) {
      const o = this.dependentModels[t.axis][e]; const a = o.__dzAxisProxy || (o.__dzAxisProxy = new aD(t.name, e, this, n));r[`${t.name}_${e}`] = a;
    }, this);
  }, _resetTarget() {
    const i = this.option; const t = this._judgeAutoMode();hD((t) => {
      const e = t.axisIndex;i[e] = Vo(i[e]);
    }, this), 'axisIndex' === t ? this._autoSetAxisIndex() : 'orient' === t && this._autoSetOrient();
  }, _judgeAutoMode() {
    const e = this.option; let i = !1;hD((t) => {
      null != e[t.axisIndex] && (i = !0);
    }, this);const t = e.orient;return null == t && i ? 'orient' : i ? void 0 : (null == t && (e.orient = 'horizontal'), 'axisIndex');
  }, _autoSetAxisIndex() {
    let a = !0; const e = this.get('orient', !0); const r = this.option; const t = this.dependentModels;if (a) {
      const i = 'vertical' === e ? 'y' : 'x';t[`${i}Axis`].length ? (r[`${i}AxisIndex`] = [0], a = !1) : uD(t.singleAxis, (t) => {
        a && t.get('orient', !0) === e && (r.singleAxisIndex = [t.componentIndex], a = !1);
      });
    }a && hD(function (t) {
      if (a) {
        const e = []; const i = this.dependentModels[t.axis];if (i.length && !e.length) for (let n = 0, o = i.length;n < o;n++)'category' === i[n].get('type') && e.push(n);(r[t.axisIndex] = e).length && (a = !1);
      }
    }, this), a && this.ecModel.eachSeries(function (o) {
      this._isSeriesHasAllAxesTypeOf(o, 'value') && hD((t) => {
        const e = r[t.axisIndex]; let i = o.get(t.axisIndex); const n = o.get(t.axisId);_(e, i = o.ecModel.queryComponents({ mainType: t.axis, index: i, id: n })[0].componentIndex) < 0 && e.push(i);
      });
    }, this);
  }, _autoSetOrient() {
    let e;this.eachTargetAxis((t) => {
      e = e || t.name;
    }, this), this.option.orient = 'y' === e ? 'vertical' : 'horizontal';
  }, _isSeriesHasAllAxesTypeOf(n, o) {
    let a = !0;return hD(function (t) {
      const e = n.get(t.axisIndex); const i = this.dependentModels[t.axis][e];i && i.get('type') === o || (a = !1);
    }, this), a;
  }, _setDefaultThrottle(t) {
    if (t.hasOwnProperty('throttle') && (this._autoThrottle = !1), this._autoThrottle) {
      const e = this.ecModel.option;this.option.throttle = e.animation && 0 < e.animationDurationUpdate ? 100 : 20;
    }
  }, getFirstTargetAxisModel() {
    let i;return hD(function (t) {
      if (null == i) {
        const e = this.get(t.axisIndex);e.length && (i = this.dependentModels[t.axis][e[0]]);
      }
    }, this), i;
  }, eachTargetAxis(i, n) {
    const o = this.ecModel;hD(function (e) {
      uD(this.get(e.axisIndex), function (t) {
        i.call(n, e, t, this, o);
      }, this);
    }, this);
  }, getAxisProxy(t, e) {
    return this._axisProxies[`${t}_${e}`];
  }, getAxisModel(t, e) {
    const i = this.getAxisProxy(t, e);return i && i.getAxisModel();
  }, setRawRange(e) {
    const i = this.option; const n = this.settledOption;uD([['start', 'startValue'], ['end', 'endValue']], (t) => {
      null == e[t[0]] && null == e[t[1]] || (i[t[0]] = n[t[0]] = e[t[0]], i[t[1]] = n[t[1]] = e[t[1]]);
    }, this), fD(this, e);
  }, setCalculatedRange(e) {
    const i = this.option;uD(['start', 'startValue', 'end', 'endValue'], (t) => {
      i[t] = e[t];
    });
  }, getPercentRange() {
    const t = this.findRepresentativeAxisProxy();if (t) return t.getDataPercentWindow();
  }, getValueRange(t, e) {
    if (null != t || null != e) return this.getAxisProxy(t, e).getDataValueWindow();const i = this.findRepresentativeAxisProxy();return i ? i.getDataValueWindow() : void 0;
  }, findRepresentativeAxisProxy(t) {
    if (t) return t.__dzAxisProxy;const e = this._axisProxies;for (var i in e) if (e.hasOwnProperty(i) && e[i].hostedBy(this)) return e[i];for (var i in e) if (e.hasOwnProperty(i) && !e[i].hostedBy(this)) return e[i];
  }, getRangePropMode() {
    return this._rangePropMode.slice();
  } });function dD(e) {
    const i = {};return uD(['start', 'end', 'startValue', 'endValue', 'throttle'], (t) => {
      e.hasOwnProperty(t) && (i[t] = e[t]);
    }), i;
  } function fD(t, o) {
    const a = t._rangePropMode; const r = t.get('rangeMode');uD([['start', 'startValue'], ['end', 'endValue']], (t, e) => {
      const i = null != o[t[0]]; const n = null != o[t[1]];i && !n ? a[e] = 'percent' : !i && n ? a[e] = 'value' : r ? a[e] = r[e] : i && (a[e] = 'percent');
    });
  } const pD = gc.extend({ type: 'dataZoom', render(t, e, i, n) {
    this.dataZoomModel = t, this.ecModel = e, this.api = i;
  }, getTargetCoordInfo() {
    const t = this.dataZoomModel; const o = this.ecModel; const a = {};return t.eachTargetAxis((t, e) => {
      const i = o.getComponent(t.axis, e);if (i) {
        const n = i.getCoordSysModel();n && (function (t, e, i, n) {
          for (var o, a = 0;a < i.length;a++) if (i[a].model === t) {
            o = i[a];break;
          }o || i.push(o = { model: t, axisModels: [], coordIndex: n });o.axisModels.push(e);
        }(n, i, a[n.mainType] || (a[n.mainType] = []), n.componentIndex));
      }
    }, this), a;
  } });cD.extend({ type: 'dataZoom.select' }), pD.extend({ type: 'dataZoom.select' }), xf({ getTargetSeries(t) {
    const n = Q();return t.eachComponent('dataZoom', (t) => {
      t.eachTargetAxis((t, e, i) => {
        R(i.getAxisProxy(t.name, e).getTargetSeriesModels(), (t) => {
          n.set(t.uid, t);
        });
      });
    }), n;
  }, modifyOutputEnd: !0, overallReset(t, n) {
    t.eachComponent('dataZoom', (t) => {
      t.eachTargetAxis((t, e, i) => {
        i.getAxisProxy(t.name, e).reset(i, n);
      }), t.eachTargetAxis((t, e, i) => {
        i.getAxisProxy(t.name, e).filterData(i, n);
      });
    }), t.eachComponent('dataZoom', (t) => {
      const e = t.findRepresentativeAxisProxy(); const i = e.getDataPercentWindow(); const n = e.getDataValueWindow();t.setCalculatedRange({ start: i[0], end: i[1], startValue: n[0], endValue: n[1] });
    });
  } }), _f('dataZoom', (i, t) => {
    const n = oD(A(t.eachComponent, t, 'dataZoom'), nD, (t, e) => t.get(e.axisIndex)); const o = [];t.eachComponent({ mainType: 'dataZoom', query: i }, (t, e) => {
      o.push.apply(o, n(t).nodes);
    }), R(o, (t, e) => {
      t.setRawRange({ start: i.start, end: i.end, startValue: i.startValue, endValue: i.endValue });
    });
  });const gD = Oc.toolbox.dataZoom; const mD = R;function vD(t, e, i) {
    (this._brushController = new Ob(i.getZr())).on('brush', A(this._onBrush, this)).mount(), this._isZoomActive;
  }vD.defaultOption = { show: !0, filterMode: 'filter', icon: { zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1', back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26' }, title: k(gD.title), brushStyle: { borderWidth: 0, color: 'rgba(0,0,0,0.2)' } };const yD = vD.prototype;yD.render = function (t, e, i, n) {
    this.model = t, this.ecModel = e, this.api = i, (function (t, e, i, n, o) {
      let a = i._isZoomActive;n && 'takeGlobalCursor' === n.type && (a = 'dataZoomSelect' === n.key && n.dataZoomSelectActive);i._isZoomActive = a, t.setIconStatus('zoom', a ? 'emphasis' : 'normal');const r = new zA(_D(t.option), e, { include: ['grid'] });i._brushController.setPanels(r.makePanelOpts(o, t => (t.xAxisDeclared && !t.yAxisDeclared ? 'lineX' : !t.xAxisDeclared && t.yAxisDeclared ? 'lineY' : 'rect'))).enableBrush(!!a && { brushType: 'auto', brushStyle: t.getModel('brushStyle').getItemStyle() });
    }(t, e, this, n, i)), (function (t, e) {
      t.setIconStatus('back', 1 < (function (t) {
        return $A(t).length;
      }(e)) ? 'emphasis' : 'normal');
    }(t, e));
  }, yD.onclick = function (t, e, i) {
    xD[i].call(this);
  }, yD.remove = function (t, e) {
    this._brushController.unmount();
  }, yD.dispose = function (t, e) {
    this._brushController.dispose();
  };var xD = { zoom() {
    const t = !this._isZoomActive;this.api.dispatchAction({ type: 'takeGlobalCursor', key: 'dataZoomSelect', dataZoomSelectActive: t });
  }, back() {
    this._dispatchZoomAction(function (t) {
      const n = $A(t); const e = n[n.length - 1];1 < n.length && n.pop();const o = {};return qA(e, (t, e) => {
        for (let i = n.length - 1;0 <= i;i--) {
          if (t = n[i][e]) {
            o[e] = t;break;
          }
        }
      }), o;
    }(this.ecModel));
  } };function _D(e) {
    const i = {};return R(['xAxisIndex', 'yAxisIndex'], (t) => {
      i[t] = e[t], null == i[t] && (i[t] = 'all'), !1 !== i[t] && 'none' !== i[t] || (i[t] = []);
    }), i;
  }yD._onBrush = function (t, e) {
    if (e.isEnd && t.length) {
      var s = {}; var l = this.ecModel;this._brushController.updateCovers([]), new zA(_D(this.model.option), l, { include: ['grid'] }).matchOutputRanges(t, l, (t, e, i) => {
        if ('cartesian2d' === i.type) {
          const n = t.brushType;'rect' === n ? (o('x', i, e[0]), o('y', i, e[1])) : o({ lineX: 'x', lineY: 'y' }[n], i, e);
        }
      }), (function (a, t) {
        const r = $A(a);qA(t, (t, e) => {
          for (var i = r.length - 1;0 <= i;i--) {
            if (r[i][e]) break;
          } if (i < 0) {
            const n = a.queryComponents({ mainType: 'dataZoom', subType: 'select', id: e })[0];if (n) {
              const o = n.getPercentRange();r[0][e] = { dataZoomId: e, start: o[0], end: o[1] };
            }
          }
        }), r.push(t);
      }(l, s)), this._dispatchZoomAction(s);
    } function o(t, e, i) {
      const n = e.getAxis(t); const o = n.model; const a = (function (e, i, t) {
        let n;return t.eachComponent({ mainType: 'dataZoom', subType: 'select' }, (t) => {
          t.getAxisModel(e, i.componentIndex) && (n = t);
        }), n;
      }(t, o, l)); const r = a.findRepresentativeAxisProxy(o).getMinMaxSpan();null == r.minValueSpan && null == r.maxValueSpan || (i = sb(0, i.slice(), n.scale.getExtent(), 0, r.minValueSpan, r.maxValueSpan)), a && (s[a.id] = { dataZoomId: a.id, startValue: i[0], endValue: i[1] });
    }
  }, yD._dispatchZoomAction = function (t) {
    const i = [];mD(t, (t, e) => {
      i.push(k(t));
    }), i.length && this.api.dispatchAction({ type: 'dataZoom', from: this.uid, batch: i });
  }, dA('dataZoom', vD), yf((s) => {
    if (s) {
      var l = s.dataZoom || (s.dataZoom = []);L(l) || (s.dataZoom = l = [l]);let t = s.toolbox;if (t && (L(t) && (t = t[0]), t && t.feature)) {
        const e = t.feature.dataZoom;i('xAxis', e), i('yAxis', e);
      }
    } function i(n, o) {
      if (o) {
        const a = `${n}Index`; let r = o[a];null == r || 'all' === r || L(r) || (r = !1 === r || 'none' === r ? [] : [r]), (function (t, e) {
          let i = s[t];L(i) || (i = i ? [i] : []);mD(i, e);
        }(n, (t, e) => {
          if (null == r || 'all' === r || -1 !== _(r, e)) {
            const i = { type: 'select', $fromToolbox: !0, filterMode: o.filterMode || 'filter', id: `\0_ec_\0toolbox-dataZoom_${n}${e}` };i[a] = e, l.push(i);
          }
        }));
      }
    }
  });const wD = Oc.toolbox.restore;function bD(t) {
    this.model = t;
  }bD.defaultOption = { show: !0, icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5', title: wD.title }, bD.prototype.onclick = function (t, e, i) {
    !(function (t) {
      t[KA] = null;
    }(t)), e.dispatchAction({ type: 'restore', from: this.uid });
  }, dA('restore', bD), _f({ type: 'restore', event: 'restore', update: 'prepareAndUpdate' }, (t, e) => {
    e.resetOption('recreate');
  }), Tf({ type: 'tooltip', dependencies: ['axisPointer'], defaultOption: { zlevel: 0, z: 60, show: !0, showContent: !0, trigger: 'item', triggerOn: 'mousemove|click', alwaysShowContent: !1, displayMode: 'single', renderMode: 'auto', confine: !1, showDelay: 0, hideDelay: 100, transitionDuration: .4, enterable: !1, backgroundColor: 'rgba(50,50,50,0.7)', borderColor: '#333', borderRadius: 4, borderWidth: 0, padding: 5, extraCssText: '', axisPointer: { type: 'line', axis: 'auto', animation: 'auto', animationDurationUpdate: 200, animationEasingUpdate: 'exponentialOut', crossStyle: { color: '#999', width: 1, type: 'dashed', textStyle: {} } }, textStyle: { color: '#fff', fontSize: 14 } } });const SD = R; const MD = eu; const ID = ['', '-webkit-', '-moz-', '-o-'];function TD(o) {
    const a = []; const t = o.get('transitionDuration'); const e = o.get('backgroundColor'); const i = o.getModel('textStyle'); const n = o.get('padding');return t && a.push(function (t) {
      const e = 'cubic-bezier(0.23, 1, 0.32, 1)'; const i = `left ${t}s ${e},top ${t}s ${e}`;return O(ID, t => `${t}transition:${i}`).join(';');
    }(t)), e && (v.canvasSupported ? a.push(`background-Color:${e}`) : (a.push(`background-Color:#${Ze(e)}`), a.push('filter:alpha(opacity=70)'))), SD(['width', 'color', 'radius'], (t) => {
      const e = `border-${t}`; const i = MD(e); const n = o.get(i);null != n && a.push(`${e}:${n}${'color' === t ? '' : 'px'}`);
    }), a.push(function (i) {
      const n = []; const t = i.get('fontSize'); const e = i.getTextColor();e && n.push(`color:${e}`), n.push(`font:${i.getFont()}`);let o = i.get('lineHeight');null == o && (o = Math.round(3 * t / 2)), t && n.push(`line-height:${o}px`);const a = i.get('textShadowColor'); const r = i.get('textShadowBlur') || 0; const s = i.get('textShadowOffsetX') || 0; const l = i.get('textShadowOffsetY') || 0;return r && n.push(`text-shadow:${s}px ${l}px ${r}px ${a}`), SD(['decoration', 'align'], (t) => {
        const e = i.get(t);e && n.push(`text-${t}:${e}`);
      }), n.join(';');
    }(i)), null != n && a.push(`padding:${iu(n).join('px ')}px`), `${a.join(';')};`;
  } function AD(t, e, i, n, o) {
    const a = e && e.painter;if (i) {
      const r = a && a.getViewportRoot();r && (function (t, e, i, n, o) {
        Et(Rt, e, n, o, !0) && Et(t, i, Rt[0], Rt[1]);
      }(t, r, document.body, n, o));
    } else {
      t[0] = n, t[1] = o;const s = a && a.getViewportRootOffset();s && (t[0] += s.offsetLeft, t[1] += s.offsetTop);
    }t[2] = t[0] / e.getWidth(), t[3] = t[1] / e.getHeight();
  } function DD(t, e, i) {
    if (v.wxa) return null;const n = document.createElement('div');n.domBelongToZr = !0, this.el = n;const o = this._zr = e.getZr(); const a = this._appendToBody = i && i.appendToBody;this._styleCoord = [0, 0, 0, 0], AD(this._styleCoord, o, a, e.getWidth() / 2, e.getHeight() / 2), a ? document.body.appendChild(n) : t.appendChild(n), this._container = t, this._show = !1, this._hideTimeout;const r = this;n.onmouseenter = function () {
      r._enterable && (clearTimeout(r._hideTimeout), r._show = !0), r._inContent = !0;
    }, n.onmousemove = function (t) {
      if (t = t || window.event, !r._enterable) {
        const e = o.handler;Zt(o.painter.getViewportRoot(), t, !0), e.dispatch('mousemove', t);
      }
    }, n.onmouseleave = function () {
      r._enterable && r._show && r.hideLater(r._hideDelay), r._inContent = !1;
    };
  } function CD(t, e, i, n) {
    t[0] = i, t[1] = n, t[2] = t[0] / e.getWidth(), t[3] = t[1] / e.getHeight();
  } function LD(t) {
    const e = this._zr = t.getZr();this._styleCoord = [0, 0, 0, 0], CD(this._styleCoord, e, t.getWidth() / 2, t.getHeight() / 2), this._show = !1, this._hideTimeout;
  }DD.prototype = { constructor: DD, _enterable: !0, update(t) {
    const e = this._container; const i = e.currentStyle || document.defaultView.getComputedStyle(e); const n = e.style;'absolute' !== n.position && 'absolute' !== i.position && (n.position = 'relative'), t.get('alwaysShowContent') && this._moveTooltipIfResized();
  }, _moveTooltipIfResized() {
    const t = this._styleCoord[2]; const e = this._styleCoord[3]; const i = t * this._zr.getWidth(); const n = e * this._zr.getHeight();this.moveTo(i, n);
  }, show(t) {
    clearTimeout(this._hideTimeout);const e = this.el; const i = this._styleCoord;e.style.cssText = `position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;${TD(t)};left:${i[0]}px;top:${i[1]}px;${t.get('extraCssText') || ''}`, e.style.display = e.innerHTML ? 'block' : 'none', e.style.pointerEvents = this._enterable ? 'auto' : 'none', this._show = !0;
  }, setContent(t) {
    this.el.innerHTML = null == t ? '' : t;
  }, setEnterable(t) {
    this._enterable = t;
  }, getSize() {
    const t = this.el;return [t.clientWidth, t.clientHeight];
  }, moveTo(t, e) {
    const i = this._styleCoord;AD(i, this._zr, this._appendToBody, t, e);const n = this.el.style;n.left = `${i[0]}px`, n.top = `${i[1]}px`;
  }, hide() {
    this.el.style.display = 'none', this._show = !1;
  }, hideLater(t) {
    !this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(A(this.hide, this), t)) : this.hide());
  }, isShow() {
    return this._show;
  }, dispose() {
    this.el.parentNode.removeChild(this.el);
  }, getOuterSize() {
    let t = this.el.clientWidth; let e = this.el.clientHeight;if (document.defaultView && document.defaultView.getComputedStyle) {
      const i = document.defaultView.getComputedStyle(this.el);i && (t += parseInt(i.borderLeftWidth, 10) + parseInt(i.borderRightWidth, 10), e += parseInt(i.borderTopWidth, 10) + parseInt(i.borderBottomWidth, 10));
    } return { width: t, height: e };
  } }, LD.prototype = { constructor: LD, _enterable: !0, update(t) {
    t.get('alwaysShowContent') && this._moveTooltipIfResized();
  }, _moveTooltipIfResized() {
    const t = this._styleCoord[2]; const e = this._styleCoord[3]; const i = t * this._zr.getWidth(); const n = e * this._zr.getHeight();this.moveTo(i, n);
  }, show(t) {
    this._hideTimeout && clearTimeout(this._hideTimeout), this.el.attr('show', !0), this._show = !0;
  }, setContent(t, e, i) {
    this.el && this._zr.remove(this.el);for (var n = {}, o = t, a = '{marker', r = o.indexOf(a);0 <= r;) {
      const s = o.indexOf('|}'); const l = o.substr(r + a.length, s - r - a.length);-1 < l.indexOf('sub') ? n[`marker${l}`] = { textWidth: 4, textHeight: 4, textBorderRadius: 2, textBackgroundColor: e[l], textOffset: [3, 0] } : n[`marker${l}`] = { textWidth: 10, textHeight: 10, textBorderRadius: 5, textBackgroundColor: e[l] }, r = (o = o.substr(s + 1)).indexOf('{marker');
    } const u = i.getModel('textStyle'); const h = u.get('fontSize'); let c = i.get('textLineHeight');null == c && (c = Math.round(3 * h / 2)), this.el = new Ur({ style: nl({}, u, { rich: n, text: t, textBackgroundColor: i.get('backgroundColor'), textBorderRadius: i.get('borderRadius'), textFill: i.get('textStyle.color'), textPadding: i.get('padding'), textLineHeight: c }), z: i.get('z') }), this._zr.add(this.el);const d = this;this.el.on('mouseover', () => {
      d._enterable && (clearTimeout(d._hideTimeout), d._show = !0), d._inContent = !0;
    }), this.el.on('mouseout', () => {
      d._enterable && d._show && d.hideLater(d._hideDelay), d._inContent = !1;
    });
  }, setEnterable(t) {
    this._enterable = t;
  }, getSize() {
    const t = this.el.getBoundingRect();return [t.width, t.height];
  }, moveTo(t, e) {
    if (this.el) {
      const i = this._styleCoord;CD(i, this._zr, t, e), this.el.attr('position', [i[0], i[1]]);
    }
  }, hide() {
    this.el && this.el.hide(), this._show = !1;
  }, hideLater(t) {
    !this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(A(this.hide, this), t)) : this.hide());
  }, isShow() {
    return this._show;
  }, dispose() {
    clearTimeout(this._hideTimeout), this.el && this._zr.remove(this.el);
  }, getOuterSize() {
    const t = this.getSize();return { width: t[0], height: t[1] };
  } };const kD = A; const PD = R; const ND = El; const OD = new rs({ shape: { x: -1, y: -1, width: 2, height: 2 } });function RD(t) {
    for (var e = t.pop();t.length;) {
      let i = t.pop();i && (Cl.isInstance(i) && (i = i.get('tooltip', !0)), 'string' === typeof i && (i = { formatter: i }), e = new Cl(i, e, e.ecModel));
    } return e;
  } function ED(t, e) {
    return t.dispatchAction || A(e.dispatchAction, e);
  } function zD(t) {
    return 'center' === t || 'middle' === t;
  }Af({ type: 'tooltip', init(t, e) {
    if (!v.node) {
      let i; const n = t.getComponent('tooltip'); const o = n.get('renderMode');this._renderMode = Qo(o), 'html' === this._renderMode ? (i = new DD(e.getDom(), e, { appendToBody: n.get('appendToBody', !0) }), this._newLine = '<br/>') : (i = new LD(e), this._newLine = '\n'), this._tooltipContent = i;
    }
  }, render(t, e, i) {
    if (!v.node) {
      this.group.removeAll(), this._tooltipModel = t, this._ecModel = e, this._api = i, this._lastDataByCoordSys = null, this._alwaysShowContent = t.get('alwaysShowContent');const n = this._tooltipContent;n.update(t), n.setEnterable(t.get('enterable')), this._initGlobalListener(), this._keepShow();
    }
  }, _initGlobalListener() {
    const n = this._tooltipModel.get('triggerOn');bI('itemTooltip', this._api, kD(function (t, e, i) {
      'none' !== n && (0 <= n.indexOf(t) ? this._tryShow(e, i) : 'leave' === t && this._hide(i));
    }, this));
  }, _keepShow() {
    const t = this._tooltipModel; const e = this._ecModel; const i = this._api;if (null != this._lastX && null != this._lastY && 'none' !== t.get('triggerOn')) {
      const n = this;clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(() => {
        i.isDisposed() || n.manuallyShowTip(t, e, i, { x: n._lastX, y: n._lastY });
      });
    }
  }, manuallyShowTip(t, e, i, n) {
    if (n.from !== this.uid && !v.node) {
      const o = ED(n, i);this._ticket = '';const a = n.dataByCoordSys;if (n.tooltip && null != n.x && null != n.y) {
        const r = OD;r.position = [n.x, n.y], r.update(), r.tooltip = n.tooltip, this._tryShow({ offsetX: n.x, offsetY: n.y, target: r }, o);
      } else if (a) this._tryShow({ offsetX: n.x, offsetY: n.y, position: n.position, dataByCoordSys: n.dataByCoordSys, tooltipOption: n.tooltipOption }, o);else if (null != n.seriesIndex) {
        if (this._manuallyAxisShowTip(t, e, i, n)) return;const s = cI(n, e); const l = s.point[0]; const u = s.point[1];null != l && null != u && this._tryShow({ offsetX: l, offsetY: u, position: n.position, target: s.el }, o);
      } else null != n.x && null != n.y && (i.dispatchAction({ type: 'updateAxisPointer', x: n.x, y: n.y }), this._tryShow({ offsetX: n.x, offsetY: n.y, position: n.position, target: i.getZr().findHover(n.x, n.y).target }, o));
    }
  }, manuallyHideTip(t, e, i, n) {
    const o = this._tooltipContent;!this._alwaysShowContent && this._tooltipModel && o.hideLater(this._tooltipModel.get('hideDelay')), this._lastX = this._lastY = null, n.from !== this.uid && this._hide(ED(n, i));
  }, _manuallyAxisShowTip(t, e, i, n) {
    const o = n.seriesIndex; const a = n.dataIndex; const r = e.getComponent('axisPointer').coordSysAxesInfo;if (null != o && null != a && null != r) {
      const s = e.getSeriesByIndex(o);if (s) if ('axis' === (t = RD([s.getData().getItemModel(a), s, (s.coordinateSystem || {}).model, t])).get('trigger')) return i.dispatchAction({ type: 'updateAxisPointer', seriesIndex: o, dataIndex: a, position: n.position }), !0;
    }
  }, _tryShow(t, e) {
    const i = t.target;if (this._tooltipModel) {
      this._lastX = t.offsetX, this._lastY = t.offsetY;const n = t.dataByCoordSys;n && n.length ? this._showAxisTooltip(n, t) : i && null != i.dataIndex ? (this._lastDataByCoordSys = null, this._showSeriesItemTooltip(t, i, e)) : i && i.tooltip ? (this._lastDataByCoordSys = null, this._showComponentItemTooltip(t, i, e)) : (this._lastDataByCoordSys = null, this._hide(e));
    }
  }, _showOrMove(t, e) {
    const i = t.get('showDelay');e = A(e, this), clearTimeout(this._showTimout), 0 < i ? this._showTimout = setTimeout(e, i) : e();
  }, _showAxisTooltip(t, e) {
    const d = this._ecModel; const i = this._tooltipModel; const n = [e.offsetX, e.offsetY]; let o = []; const f = []; const a = RD([e.tooltipOption, i]); const p = this._renderMode; const r = this._newLine; const g = {};PD(t, (t) => {
      PD(t.dataByAxis, (s) => {
        const l = d.getComponent(`${s.axisDim}Axis`, s.axisIndex); const u = s.value; const h = [];if (l && null != u) {
          const c = zI(u, l.axis, d, s.seriesDataIndices, s.valueLabelOpt);R(s.seriesDataIndices, (t) => {
            const e = d.getSeriesByIndex(t.seriesIndex); const i = t.dataIndexInside; const n = e && e.getDataParams(i);if (n.axisDim = s.axisDim, n.axisIndex = s.axisIndex, n.axisType = s.axisType, n.axisId = s.axisId, n.axisValue = ug(l.axis, u), n.axisValueLabel = c, n) {
              f.push(n);let o; const a = e.formatTooltip(i, !0, null, p);if (z(a)) {
                o = a.html;const r = a.markers;m(g, r);
              } else o = a;h.push(o);
            }
          });const t = c;'html' !== p ? o.push(h.join(r)) : o.push((t ? au(t) + r : '') + h.join(r));
        }
      });
    }, this), o.reverse(), o = o.join(this._newLine + this._newLine);const s = e.position;this._showOrMove(a, function () {
      this._updateContentNotChangedOnAxis(t) ? this._updatePosition(a, s, n[0], n[1], this._tooltipContent, f) : this._showTooltipContent(a, o, f, Math.random(), n[0], n[1], s, void 0, g);
    });
  }, _showSeriesItemTooltip(t, e, i) {
    const n = this._ecModel; const o = e.seriesIndex; const a = n.getSeriesByIndex(o); const r = e.dataModel || a; const s = e.dataIndex; const l = e.dataType; const u = r.getData(l); const h = RD([u.getItemModel(s), r, a && (a.coordinateSystem || {}).model, this._tooltipModel]); const c = h.get('trigger');if (null == c || 'item' === c) {
      let d; let f; const p = r.getDataParams(s, l); const g = r.formatTooltip(s, !1, l, this._renderMode);f = z(g) ? (d = g.html, g.markers) : (d = g, null);const m = `item_${r.name}_${s}`;this._showOrMove(h, function () {
        this._showTooltipContent(h, d, p, m, t.offsetX, t.offsetY, t.position, t.target, f);
      }), i({ type: 'showTip', dataIndexInside: s, dataIndex: u.getRawIndex(s), seriesIndex: o, from: this.uid });
    }
  }, _showComponentItemTooltip(t, e, i) {
    let n = e.tooltip;if ('string' === typeof n) {
      n = { content: n, formatter: n };
    } const o = new Cl(n, this._tooltipModel, this._ecModel); const a = o.get('content'); const r = Math.random();this._showOrMove(o, function () {
      this._showTooltipContent(o, a, o.get('formatterParams') || {}, r, t.offsetX, t.offsetY, t.position, e);
    }), i({ type: 'showTip', from: this.uid });
  }, _showTooltipContent(i, t, n, e, o, a, r, s, l) {
    if (this._ticket = '', i.get('showContent') && i.get('show')) {
      const u = this._tooltipContent; const h = i.get('formatter');r = r || i.get('position');let c = t;if (h && 'string' === typeof h)c = lu(h, n, !0);else if ('function' === typeof h) {
        const d = kD(function (t, e) {
          t === this._ticket && (u.setContent(e, l, i), this._updatePosition(i, r, o, a, u, n, s));
        }, this);this._ticket = e, c = h(n, e, d);
      }u.setContent(c, l, i), u.show(i), this._updatePosition(i, r, o, a, u, n, s);
    }
  }, _updatePosition(t, e, i, n, o, a, r) {
    const s = this._api.getWidth(); const l = this._api.getHeight();e = e || t.get('position');const u = o.getSize(); let h = t.get('align'); let c = t.get('verticalAlign'); const d = r && r.getBoundingRect().clone();if (r && d.applyTransform(r.transform), 'function' === typeof e && (e = e([i, n], a, o.el, d, { viewSize: [s, l], contentSize: u.slice() })), L(e))i = ND(e[0], s), n = ND(e[1], l);else if (z(e)) {
      e.width = u[0], e.height = u[1];const f = bu(e, { width: s, height: l });i = f.x, n = f.y, c = h = null;
    } else if ('string' === typeof e && r) {
      i = (p = (function (t, e, i) {
        const n = i[0]; const o = i[1]; let a = 0; let r = 0; const s = e.width; const l = e.height;switch (t) {
          case 'inside':a = e.x + s / 2 - n / 2, r = e.y + l / 2 - o / 2;break;case 'top':a = e.x + s / 2 - n / 2, r = e.y - o - 5;break;case 'bottom':a = e.x + s / 2 - n / 2, r = e.y + l + 5;break;case 'left':a = e.x - n - 5, r = e.y + l / 2 - o / 2;break;case 'right':a = e.x + s + 5, r = e.y + l / 2 - o / 2;
        } return [a, r];
      }(e, d, u)))[0], n = p[1];
    } else {
      var p;i = (p = (function (t, e, i, n, o, a, r) {
        const s = i.getOuterSize(); const l = s.width; const u = s.height;null != a && (n < t + l + a ? t -= l + a : t += a);null != r && (o < e + u + r ? e -= u + r : e += r);return [t, e];
      }(i, n, o, s, l, h ? null : 20, c ? null : 20)))[0], n = p[1];
    }h && (i -= zD(h) ? u[0] / 2 : 'right' === h ? u[0] : 0), c && (n -= zD(c) ? u[1] / 2 : 'bottom' === c ? u[1] : 0), t.get('confine') && (i = (p = (function (t, e, i, n, o) {
      const a = i.getOuterSize(); const r = a.width; const s = a.height;return t = Math.min(t + r, n) - r, e = Math.min(e + s, o) - s, t = Math.max(t, 0), e = Math.max(e, 0), [t, e];
    }(i, n, o, s, l)))[0], n = p[1]);o.moveTo(i, n);
  }, _updateContentNotChangedOnAxis(n) {
    const t = this._lastDataByCoordSys; let r = !!t && t.length === n.length;return r && PD(t, (t, e) => {
      const i = t.dataByAxis || {}; const a = (n[e] || {}).dataByAxis || [];(r &= i.length === a.length) && PD(i, (t, e) => {
        const i = a[e] || {}; const n = t.seriesDataIndices || []; const o = i.seriesDataIndices || [];(r &= t.value === i.value && t.axisType === i.axisType && t.axisId === i.axisId && n.length === o.length) && PD(n, (t, e) => {
          const i = o[e];r &= t.seriesIndex === i.seriesIndex && t.dataIndex === i.dataIndex;
        });
      });
    }), this._lastDataByCoordSys = n, !!r;
  }, _hide(t) {
    this._lastDataByCoordSys = null, t({ type: 'hideTip', from: this.uid });
  }, dispose(t, e) {
    v.node || (this._tooltipContent.dispose(), II('itemTooltip', e));
  } }), _f({ type: 'showTip', event: 'showTip', update: 'tooltip:manuallyShowTip' }, () => {}), _f({ type: 'hideTip', event: 'hideTip', update: 'tooltip:manuallyHideTip' }, () => {});const BD = ['rect', 'polygon', 'keep', 'clear'];const VD = R;function GD(t) {
    if (t) for (const e in t) if (t.hasOwnProperty(e)) return !0;
  } function FD(t, e, a) {
    const i = {};return VD(e, (n) => {
      const o = i[n] = (function () {
        function t() {} return t.prototype.__hidden = t.prototype, new t;
      }());VD(t[n], (t, e) => {
        if (g_.isValidType(e)) {
          let i = { type: e, visual: t };a && a(i, n), o[e] = new g_(i), 'opacity' === e && ((i = k(i)).type = 'colorAlpha', o.__hidden.__alphaForOpacity = new g_(i));
        }
      });
    }), i;
  } function WD(e, i, t) {
    let n;R(t, (t) => {
      i.hasOwnProperty(t) && GD(i[t]) && (n = !0);
    }), n && R(t, (t) => {
      i.hasOwnProperty(t) && GD(i[t]) ? e[t] = k(i[t]) : delete e[t];
    });
  } const HD = { lineX: ZD(0), lineY: ZD(1), rect: { point(t, e, i) {
    return t && i.boundingRect.contain(t[0], t[1]);
  }, rect(t, e, i) {
    return t && i.boundingRect.intersect(t);
  } }, polygon: { point(t, e, i) {
    return t && i.boundingRect.contain(t[0], t[1]) && Tg(i.range, t[0], t[1]);
  }, rect(t, e, i) {
    const n = i.range;if (!t || n.length <= 1) return !1;const o = t.x; const a = t.y; const r = t.width; const s = t.height; const l = n[0];return !!(Tg(n, o, a) || Tg(n, o + r, a) || Tg(n, o, a + s) || Tg(n, o + r, a + s) || Di.create(t).contain(l[0], l[1]) || xl(o, a, o + r, a, n) || xl(o, a, o, a + s, n) || xl(o + r, a, o + r, a + s, n) || xl(o, a + s, o + r, a + s, n)) || void 0;
  } } };function ZD(a) {
    const r = ['x', 'y']; const s = ['width', 'height'];return { point(t, e, i) {
      if (t) {
        const n = i.range;return UD(t[a], n);
      }
    }, rect(t, e, i) {
      if (t) {
        const n = i.range; const o = [t[r[a]], t[r[a]] + t[s[a]]];return o[1] < o[0] && o.reverse(), UD(o[0], n) || UD(o[1], n) || UD(n[0], o) || UD(n[1], o);
      }
    } };
  } function UD(t, e) {
    return e[0] <= t && t <= e[1];
  } const XD = ['inBrush', 'outOfBrush']; const YD = '__ecBrushSelect'; const jD = '__ecInBrushSelectEvent'; const qD = Ld.VISUAL.BRUSH;function KD(e) {
    e.eachComponent({ mainType: 'brush' }, (t) => {
      (t.brushTargetManager = new zA(t.option, e)).setInputRanges(t.areas, e);
    });
  } function $D(t, e) {
    if (!t.isDisposed()) {
      const i = t.getZr();i[jD] = !0, t.dispatchAction({ type: 'brushSelect', batch: e }), i[jD] = !1;
    }
  } function JD(t, e, i, n) {
    for (let o = 0, a = e.length;o < a;o++) {
      const r = e[o];if (t[r.brushType](n, i, r.selectors, r)) return !0;
    }
  } function QD(t) {
    const r = t.brushSelector;if (E(r)) {
      const e = [];return R(HD, (a, t) => {
        e[t] = function (t, e, i, n) {
          const o = e.getItemLayout(t);return a[r](o, i, n);
        };
      }), e;
    } if (C(r)) {
      const i = {};return R(HD, (t, e) => {
        i[e] = r;
      }), i;
    } return r;
  }bf(qD, (t, e, i) => {
    t.eachComponent({ mainType: 'brush' }, (t) => {
      i && 'takeGlobalCursor' === i.type && t.setBrushOption('brush' === i.key ? i.brushOption : { brushType: !1 });
    }), KD(t);
  }), Sf(qD, (p, t, e) => {
    let o; let g; const m = [];p.eachComponent({ mainType: 'brush' }, (a, t) => {
      const s = { brushId: a.id, brushIndex: t, brushName: a.name, areas: k(a.areas), selected: [] };m.push(s);const e = a.option; const i = e.brushLink; const n = []; const l = []; const u = []; let h = 0;t || (o = e.throttleType, g = e.throttleDelay);const r = O(a.areas, t => (function (i) {
        const n = i.selectors = {};return R(HD[i.brushType], (e, t) => {
          n[t] = function (t) {
            return e(t, n, i);
          };
        }), i;
      }(D({ boundingRect: tC[t.brushType](t) }, t)))); const c = FD(a.option, XD, (t) => {
        t.mappingMethod = 'fixed';
      });function d(t) {
        return 'all' === i || n[t];
      } function f(t) {
        return !!t.length;
      }L(i) && R(i, (t) => {
        n[t] = 1;
      }), p.eachSeries((t, e) => {
        const i = u[e] = [];'parallel' === t.subType ? (function (t, e) {
          const i = t.coordinateSystem;h |= i.hasAxisBrushed(), d(e) && i.eachActiveState(t.getData(), (t, e) => {
            'active' === t && (l[e] = 1);
          });
        }(t, e)) : (function (e, t, i) {
          const n = QD(e);if (!n || (function (t, e) {
            const i = t.option.seriesIndex;return null != i && 'all' !== i && (L(i) ? _(i, e) < 0 : e !== i);
          }(a, t))) return;if (R(r, (t) => {
            n[t.brushType] && a.brushTargetManager.controlSeries(t, e, p) && i.push(t), h |= f(i);
          }), d(t) && f(i)) {
            const o = e.getData();o.each((t) => {
              JD(n, i, o, t) && (l[t] = 1);
            });
          }
        }(t, e, i));
      }), p.eachSeries((t, e) => {
        const i = { seriesId: t.id, seriesIndex: e, seriesName: t.name, dataIndex: [] };s.selected.push(i);const n = QD(t); const o = u[e]; const a = t.getData(); const r = d(e) ? function (t) {
          return l[t] ? (i.dataIndex.push(a.getRawIndex(t)), 'inBrush') : 'outOfBrush';
        } : function (t) {
          return JD(n, o, a, t) ? (i.dataIndex.push(a.getRawIndex(t)), 'inBrush') : 'outOfBrush';
        };(d(e) ? h : f(o)) && (function (t, u, h, c, d, f) {
          let p; const g = {};function m(t) {
            return h.getItemVisual(p, t);
          } function v(t, e) {
            h.setItemVisual(p, t, e);
          } function e(t, e) {
            p = null == f ? t : e;const i = h.getRawDataItem(p);if (!i || !1 !== i.visualMap) for (let n = c.call(d, t), o = u[n], a = g[n], r = 0, s = a.length;r < s;r++) {
              const l = a[r];o[l] && o[l].applyVisual(t, m, v);
            }
          }R(t, (t) => {
            const e = g_.prepareVisualTypes(u[t]);g[t] = e;
          }), null == f ? h.each(e) : h.each([f], e);
        }(XD, c, a, r));
      });
    }), (function (t, e, i, n, o) {
      if (!o) return;const a = t.getZr();if (a[jD]) return;a[YD] || (a[YD] = $D);kc(a, YD, i, e)(t, n);
    }(t, o, g, m, e));
  });var tC = { lineX: et, lineY: et, rect(t) {
    return eC(t.range);
  }, polygon(t) {
    for (var e, i = t.range, n = 0, o = i.length;n < o;n++) {
      e = e || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];const a = i[n];a[0] < e[0][0] && (e[0][0] = a[0]), a[0] > e[0][1] && (e[0][1] = a[0]), a[1] < e[1][0] && (e[1][0] = a[1]), a[1] > e[1][1] && (e[1][1] = a[1]);
    } return e && eC(e);
  } };function eC(t) {
    return new Di(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0]);
  } const iC = ['#ddd'];Tf({ type: 'brush', dependencies: ['geo', 'grid', 'xAxis', 'yAxis', 'parallel', 'series'], defaultOption: { toolbox: null, brushLink: null, seriesIndex: 'all', geoIndex: null, xAxisIndex: null, yAxisIndex: null, brushType: 'rect', brushMode: 'single', transformable: !0, brushStyle: { borderWidth: 1, color: 'rgba(120,140,180,0.3)', borderColor: 'rgba(120,140,180,0.8)' }, throttleType: 'fixRate', throttleDelay: 0, removeOnClick: !0, z: 1e4 }, areas: [], brushType: null, brushOption: {}, coordInfoList: [], optionUpdated(t, e) {
    const i = this.option;e || WD(i, t, ['inBrush', 'outOfBrush']);const n = i.inBrush = i.inBrush || {};i.outOfBrush = i.outOfBrush || { color: iC }, n.hasOwnProperty('liftZ') || (n.liftZ = 5);
  }, setAreas(t) {
    t && (this.areas = O(t, function (t) {
      return nC(this.option, t);
    }, this));
  }, setBrushOption(t) {
    this.brushOption = nC(this.option, t), this.brushType = this.brushOption.brushType;
  } });function nC(t, e) {
    return m({ brushType: t.brushType, brushMode: t.brushMode, transformable: t.transformable, brushStyle: new Cl(t.brushStyle).getItemStyle(), removeOnClick: t.removeOnClick, z: t.z }, e, !0);
  } function oC(t, e, i, n) {
    n && n.$from === t.id || this._brushController.setPanels(t.brushTargetManager.makePanelOpts(i)).enableBrush(t.brushOption)
      .updateCovers(t.areas.slice());
  }Af({ type: 'brush', init(t, e) {
    this.ecModel = t, this.api = e, this.model, (this._brushController = new Ob(e.getZr())).on('brush', A(this._onBrush, this)).mount();
  }, render(t) {
    return this.model = t, oC.apply(this, arguments);
  }, updateTransform(t, e) {
    return KD(e), oC.apply(this, arguments);
  }, updateView: oC, dispose() {
    this._brushController.dispose();
  }, _onBrush(t, e) {
    const i = this.model.id;this.model.brushTargetManager.setOutputRanges(t, this.ecModel), e.isEnd && !e.removeOnClick || this.api.dispatchAction({ type: 'brush', brushId: i, areas: k(t), $from: i }), e.isEnd && this.api.dispatchAction({ type: 'brushEnd', brushId: i, areas: k(t), $from: i });
  } }), _f({ type: 'brush', event: 'brush' }, (e, t) => {
    t.eachComponent({ mainType: 'brush', query: e }, (t) => {
      t.setAreas(e.areas);
    });
  }), _f({ type: 'brushSelect', event: 'brushSelected', update: 'none' }, () => {}), _f({ type: 'brushEnd', event: 'brushEnd', update: 'none' }, () => {});const aC = Oc.toolbox.brush;function rC(t, e, i) {
    this.model = t, this.ecModel = e, this.api = i, this._brushType, this._brushMode;
  }rC.defaultOption = { show: !0, type: ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear'], icon: { rect: 'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13', polygon: 'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2', lineX: 'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4', lineY: 'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4', keep: 'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z', clear: 'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2' }, title: k(aC.title) };const sC = rC.prototype;sC.render = sC.updateView = function (e, t, i) {
    let n; let o; let a;t.eachComponent({ mainType: 'brush' }, (t) => {
      n = t.brushType, o = t.brushOption.brushMode || 'single', a |= t.areas.length;
    }), this._brushType = n, this._brushMode = o, R(e.get('type', !0), (t) => {
      e.setIconStatus(t, ('keep' === t ? 'multiple' === o : 'clear' === t ? a : t === n) ? 'emphasis' : 'normal');
    });
  }, sC.getIcons = function () {
    const t = this.model; const e = t.get('icon', !0); const i = {};return R(t.get('type', !0), (t) => {
      e[t] && (i[t] = e[t]);
    }), i;
  }, sC.onclick = function (t, e, i) {
    const n = this._brushType; const o = this._brushMode;'clear' === i ? (e.dispatchAction({ type: 'axisAreaSelect', intervals: [] }), e.dispatchAction({ type: 'brush', command: 'clear', areas: [] })) : e.dispatchAction({ type: 'takeGlobalCursor', key: 'brush', brushOption: { brushType: 'keep' === i ? n : n !== i && i, brushMode: 'keep' === i ? 'multiple' === o ? 'single' : 'multiple' : o } });
  }, dA('brush', rC), yf((t, e) => {
    let i = t && t.brush;if (L(i) || (i = i ? [i] : []), i.length) {
      let n = [];R(i, (t) => {
        const e = t.hasOwnProperty('toolbox') ? t.toolbox : [];e instanceof Array && (n = n.concat(e));
      });let o = t && t.toolbox;L(o) && (o = o[0]), o || (o = { feature: {} }, t.toolbox = [o]);const a = o.feature || (o.feature = {}); const r = a.brush || (a.brush = {}); const s = r.type || (r.type = []);s.push.apply(s, n), (function (i) {
        const e = {};R(i, (t) => {
          e[t] = 1;
        }), i.length = 0, R(e, (t, e) => {
          i.push(e);
        });
      }(s)), e && !s.length && s.push.apply(s, BD);
    }
  }), Tf({ type: 'title', layoutMode: { type: 'box', ignoreSize: !0 }, defaultOption: { zlevel: 0, z: 6, show: !0, text: '', target: 'blank', subtext: '', subtarget: 'blank', left: 0, top: 0, backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', borderWidth: 0, padding: 5, itemGap: 10, textStyle: { fontSize: 18, fontWeight: 'bolder', color: '#333' }, subtextStyle: { color: '#aaa' } } }), Af({ type: 'title', render(t, e, i) {
    if (this.group.removeAll(), t.get('show')) {
      const n = this.group; const o = t.getModel('textStyle'); const a = t.getModel('subtextStyle'); let r = t.get('textAlign'); let s = H(t.get('textBaseline'), t.get('textVerticalAlign')); const l = new Ur({ style: nl({}, o, { text: t.get('text'), textFill: o.getTextColor() }, { disableBox: !0 }), z2: 10 }); const u = l.getBoundingRect(); const h = t.get('subtext'); const c = new Ur({ style: nl({}, a, { text: h, textFill: a.getTextColor(), y: u.height + t.get('itemGap'), textVerticalAlign: 'top' }, { disableBox: !0 }), z2: 10 }); const d = t.get('link'); const f = t.get('sublink'); const p = t.get('triggerEvent', !0);l.silent = !d && !p, c.silent = !f && !p, d && l.on('click', () => {
        gu(d, `_${t.get('target')}`);
      }), f && c.on('click', () => {
        gu(f, `_${t.get('subtarget')}`);
      }), l.eventData = c.eventData = p ? { componentType: 'title', componentIndex: t.componentIndex } : null, n.add(l), h && n.add(c);let g = n.getBoundingRect(); const m = t.getBoxLayoutParams();m.width = g.width, m.height = g.height;const v = bu(m, { width: i.getWidth(), height: i.getHeight() }, t.get('padding'));r || ('middle' === (r = t.get('left') || t.get('right')) && (r = 'center'), 'right' === r ? v.x += v.width : 'center' === r && (v.x += v.width / 2)), s || ('center' === (s = t.get('top') || t.get('bottom')) && (s = 'middle'), 'bottom' === s ? v.y += v.height : 'middle' === s && (v.y += v.height / 2), s = s || 'top'), n.attr('position', [v.x, v.y]);const y = { textAlign: r, textVerticalAlign: s };l.setStyle(y), c.setStyle(y), g = n.getBoundingRect();const x = v.margin; const _ = t.getItemStyle(['color', 'opacity']);_.fill = t.get('backgroundColor');const w = new rs({ shape: { x: g.x - x[3], y: g.y - x[0], width: g.width + x[1] + x[3], height: g.height + x[0] + x[2], r: t.get('borderRadius') }, style: _, subPixelOptimize: !0, silent: !0 });n.add(w);
    }
  } });function lC(t) {
    const e = t.itemStyle || (t.itemStyle = {}); const i = e.emphasis || (e.emphasis = {}); const n = t.label || t.label || {}; const o = n.normal || (n.normal = {}); const a = { normal: 1, emphasis: 1 };R(n, (t, e) => {
      a[e] || uC(o, e) || (o[e] = t);
    }), i.label && !uC(n, 'emphasis') && (n.emphasis = i.label, delete i.label);
  } function uC(t, e) {
    return t.hasOwnProperty(e);
  }ku.registerSubTypeDefaulter('timeline', () => 'slider'), _f({ type: 'timelineChange', event: 'timelineChanged', update: 'prepareAndUpdate' }, (t, e) => {
    const i = e.getComponent('timeline');return i && null != t.currentIndex && (i.setCurrentIndex(t.currentIndex), !i.get('loop', !0) && i.isIndexMax() && i.setPlayState(!1)), e.resetOption('timeline'), D({ currentIndex: i.option.currentIndex }, t);
  }), _f({ type: 'timelinePlayChange', event: 'timelinePlayChanged', update: 'update' }, (t, e) => {
    const i = e.getComponent('timeline');i && null != t.playState && i.setPlayState(t.playState);
  });var hC = ku.extend({ type: 'timeline', layoutMode: 'box', defaultOption: { zlevel: 0, z: 4, show: !0, axisType: 'time', realtime: !0, left: '20%', top: null, right: '20%', bottom: 0, width: null, height: 40, padding: 5, controlPosition: 'left', autoPlay: !1, rewind: !1, loop: !0, playInterval: 2e3, currentIndex: 0, itemStyle: {}, label: { color: '#000' }, data: [] }, init(t, e, i) {
    this._data, this._names, this.mergeDefaultAndTheme(t, i), this._initData();
  }, mergeOption(t) {
    hC.superApply(this, 'mergeOption', arguments), this._initData();
  }, setCurrentIndex(t) {
    null == t && (t = this.option.currentIndex);const e = this._data.count();this.option.loop ? t = (t % e + e) % e : (e <= t && (t = e - 1), t < 0 && (t = 0)), this.option.currentIndex = t;
  }, getCurrentIndex() {
    return this.option.currentIndex;
  }, isIndexMax() {
    return this.getCurrentIndex() >= this._data.count() - 1;
  }, setPlayState(t) {
    this.option.autoPlay = !!t;
  }, getPlayState() {
    return !!this.option.autoPlay;
  }, _initData() {
    const t = this.option; let e = t.data || []; const i = t.axisType; const o = this._names = [];if ('category' === i) {
      const a = [];R(e, (t, e) => {
        let i; let n = Wo(t);z(t) ? (i = k(t)).value = e : i = e, a.push(i), E(n) || null != n && !isNaN(n) || (n = ''), o.push(`${n}`);
      }), e = a;
    } const n = { category: 'ordinal', time: 'time' }[i] || 'number';(this._data = new Yf([{ name: 'value', type: n }], this)).initData(e, o);
  }, getData() {
    return this._data;
  }, getCategories() {
    if ('category' === this.get('axisType')) return this._names.slice();
  } });b(hC.extend({ type: 'timeline.slider', defaultOption: { backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', borderWidth: 0, orient: 'horizontal', inverse: !1, tooltip: { trigger: 'item' }, symbol: 'emptyCircle', symbolSize: 10, lineStyle: { show: !0, width: 2, color: '#304654' }, label: { position: 'auto', show: !0, interval: 'auto', rotate: 0, color: '#304654' }, itemStyle: { color: '#304654', borderWidth: 1 }, checkpointStyle: { symbol: 'circle', symbolSize: 13, color: '#c23531', borderWidth: 5, borderColor: 'rgba(194,53,49, 0.5)', animation: !0, animationDuration: 300, animationEasing: 'quinticInOut' }, controlStyle: { show: !0, showPlayBtn: !0, showPrevBtn: !0, showNextBtn: !0, itemSize: 22, itemGap: 12, position: 'left', playIcon: 'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z', stopIcon: 'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z', nextIcon: 'path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z', prevIcon: 'path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z', color: '#304654', borderColor: '#304654', borderWidth: 1 }, emphasis: { label: { show: !0, color: '#c23531' }, itemStyle: { color: '#c23531' }, controlStyle: { color: '#c23531', borderColor: '#c23531', borderWidth: 2 } }, data: [] } }), Xh);function cC(t, e, i, n) {
    Gg.call(this, t, e, i), this.type = n || 'value', this.model = null;
  } const dC = gc.extend({ type: 'timeline' });cC.prototype = { constructor: cC, getLabelModel() {
    return this.model.getModel('label');
  }, isHorizontal() {
    return 'horizontal' === this.model.get('orient');
  } }, w(cC, Gg);const fC = A; const pC = R; const gC = Math.PI;function mC(t, e, i, n, o, a) {
    const r = e.get('color');o ? (o.setColor(r), i.add(o), a && a.onUpdate(o)) : ((o = wg(t.get('symbol'), -1, -1, 2, 2, r)).setStyle('strokeNoScale', !0), i.add(o), a && a.onCreate(o));const s = e.getItemStyle(['color', 'symbol', 'symbolSize']);o.setStyle(s), n = m({ rectHover: !0, z2: 100 }, n, !0);let l = t.get('symbolSize');(l = l instanceof Array ? l.slice() : [+l, +l])[0] /= 2, l[1] /= 2, n.scale = l;const u = t.get('symbolOffset');if (u) {
      const h = n.position = n.position || [0, 0];h[0] += El(u[0], l[0]), h[1] += El(u[1], l[1]);
    } const c = t.get('symbolRotate');return n.rotation = (c || 0) * Math.PI / 180 || 0, o.attr(n), o.updateTransform(), o;
  } function vC(t, e, i, n, o) {
    if (!t.dragging) {
      const a = n.getModel('checkpointStyle'); const r = i.dataToCoord(n.getData().get(['value'], e));o || !a.get('animation', !0) ? t.attr({ position: [r, 0] }) : (t.stopAnimation(!0), t.animateTo({ position: [r, 0] }, a.get('animationDuration', !0), a.get('animationEasing', !0)));
    }
  }dC.extend({ type: 'timeline.slider', init(t, e) {
    this.api = e, this._axis, this._viewRect, this._timer, this._currentPointer, this._mainGroup, this._labelGroup;
  }, render(e, t, i, n) {
    if (this.model = e, this.api = i, this.ecModel = t, this.group.removeAll(), e.get('show', !0)) {
      const o = this._layout(e, i); const a = this._createGroup('mainGroup'); const r = this._createGroup('labelGroup'); const s = this._axis = this._createAxis(o, e);e.formatTooltip = function (t) {
        return au(s.scale.getLabel(t));
      }, pC(['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'], function (t) {
        this[`_render${t}`](o, a, s, e);
      }, this), this._renderAxisLabel(o, r, s, e), this._position(o, e);
    } this._doPlayStop();
  }, remove() {
    this._clearTimer(), this.group.removeAll();
  }, dispose() {
    this._clearTimer();
  }, _layout(t, e) {
    let i = t.get('label.position'); const n = t.get('orient'); const o = (function (t, e) {
      return bu(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }, t.get('padding'));
    }(t, e));null == i || 'auto' === i ? i = 'horizontal' === n ? o.y + o.height / 2 < e.getHeight() / 2 ? '-' : '+' : o.x + o.width / 2 < e.getWidth() / 2 ? '+' : '-' : isNaN(i) && (i = { horizontal: { top: '-', bottom: '+' }, vertical: { left: '-', right: '+' } }[n][i]);let a; let r; let s; let l; const u = { horizontal: 'center', vertical: 0 <= i || '+' === i ? 'left' : 'right' }; const h = { horizontal: 0 <= i || '+' === i ? 'top' : 'bottom', vertical: 'middle' }; const c = { horizontal: 0, vertical: gC / 2 }; const d = 'vertical' === n ? o.height : o.width; const f = t.getModel('controlStyle'); const p = f.get('show', !0); const g = p ? f.get('itemSize') : 0; const m = p ? f.get('itemGap') : 0; const v = g + m; let y = t.get('label.rotate') || 0;y = y * gC / 180;const x = f.get('position', !0); const _ = p && f.get('showPlayBtn', !0); const w = p && f.get('showPrevBtn', !0); const b = p && f.get('showNextBtn', !0); let S = 0; let M = d;return 'left' === x || 'bottom' === x ? (_ && (a = [0, 0], S += v), w && (r = [S, 0], S += v)) : (_ && (a = [M - g, 0], M -= v), w && (r = [0, 0], S += v)), b && (s = [M - g, 0], M -= v), l = [S, M], t.get('inverse') && l.reverse(), { viewRect: o, mainLength: d, orient: n, rotation: c[n], labelRotation: y, labelPosOpt: i, labelAlign: t.get('label.align') || u[n], labelBaseline: t.get('label.verticalAlign') || t.get('label.baseline') || h[n], playPosition: a, prevBtnPosition: r, nextBtnPosition: s, axisExtent: l, controlSize: g, controlGap: m };
  }, _position(t, e) {
    const i = this._mainGroup; const n = this._labelGroup; let o = t.viewRect;if ('vertical' === t.orient) {
      const a = ae(); const r = o.x; const s = o.y + o.height;ue(a, a, [-r, -s]), he(a, a, -gC / 2), ue(a, a, [r, s]), (o = o.clone()).applyTransform(a);
    } const l = m(o); const u = m(i.getBoundingRect()); const h = m(n.getBoundingRect()); const c = i.position; const d = n.position;d[0] = c[0] = l[0][0];let f; const p = t.labelPosOpt;isNaN(p) ? (v(c, u, l, 1, f = '+' === p ? 0 : 1), v(d, h, l, 1, 1 - f)) : (v(c, u, l, 1, f = 0 <= p ? 0 : 1), d[1] = c[1] + p);function g(t) {
      const e = t.position;t.origin = [l[0][0] - e[0], l[1][0] - e[1]];
    } function m(t) {
      return [[t.x, t.x + t.width], [t.y, t.y + t.height]];
    } function v(t, e, i, n, o) {
      t[n] += i[n][o] - e[n][o];
    }i.attr('position', c), n.attr('position', d), i.rotation = n.rotation = t.rotation, g(i), g(n);
  }, _createAxis(t, e) {
    const i = e.getData(); const n = e.get('axisType'); const o = sg(e, n);o.getTicks = function () {
      return i.mapArray(['value'], t => t);
    };const a = i.getDataExtent('value');o.setExtent(a[0], a[1]), o.niceTicks();const r = new cC('value', o, t.axisExtent, n);return r.model = e, r;
  }, _createGroup(t) {
    const e = this[`_${t}`] = new Ci;return this.group.add(e), e;
  }, _renderAxisLine(t, e, i, n) {
    const o = i.getExtent();n.get('lineStyle.show') && e.add(new ls({ shape: { x1: o[0], y1: 0, x2: o[1], y2: 0 }, style: P({ lineCap: 'round' }, n.getModel('lineStyle').getLineStyle()), silent: !0, z2: 1 }));
  }, _renderAxisTick(t, s, l, u) {
    const h = u.getData(); const e = l.scale.getTicks();pC(e, function (t) {
      const e = l.dataToCoord(t); const i = h.getItemModel(t); const n = i.getModel('itemStyle'); const o = i.getModel('emphasis.itemStyle'); const a = { position: [e, 0], onclick: fC(this._changeTimeline, this, t) }; const r = mC(i, n, s, a);$s(r, o.getItemStyle()), i.get('tooltip') ? (r.dataIndex = t, r.dataModel = u) : r.dataIndex = r.dataModel = null;
    }, this);
  }, _renderAxisLabel(s, l, u, t) {
    if (u.getLabelModel().get('show')) {
      const h = t.getData(); const e = u.getViewLabels();pC(e, function (t) {
        const e = t.tickValue; const i = h.getItemModel(e); const n = i.getModel('label'); const o = i.getModel('emphasis.label'); const a = u.dataToCoord(t.tickValue); const r = new Ur({ position: [a, 0], rotation: s.labelRotation - s.rotation, onclick: fC(this._changeTimeline, this, e), silent: !1 });nl(r.style, n, { text: t.formattedLabel, textAlign: s.labelAlign, textVerticalAlign: s.labelBaseline }), l.add(r), $s(r, nl({}, o));
      }, this);
    }
  }, _renderControl(t, a, e, r) {
    const s = t.controlSize; const l = t.rotation; const u = r.getModel('controlStyle').getItemStyle(); const h = r.getModel('emphasis.controlStyle').getItemStyle(); const c = [0, -s / 2, s, s]; const i = r.getPlayState(); const n = r.get('inverse', !0);function o(t, e, i, n) {
      if (t) {
        const o = (function (t, e, i, n) {
          const o = n.style; const a = yl(t.get(e), n || {}, new Di(i[0], i[1], i[2], i[3]));o && a.setStyle(o);return a;
        }(r, e, c, { position: t, origin: [s / 2, 0], rotation: n ? -l : 0, rectHover: !0, style: u, onclick: i }));a.add(o), $s(o, h);
      }
    }o(t.nextBtnPosition, 'controlStyle.nextIcon', fC(this._changeTimeline, this, n ? '-' : '+')), o(t.prevBtnPosition, 'controlStyle.prevIcon', fC(this._changeTimeline, this, n ? '+' : '-')), o(t.playPosition, `controlStyle.${i ? 'stopIcon' : 'playIcon'}`, fC(this._handlePlayClick, this, !i), !0);
  }, _renderCurrentPointer(t, e, i, n) {
    const o = n.getData(); const a = n.getCurrentIndex(); const r = o.getItemModel(a).getModel('checkpointStyle'); const s = this; const l = { onCreate(t) {
      t.draggable = !0, t.drift = fC(s._handlePointerDrag, s), t.ondragend = fC(s._handlePointerDragend, s), vC(t, a, i, n, !0);
    }, onUpdate(t) {
      vC(t, a, i, n);
    } };this._currentPointer = mC(r, r, this._mainGroup, {}, this._currentPointer, l);
  }, _handlePlayClick(t) {
    this._clearTimer(), this.api.dispatchAction({ type: 'timelinePlayChange', playState: t, from: this.uid });
  }, _handlePointerDrag(t, e, i) {
    this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY]);
  }, _handlePointerDragend(t) {
    this._pointerChangeTimeline([t.offsetX, t.offsetY], !0);
  }, _pointerChangeTimeline(t, e) {
    let i = this._toAxisCoord(t)[0]; const n = Bl(this._axis.getExtent().slice());i > n[1] && (i = n[1]), i < n[0] && (i = n[0]), this._currentPointer.position[0] = i, this._currentPointer.dirty();const o = this._findNearestTick(i); const a = this.model;(e || o !== a.getCurrentIndex() && a.get('realtime')) && this._changeTimeline(o);
  }, _doPlayStop() {
    this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(fC(function () {
      const t = this.model;this._changeTimeline(t.getCurrentIndex() + (t.get('rewind', !0) ? -1 : 1));
    }, this), this.model.get('playInterval')));
  }, _toAxisCoord(t) {
    return pl(t, this._mainGroup.getLocalTransform(), !0);
  }, _findNearestTick(o) {
    let a; const t = this.model.getData(); let r = 1 / 0; const s = this._axis;return t.each(['value'], (t, e) => {
      const i = s.dataToCoord(t); const n = Math.abs(i - o);n < r && (r = n, a = e);
    }), a;
  }, _clearTimer() {
    this._timer && (clearTimeout(this._timer), this._timer = null);
  }, _changeTimeline(t) {
    const e = this.model.getCurrentIndex();'+' === t ? t = e + 1 : '-' === t && (t = e - 1), this.api.dispatchAction({ type: 'timelineChange', currentIndex: t, from: this.uid });
  } }), yf((t) => {
    let e = t && t.timeline;L(e) || (e = e ? [e] : []), R(e, (t) => {
      t && (function (t) {
        const e = t.type; const i = { number: 'value', time: 'time' };i[e] && (t.axisType = i[e], delete t.type);if (lC(t), uC(t, 'controlPosition')) {
          const n = t.controlStyle || (t.controlStyle = {});uC(n, 'position') || (n.position = t.controlPosition), 'none' !== n.position || uC(n, 'show') || (n.show = !1, delete n.position), delete t.controlPosition;
        }R(t.data || [], (t) => {
          z(t) && !L(t) && (!uC(t, 'value') && uC(t, 'name') && (t.value = t.name), lC(t));
        });
      }(t));
    });
  });const yC = tu; const xC = au;function _C(t) {
    Go(t, 'label', ['show']);
  } const wC = Tf({ type: 'marker', dependencies: ['series', 'grid', 'polar', 'geo'], init(t, e, i) {
    this.mergeDefaultAndTheme(t, i), this._mergeOption(t, i, !1, !0);
  }, isAnimationEnabled() {
    if (v.node) return !1;const t = this.__hostSeries;return this.getShallow('animation') && t && t.isAnimationEnabled();
  }, mergeOption(t, e) {
    this._mergeOption(t, e, !1, !1);
  }, _mergeOption(t, n, e, o) {
    const a = this.constructor; const r = `${this.mainType}Model`;e || n.eachSeries(function (t) {
      const e = t.get(this.mainType, !0); let i = t[r];e && e.data ? (i ? i._mergeOption(e, n, !0) : (o && _C(e), R(e.data, (t) => {
        t instanceof Array ? (_C(t[0]), _C(t[1])) : _C(t);
      }), P(i = new a(e, this, n), { mainType: this.mainType, seriesIndex: t.seriesIndex, name: t.name, createdBySelf: !0 }), i.__hostSeries = t), t[r] = i) : t[r] = null;
    }, this);
  }, formatTooltip(t, e, i, n) {
    const o = this.getData(); const a = this.getRawValue(t); const r = L(a) ? O(a, yC).join(', ') : yC(a); const s = o.getName(t); let l = xC(this.name);return null == a && !s || (l += 'html' === n ? '<br/>' : '\n'), s && (l += xC(s), null != a && (l += ' : ')), null != a && (l += xC(r)), l;
  }, getData() {
    return this._data;
  }, setData(t) {
    this._data = t;
  } });b(wC, Xh), wC.extend({ type: 'markPoint', defaultOption: { zlevel: 0, z: 5, symbol: 'pin', symbolSize: 50, tooltip: { trigger: 'item' }, label: { show: !0, position: 'inside' }, itemStyle: { borderWidth: 2 }, emphasis: { label: { show: !0 } } } });const bC = _;function SC(t, e, i, n, o, a) {
    const r = []; const s = fp(e, n) ? e.getCalculationInfo('stackResultDimension') : n; const l = LC(e, s, t); const u = e.indicesOfNearest(s, l)[0];r[o] = e.get(i, u), r[a] = e.get(s, u);const h = e.get(n, u); let c = Vl(e.get(n, u));return 0 <= (c = Math.min(c, 20)) && (r[a] = +r[a].toFixed(c)), [r, h];
  } const MC = T; const IC = { min: MC(SC, 'min'), max: MC(SC, 'max'), average: MC(SC, 'average') };function TC(t, e) {
    const i = t.getData(); const n = t.coordinateSystem;if (e && !(function (t) {
      return !isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y));
    }(e)) && !L(e.coord) && n) {
      const o = n.dimensions; const a = AC(e, i, n, t);if ((e = k(e)).type && IC[e.type] && a.baseAxis && a.valueAxis) {
        const r = bC(o, a.baseAxis.dim); const s = bC(o, a.valueAxis.dim); const l = IC[e.type](i, a.baseDataDim, a.valueDataDim, r, s);e.coord = l[0], e.value = l[1];
      } else {
        for (var u = [null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis], h = 0;h < 2;h++)IC[u[h]] && (u[h] = LC(i, i.mapDimension(o[h]), u[h]));e.coord = u;
      }
    } return e;
  } function AC(t, e, i, n) {
    const o = {};return null != t.valueIndex || null != t.valueDim ? (o.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, o.valueAxis = i.getAxis(function (t, e) {
      const i = t.getData(); const n = i.dimensions;e = i.getDimension(e);for (let o = 0;o < n.length;o++) {
        const a = i.getDimensionInfo(n[o]);if (a.name === e) return a.coordDim;
      }
    }(n, o.valueDataDim)), o.baseAxis = i.getOtherAxis(o.valueAxis), o.baseDataDim = e.mapDimension(o.baseAxis.dim)) : (o.baseAxis = n.getBaseAxis(), o.valueAxis = i.getOtherAxis(o.baseAxis), o.baseDataDim = e.mapDimension(o.baseAxis.dim), o.valueDataDim = e.mapDimension(o.valueAxis.dim)), o;
  } function DC(t, e) {
    return !(t && t.containData && e.coord && !(function (t) {
      return !(isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y)));
    }(e))) || t.containData(e.coord);
  } function CC(t, e, i, n) {
    return n < 2 ? t.coord && t.coord[n] : t.value;
  } function LC(t, e, i) {
    if ('average' !== i) return 'median' === i ? t.getMedian(e) : t.getDataExtent(e, !0)['max' === i ? 1 : 0];let n = 0; let o = 0;return t.each(e, (t, e) => {
      isNaN(t) || (n += t, o++);
    }), n / o;
  } const kC = Af({ type: 'marker', init() {
    this.markerGroupMap = Q();
  }, render(t, i, n) {
    const e = this.markerGroupMap;e.each((t) => {
      t.__keep = !1;
    });const o = `${this.type}Model`;i.eachSeries(function (t) {
      const e = t[o];e && this.renderSeries(t, e, i, n);
    }, this), e.each(function (t) {
      t.__keep || this.group.remove(t.group);
    }, this);
  }, renderSeries() {} });function PC(s, l, u) {
    const h = l.coordinateSystem;s.each((t) => {
      let e; const i = s.getItemModel(t); const n = El(i.get('x'), u.getWidth()); const o = El(i.get('y'), u.getHeight());if (isNaN(n) || isNaN(o)) {
        if (l.getMarkerPosition)e = l.getMarkerPosition(s.getValues(s.dimensions, t));else if (h) {
          const a = s.get(h.dimensions[0], t); const r = s.get(h.dimensions[1], t);e = h.dataToPoint([a, r]);
        }
      } else e = [n, o];isNaN(n) || (e[0] = n), isNaN(o) || (e[1] = o), s.setItemLayout(t, e);
    });
  }kC.extend({ type: 'markPoint', updateTransform(t, e, i) {
    e.eachSeries(function (t) {
      const e = t.markPointModel;e && (PC(e.getData(), t, i), this.markerGroupMap.get(t.id).updateLayout(e));
    }, this);
  }, renderSeries(t, h, e, i) {
    const n = t.coordinateSystem; const o = t.id; const c = t.getData(); const a = this.markerGroupMap; const r = a.get(o) || a.set(o, new im); const d = (function (t, e, i) {
      let n;n = t ? O(t && t.dimensions, t => D({ name: t }, e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {})) : [{ name: 'value', type: 'float' }];const o = new Yf(n, i); let a = O(i.get('data'), T(TC, e));t && (a = M(a, T(DC, t)));return o.initData(a, null, t ? CC : t => t.value), o;
    }(n, t, h));h.setData(d), PC(h.getData(), t, i), d.each((t) => {
      const e = d.getItemModel(t); let i = e.getShallow('symbol'); let n = e.getShallow('symbolSize'); let o = e.getShallow('symbolRotate'); const a = C(i); const r = C(n); const s = C(o);if (a || r || s) {
        const l = h.getRawValue(t); const u = h.getDataParams(t);a && (i = i(l, u)), r && (n = n(l, u)), s && (o = o(l, u));
      }d.setItemVisual(t, { symbol: i, symbolSize: n, symbolRotate: o, color: e.get('itemStyle.color') || c.getVisual('color') });
    }), r.updateData(d), this.group.add(r.group), d.eachItemGraphicEl((t) => {
      t.traverse((t) => {
        t.dataModel = h;
      });
    }), r.__keep = !0, r.group.silent = h.get('silent') || t.get('silent');
  } }), yf((t) => {
    t.markPoint = t.markPoint || {};
  }), wC.extend({ type: 'markLine', defaultOption: { zlevel: 0, z: 5, symbol: ['circle', 'arrow'], symbolSize: [8, 16], precision: 2, tooltip: { trigger: 'item' }, label: { show: !0, position: 'end', distance: 5 }, lineStyle: { type: 'dashed' }, emphasis: { label: { show: !0 }, lineStyle: { width: 3 } }, animationEasing: 'linear' } });function NC(t, e, i, n) {
    const o = t.getData(); const a = n.type;if (!L(n) && ('min' === a || 'max' === a || 'average' === a || 'median' === a || null != n.xAxis || null != n.yAxis)) {
      let r; let s;if (null != n.yAxis || null != n.xAxis)r = e.getAxis(null != n.yAxis ? 'y' : 'x'), s = W(n.yAxis, n.xAxis);else {
        const l = AC(n, o, e, t);r = l.valueAxis, s = LC(o, pp(o, l.valueDataDim), a);
      } const u = 'x' === r.dim ? 0 : 1; const h = 1 - u; const c = k(n); const d = {};c.type = null, c.coord = [], d.coord = [], c.coord[h] = -1 / 0, d.coord[h] = 1 / 0;const f = i.get('precision');0 <= f && 'number' === typeof s && (s = +s.toFixed(Math.min(f, 20))), c.coord[u] = d.coord[u] = s, n = [c, d, { type: a, valueIndex: n.valueIndex, value: s }];
    } return (n = [TC(t, n[0]), TC(t, n[1]), P({}, n[2])])[2].type = n[2].type || '', m(n[2], n[0]), m(n[2], n[1]), n;
  } function OC(t) {
    return !isNaN(t) && !isFinite(t);
  } function RC(t, e, i, n) {
    const o = 1 - t; const a = n.dimensions[t];return OC(e[o]) && OC(i[o]) && e[t] === i[t] && n.getAxis(a).containData(e[t]);
  } function EC(t, e) {
    if ('cartesian2d' === t.type) {
      const i = e[0].coord; const n = e[1].coord;if (i && n && (RC(1, i, n, t) || RC(0, i, n, t))) return !0;
    } return DC(t, e[0]) && DC(t, e[1]);
  } function zC(t, e, i, n, o) {
    let a; const r = n.coordinateSystem; const s = t.getItemModel(e); const l = El(s.get('x'), o.getWidth()); const u = El(s.get('y'), o.getHeight());if (isNaN(l) || isNaN(u)) {
      if (n.getMarkerPosition)a = n.getMarkerPosition(t.getValues(t.dimensions, e));else {
        var h = r.dimensions; const c = t.get(h[0], e); const d = t.get(h[1], e);a = r.dataToPoint([c, d]);
      } if ('cartesian2d' === r.type) {
        const f = r.getAxis('x'); const p = r.getAxis('y');h = r.dimensions;OC(t.get(h[0], e)) ? a[0] = f.toGlobalCoord(f.getExtent()[i ? 0 : 1]) : OC(t.get(h[1], e)) && (a[1] = p.toGlobalCoord(p.getExtent()[i ? 0 : 1]));
      }isNaN(l) || (a[0] = l), isNaN(u) || (a[1] = u);
    } else a = [l, u];t.setItemLayout(e, a);
  }kC.extend({ type: 'markLine', updateTransform(t, e, a) {
    e.eachSeries(function (e) {
      const t = e.markLineModel;if (t) {
        const i = t.getData(); const n = t.__from; const o = t.__to;n.each((t) => {
          zC(n, t, !0, e, a), zC(o, t, !1, e, a);
        }), i.each((t) => {
          i.setItemLayout(t, [n.getItemLayout(t), o.getItemLayout(t)]);
        }), this.markerGroupMap.get(e.id).updateLayout();
      }
    }, this);
  }, renderSeries(o, i, t, a) {
    const e = o.coordinateSystem; const n = o.id; const r = o.getData(); const s = this.markerGroupMap; const l = s.get(n) || s.set(n, new Sw);this.group.add(l.group);const u = (function (t, e, i) {
      let n;n = t ? O(t && t.dimensions, t => D({ name: t }, e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {})) : [{ name: 'value', type: 'float' }];const o = new Yf(n, i); const a = new Yf(n, i); const r = new Yf([], i); let s = O(i.get('data'), T(NC, e, t, i));t && (s = M(s, T(EC, t)));const l = t ? CC : function (t) {
        return t.value;
      };return o.initData(O(s, t => t[0]), null, l), a.initData(O(s, t => t[1]), null, l), r.initData(O(s, t => t[2])), r.hasItemOption = !0, { from: o, to: a, line: r };
    }(e, o, i)); const h = u.from; const c = u.to; const d = u.line;i.__from = h, i.__to = c, i.setData(d);let f = i.get('symbol'); let p = i.get('symbolSize');function g(t, e, i) {
      const n = t.getItemModel(e);zC(t, e, i, o, a), t.setItemVisual(e, { symbolRotate: n.get('symbolRotate'), symbolSize: n.get('symbolSize') || p[i ? 0 : 1], symbol: n.get('symbol', !0) || f[i ? 0 : 1], color: n.get('itemStyle.color') || r.getVisual('color') });
    }L(f) || (f = [f, f]), 'number' === typeof p && (p = [p, p]), u.from.each((t) => {
      g(h, t, !0), g(c, t, !1);
    }), d.each((t) => {
      const e = d.getItemModel(t).get('lineStyle.color');d.setItemVisual(t, { color: e || h.getItemVisual(t, 'color') }), d.setItemLayout(t, [h.getItemLayout(t), c.getItemLayout(t)]), d.setItemVisual(t, { fromSymbolRotate: h.getItemVisual(t, 'symbolRotate'), fromSymbolSize: h.getItemVisual(t, 'symbolSize'), fromSymbol: h.getItemVisual(t, 'symbol'), toSymbolRotate: c.getItemVisual(t, 'symbolRotate'), toSymbolSize: c.getItemVisual(t, 'symbolSize'), toSymbol: c.getItemVisual(t, 'symbol') });
    }), l.updateData(d), u.line.eachItemGraphicEl((t, e) => {
      t.traverse((t) => {
        t.dataModel = i;
      });
    }), l.__keep = !0, l.group.silent = i.get('silent') || o.get('silent');
  } }), yf((t) => {
    t.markLine = t.markLine || {};
  }), wC.extend({ type: 'markArea', defaultOption: { zlevel: 0, z: 1, tooltip: { trigger: 'item' }, animation: !1, label: { show: !0, position: 'top' }, itemStyle: { borderWidth: 0 }, emphasis: { label: { show: !0, position: 'top' } } } });function BC(t, e, i, n) {
    const o = TC(t, n[0]); const a = TC(t, n[1]); const r = W; const s = o.coord; const l = a.coord;s[0] = r(s[0], -1 / 0), s[1] = r(s[1], -1 / 0), l[0] = r(l[0], 1 / 0), l[1] = r(l[1], 1 / 0);const u = p([{}, o, a]);return u.coord = [o.coord, a.coord], u.x0 = o.x, u.y0 = o.y, u.x1 = a.x, u.y1 = a.y, u;
  } function VC(t) {
    return !isNaN(t) && !isFinite(t);
  } function GC(t, e, i) {
    const n = 1 - t;return VC(e[n]) && VC(i[n]);
  } function FC(t, e) {
    const i = e.coord[0]; const n = e.coord[1];return !('cartesian2d' !== t.type || !i || !n || !GC(1, i, n) && !GC(0, i, n)) || (DC(t, { coord: i, x: e.x0, y: e.y0 }) || DC(t, { coord: n, x: e.x1, y: e.y1 }));
  } function WC(t, e, i, n, o) {
    let a; const r = n.coordinateSystem; const s = t.getItemModel(e); const l = El(s.get(i[0]), o.getWidth()); const u = El(s.get(i[1]), o.getHeight());if (isNaN(l) || isNaN(u)) {
      if (n.getMarkerPosition)a = n.getMarkerPosition(t.getValues(i, e));else {
        const h = [f = t.get(i[0], e), p = t.get(i[1], e)];r.clampData && r.clampData(h, h), a = r.dataToPoint(h, !0);
      } if ('cartesian2d' === r.type) {
        const c = r.getAxis('x'); const d = r.getAxis('y'); var f = t.get(i[0], e); var p = t.get(i[1], e);VC(f) ? a[0] = c.toGlobalCoord(c.getExtent()['x0' === i[0] ? 0 : 1]) : VC(p) && (a[1] = d.toGlobalCoord(d.getExtent()['y0' === i[1] ? 0 : 1]));
      }isNaN(l) || (a[0] = l), isNaN(u) || (a[1] = u);
    } else a = [l, u];return a;
  } const HC = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];kC.extend({ type: 'markArea', updateTransform(t, e, o) {
    e.eachSeries((i) => {
      const t = i.markAreaModel;if (t) {
        const n = t.getData();n.each((e) => {
          const t = O(HC, t => WC(n, e, t, i, o));n.setItemLayout(e, t), n.getItemGraphicEl(e).setShape('points', t);
        });
      }
    }, this);
  }, renderSeries(e, r, t, i) {
    const a = e.coordinateSystem; const n = e.id; const s = e.getData(); const o = this.markerGroupMap; const l = o.get(n) || o.set(n, { group: new Ci });this.group.add(l.group), l.__keep = !0;const u = (function (t, i, e) {
      let n; let o;o = t ? (n = O(t && t.dimensions, (t) => {
        const e = i.getData();return D({ name: t }, e.getDimensionInfo(e.mapDimension(t)) || {});
      }), new Yf(O(['x0', 'y0', 'x1', 'y1'], (t, e) => ({ name: t, type: n[e % 2].type })), e)) : new Yf(n = [{ name: 'value', type: 'float' }], e);let a = O(e.get('data'), T(BC, i, t, e));t && (a = M(a, T(FC, t)));const r = t ? function (t, e, i, n) {
        return t.coord[Math.floor(n / 2)][n % 2];
      } : function (t) {
        return t.value;
      };return o.initData(a, null, r), o.hasItemOption = !0, o;
    }(a, e, r));r.setData(u), u.each((n) => {
      const t = O(HC, t => WC(u, n, t, e, i)); let o = !0;R(HC, (t) => {
        if (o) {
          const e = u.get(t[0], n); const i = u.get(t[1], n);(VC(e) || a.getAxis('x').containData(e)) && (VC(i) || a.getAxis('y').containData(i)) && (o = !1);
        }
      }), u.setItemLayout(n, { points: t, allClipped: o }), u.setItemVisual(n, { color: s.getVisual('color') });
    }), u.diff(l.__data).add((t) => {
      const e = u.getItemLayout(t);if (!e.allClipped) {
        const i = new Qr({ shape: { points: e.points } });u.setItemGraphicEl(t, i), l.group.add(i);
      }
    })
      .update((t, e) => {
        let i = l.__data.getItemGraphicEl(e); const n = u.getItemLayout(t);n.allClipped ? i && l.group.remove(i) : (i ? cl(i, { shape: { points: n.points } }, r, t) : i = new Qr({ shape: { points: n.points } }), u.setItemGraphicEl(t, i), l.group.add(i));
      })
      .remove((t) => {
        const e = l.__data.getItemGraphicEl(t);l.group.remove(e);
      })
      .execute(), u.eachItemGraphicEl((t, e) => {
      const i = u.getItemModel(e); const n = i.getModel('label'); const o = i.getModel('emphasis.label'); const a = u.getItemVisual(e, 'color');t.useStyle(D(i.getModel('itemStyle').getItemStyle(), { fill: Ke(a, .4), stroke: a })), t.hoverStyle = i.getModel('emphasis.itemStyle').getItemStyle(), el(t.style, t.hoverStyle, n, o, { labelFetcher: r, labelDataIndex: e, defaultText: u.getName(e) || '', isRectText: !0, autoColor: a }), $s(t, {}), t.dataModel = r;
    }), l.__data = u, l.group.silent = r.get('silent') || e.get('silent');
  } }), yf((t) => {
    t.markArea = t.markArea || {};
  });const ZC = Oc.legend.selector; const UC = { all: { type: 'all', title: k(ZC.all) }, inverse: { type: 'inverse', title: k(ZC.inverse) } }; var XC = Tf({ type: 'legend.plain', dependencies: ['series'], layoutMode: { type: 'box', ignoreSize: !0 }, init(t, e, i) {
    this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}, this._updateSelector(t);
  }, mergeOption(t) {
    XC.superCall(this, 'mergeOption', t), this._updateSelector(t);
  }, _updateSelector(t) {
    let i = t.selector;!0 === i && (i = t.selector = ['all', 'inverse']), L(i) && R(i, (t, e) => {
      E(t) && (t = { type: t }), i[e] = m(t, UC[t.type]);
    });
  }, optionUpdated() {
    this._updateData(this.ecModel);const t = this._data;if (t[0] && 'single' === this.get('selectedMode')) {
      for (var e = !1, i = 0;i < t.length;i++) {
        const n = t[i].get('name');if (this.isSelected(n)) {
          this.select(n), e = !0;break;
        }
      }e || this.select(t[0].get('name'));
    }
  }, _updateData(o) {
    let a = []; let r = [];o.eachRawSeries((t) => {
      let e; const i = t.name;if (r.push(i), t.legendVisualProvider) {
        const n = t.legendVisualProvider.getAllNames();o.isSeriesFiltered(t) || (r = r.concat(n)), n.length ? a = a.concat(n) : e = !0;
      } else e = !0;e && Uo(t) && a.push(t.name);
    }), this._availableNames = r;const t = O(this.get('data') || a, function (t) {
      return 'string' !== typeof t && 'number' !== typeof t || (t = { name: t }), new Cl(t, this, this.ecModel);
    }, this);this._data = t;
  }, getData() {
    return this._data;
  }, select(t) {
    const e = this.option.selected;'single' === this.get('selectedMode') && R(this._data, (t) => {
      e[t.get('name')] = !1;
    });e[t] = !0;
  }, unSelect(t) {
    'single' !== this.get('selectedMode') && (this.option.selected[t] = !1);
  }, toggleSelected(t) {
    const e = this.option.selected;e.hasOwnProperty(t) || (e[t] = !0), this[e[t] ? 'unSelect' : 'select'](t);
  }, allSelect() {
    const t = this._data; const e = this.option.selected;R(t, (t) => {
      e[t.get('name', !0)] = !0;
    });
  }, inverseSelect() {
    const t = this._data; const i = this.option.selected;R(t, (t) => {
      const e = t.get('name', !0);i.hasOwnProperty(e) || (i[e] = !0), i[e] = !i[e];
    });
  }, isSelected(t) {
    const e = this.option.selected;return !(e.hasOwnProperty(t) && !e[t]) && 0 <= _(this._availableNames, t);
  }, getOrient() {
    return 'vertical' === this.get('orient') ? { index: 1, name: 'vertical' } : { index: 0, name: 'horizontal' };
  }, defaultOption: { zlevel: 0, z: 4, show: !0, orient: 'horizontal', left: 'center', top: 0, align: 'auto', backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', borderRadius: 0, borderWidth: 0, padding: 5, itemGap: 10, itemWidth: 25, itemHeight: 14, inactiveColor: '#ccc', inactiveBorderColor: '#ccc', itemStyle: { borderWidth: 0 }, textStyle: { color: '#333' }, selectedMode: !0, selector: !1, selectorLabel: { show: !0, borderRadius: 10, padding: [3, 5, 3, 5], fontSize: 12, fontFamily: ' sans-serif', color: '#666', borderWidth: 1, borderColor: '#666' }, emphasis: { selectorLabel: { show: !0, color: '#eee', backgroundColor: '#666' } }, selectorPosition: 'auto', selectorItemGap: 7, selectorButtonGap: 10, tooltip: { show: !1 } } });function YC(t, e, i) {
    let o; const a = {}; const r = 'toggleSelected' === t;return i.eachComponent('legend', (n) => {
      r && null != o ? n[o ? 'select' : 'unSelect'](e.name) : 'allSelect' === t || 'inverseSelect' === t ? n[t]() : (n[t](e.name), o = n.isSelected(e.name)), R(n.getData(), (t) => {
        const e = t.get('name');if ('\n' !== e && '' !== e) {
          const i = n.isSelected(e);a.hasOwnProperty(e) ? a[e] = a[e] && i : a[e] = i;
        }
      });
    }), 'allSelect' === t || 'inverseSelect' === t ? { selected: a } : { name: e.name, selected: a };
  }_f('legendToggleSelect', 'legendselectchanged', T(YC, 'toggleSelected')), _f('legendAllSelect', 'legendselectall', T(YC, 'allSelect')), _f('legendInverseSelect', 'legendinverseselect', T(YC, 'inverseSelect')), _f('legendSelect', 'legendselected', T(YC, 'select')), _f('legendUnSelect', 'legendunselected', T(YC, 'unSelect'));const jC = T; const qC = R; const KC = Ci; const $C = Af({ type: 'legend.plain', newlineDisabled: !1, init() {
    this.group.add(this._contentGroup = new KC), this._backgroundEl, this.group.add(this._selectorGroup = new KC), this._isFirstRender = !0;
  }, getContentGroup() {
    return this._contentGroup;
  }, getSelectorGroup() {
    return this._selectorGroup;
  }, render(t, e, i) {
    const n = this._isFirstRender;if (this._isFirstRender = !1, this.resetInner(), t.get('show', !0)) {
      let o = t.get('align'); const a = t.get('orient');o && 'auto' !== o || (o = 'right' === t.get('left') && 'vertical' === a ? 'right' : 'left');const r = t.get('selector', !0); let s = t.get('selectorPosition', !0);!r || s && 'auto' !== s || (s = 'horizontal' === a ? 'end' : 'start'), this.renderInner(o, t, e, i, r, a, s);const l = t.getBoxLayoutParams(); const u = { width: i.getWidth(), height: i.getHeight() }; const h = t.get('padding'); const c = bu(l, u, h); const d = this.layoutInner(t, o, c, n, r, s); const f = bu(D({ width: d.width, height: d.height }, l), u, h);this.group.attr('position', [f.x - d.x, f.y - d.y]), this.group.add(this._backgroundEl = gA(d, t));
    }
  }, resetInner() {
    this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
  }, renderInner(u, h, c, d, t, e, i) {
    const f = this.getContentGroup(); const p = Q(); const g = h.get('selectedMode'); const m = [];c.eachRawSeries((t) => {
      t.get('legendHoverLink') || m.push(t.id);
    }), qC(h.getData(), function (a, r) {
      const s = a.get('name');if (this.newlineDisabled || '' !== s && '\n' !== s) {
        const t = c.getSeriesByName(s)[0];if (!p.get(s)) if (t) {
          const e = t.getData(); let i = e.getVisual('color'); let n = e.getVisual('borderColor');'function' === typeof i && (i = i(t.getDataParams(0))), 'function' === typeof n && (n = n(t.getDataParams(0)));const o = e.getVisual('legendSymbol') || 'roundRect'; const l = e.getVisual('symbol');this._createItem(s, r, a, h, o, l, u, i, n, g).on('click', jC(QC, s, null, d, m))
            .on('mouseover', jC(tL, t.name, null, d, m))
            .on('mouseout', jC(eL, t.name, null, d, m)), p.set(s, !0);
        } else c.eachRawSeries(function (t) {
          if (!p.get(s) && t.legendVisualProvider) {
            const e = t.legendVisualProvider;if (!e.containName(s)) return;const i = e.indexOfName(s); const n = e.getItemVisual(i, 'color'); const o = e.getItemVisual(i, 'borderColor');this._createItem(s, r, a, h, 'roundRect', null, u, n, o, g).on('click', jC(QC, null, s, d, m))
              .on('mouseover', jC(tL, null, s, d, m))
              .on('mouseout', jC(eL, null, s, d, m)), p.set(s, !0);
          }
        }, this);
      } else f.add(new KC({ newline: !0 }));
    }, this), t && this._createSelector(t, h, d, e, i);
  }, _createSelector(t, a, r, e, i) {
    const s = this.getSelectorGroup();qC(t, (t) => {
      !(function (t) {
        const e = t.type; const i = new Ur({ style: { x: 0, y: 0, align: 'center', verticalAlign: 'middle' }, onclick() {
          r.dispatchAction({ type: 'all' === e ? 'legendAllSelect' : 'legendInverseSelect' });
        } });s.add(i);const n = a.getModel('selectorLabel'); const o = a.getModel('emphasis.selectorLabel');el(i.style, i.hoverStyle = {}, n, o, { defaultText: t.title, isRectText: !1 }), $s(i);
      }(t));
    });
  }, _createItem(t, e, i, n, o, a, r, s, l, u) {
    const h = n.get('itemWidth'); const c = n.get('itemHeight'); const d = n.get('inactiveColor'); const f = n.get('inactiveBorderColor'); const p = n.get('symbolKeepAspect'); const g = n.getModel('itemStyle'); const m = n.isSelected(t); const v = new KC; const y = i.getModel('textStyle'); const x = i.get('icon'); const _ = i.getModel('tooltip'); const w = _.parentModel; const b = wg(o = x || o, 0, 0, h, c, m ? s : d, null == p || p);if (v.add(JC(b, o, g, l, f, m)), !x && a && (a !== o || 'none' === a)) {
      const S = .8 * c;'none' === a && (a = 'circle');const M = wg(a, (h - S) / 2, (c - S) / 2, S, S, m ? s : d, null == p || p);v.add(JC(M, a, g, l, f, m));
    } const I = 'left' === r ? h + 5 : -5; const T = r; const A = n.get('formatter'); let D = t;'string' === typeof A && A ? D = A.replace('{name}', null != t ? t : '') : 'function' === typeof A && (D = A(t)), v.add(new Ur({ style: nl({}, y, { text: D, x: I, y: c / 2, textFill: m ? y.getTextColor() : d, textAlign: T, textVerticalAlign: 'middle' }) }));const C = new rs({ shape: v.getBoundingRect(), invisible: !0, tooltip: _.get('show') ? P({ content: t, formatter: w.get('formatter', !0) || function () {
      return t;
    }, formatterParams: { componentType: 'legend', legendIndex: n.componentIndex, name: t, $vars: ['name'] } }, _.option) : null });return v.add(C), v.eachChild((t) => {
      t.silent = !0;
    }), C.silent = !u, this.getContentGroup().add(v), $s(v), v.__legendDataIndex = e, v;
  }, layoutInner(t, e, i, n, o, a) {
    const r = this.getContentGroup(); const s = this.getSelectorGroup();wu(t.get('orient'), r, t.get('itemGap'), i.width, i.height);const l = r.getBoundingRect(); const u = [-l.x, -l.y];if (o) {
      wu('horizontal', s, t.get('selectorItemGap', !0));const h = s.getBoundingRect(); const c = [-h.x, -h.y]; const d = t.get('selectorButtonGap', !0); const f = t.getOrient().index; const p = 0 === f ? 'width' : 'height'; const g = 0 === f ? 'height' : 'width'; const m = 0 === f ? 'y' : 'x';'end' === a ? c[f] += l[p] + d : u[f] += h[p] + d, c[1 - f] += l[g] / 2 - h[g] / 2, s.attr('position', c), r.attr('position', u);const v = { x: 0, y: 0 };return v[p] = l[p] + d + h[p], v[g] = Math.max(l[g], h[g]), v[m] = Math.min(0, h[m] + c[1 - f]), v;
    } return r.attr('position', u), this.group.getBoundingRect();
  }, remove() {
    this.getContentGroup().removeAll(), this._isFirstRender = !0;
  } });function JC(t, e, i, n, o, a) {
    let r;return 'line' !== e && e.indexOf('empty') < 0 ? (r = i.getItemStyle(), t.style.stroke = n, a || (r.stroke = o)) : r = i.getItemStyle(['borderWidth', 'borderColor']), t.setStyle(r);
  } function QC(t, e, i, n) {
    eL(t, e, i, n), i.dispatchAction({ type: 'legendToggleSelect', name: null != t ? t : e }), tL(t, e, i, n);
  } function tL(t, e, i, n) {
    const o = i.getZr().storage.getDisplayList()[0];o && o.useHoverLayer || i.dispatchAction({ type: 'highlight', seriesName: t, name: e, excludeSeriesId: n });
  } function eL(t, e, i, n) {
    const o = i.getZr().storage.getDisplayList()[0];o && o.useHoverLayer || i.dispatchAction({ type: 'downplay', seriesName: t, name: e, excludeSeriesId: n });
  }xf(Ld.PROCESSOR.SERIES_FILTER, (t) => {
    const i = t.findComponents({ mainType: 'legend' });i && i.length && t.filterSeries((t) => {
      for (let e = 0;e < i.length;e++) if (!i[e].isSelected(t.name)) return !1;return !0;
    });
  }), ku.registerSubTypeDefaulter('legend', () => 'plain');var iL = XC.extend({ type: 'legend.scroll', setScrollDataIndex(t) {
    this.option.scrollDataIndex = t;
  }, defaultOption: { scrollDataIndex: 0, pageButtonItemGap: 5, pageButtonGap: null, pageButtonPosition: 'end', pageFormatter: '{current}/{total}', pageIcons: { horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'], vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z'] }, pageIconColor: '#2f4554', pageIconInactiveColor: '#aaa', pageIconSize: 15, pageTextStyle: { color: '#333' }, animationDurationUpdate: 800 }, init(t, e, i, n) {
    const o = Iu(t);iL.superCall(this, 'init', t, e, i, n), nL(this, t, o);
  }, mergeOption(t, e) {
    iL.superCall(this, 'mergeOption', t, e), nL(this, this.option, t);
  } });function nL(t, e, i) {
    const n = [1, 1];n[t.getOrient().index] = 0, Mu(e, i, { type: 'box', ignoreSize: n });
  } const oL = Ci; const aL = ['width', 'height']; const rL = ['x', 'y']; var sL = $C.extend({ type: 'legend.scroll', newlineDisabled: !0, init() {
    sL.superCall(this, 'init'), this._currentIndex = 0, this.group.add(this._containerGroup = new oL), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new oL), this._showController;
  }, resetInner() {
    sL.superCall(this, 'resetInner'), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
  }, renderInner(t, o, e, a, i, n, r) {
    const s = this;sL.superCall(this, 'renderInner', t, o, e, a, i, n, r);const l = this._controllerGroup; let u = o.get('pageIconSize', !0);L(u) || (u = [u, u]), c('pagePrev', 0);const h = o.getModel('pageTextStyle');function c(t, e) {
      const i = `${t}DataIndex`; const n = yl(o.get('pageIcons', !0)[o.getOrient().name][e], { onclick: A(s._pageGo, s, i, o, a) }, { x: -u[0] / 2, y: -u[1] / 2, width: u[0], height: u[1] });n.name = t, l.add(n);
    }l.add(new Ur({ name: 'pageText', style: { textFill: h.getTextColor(), font: h.getFont(), textVerticalAlign: 'middle', textAlign: 'center' }, silent: !0 })), c('pageNext', 1);
  }, layoutInner(t, e, i, n, o, a) {
    const r = this.getSelectorGroup(); const s = t.getOrient().index; const l = aL[s]; const u = rL[s]; const h = aL[1 - s]; const c = rL[1 - s];o && wu('horizontal', r, t.get('selectorItemGap', !0));const d = t.get('selectorButtonGap', !0); const f = r.getBoundingRect(); const p = [-f.x, -f.y]; const g = k(i);o && (g[l] = i[l] - f[l] - d);const m = this._layoutContentAndController(t, n, g, s, l, h, c);if (o) {
      if ('end' === a)p[s] += m[l] + d;else {
        const v = f[l] + d;p[s] -= v, m[u] -= v;
      }m[l] += f[l] + d, p[1 - s] += m[c] + m[h] / 2 - f[h] / 2, m[h] = Math.max(m[h], f[h]), m[c] = Math.min(m[c], f[c] + p[1 - s]), r.attr('position', p);
    } return m;
  }, _layoutContentAndController(t, e, i, n, o, a, r) {
    const s = this.getContentGroup(); const l = this._containerGroup; const u = this._controllerGroup;wu(t.get('orient'), s, t.get('itemGap'), n ? i.width : null, n ? null : i.height), wu('horizontal', u, t.get('pageButtonItemGap', !0));const h = s.getBoundingRect(); const c = u.getBoundingRect(); const d = this._showController = h[o] > i[o]; const f = [-h.x, -h.y];e || (f[n] = s.position[n]);const p = [0, 0]; const g = [-c.x, -c.y]; const m = H(t.get('pageButtonGap', !0), t.get('itemGap', !0));d && ('end' === t.get('pageButtonPosition', !0) ? g[n] += i[o] - c[o] : p[n] += c[o] + m);g[1 - n] += h[a] / 2 - c[a] / 2, s.attr('position', f), l.attr('position', p), u.attr('position', g);const v = { x: 0, y: 0 };if (v[o] = d ? i[o] : h[o], v[a] = Math.max(h[a], c[a]), v[r] = Math.min(0, c[r] + g[1 - n]), l.__rectSize = i[o], d) {
      const y = { x: 0, y: 0 };y[o] = Math.max(i[o] - c[o] - m, 0), y[a] = v[a], l.setClipPath(new rs({ shape: y })), l.__rectSize = y[o];
    } else u.eachChild((t) => {
      t.attr({ invisible: !0, silent: !0 });
    });const x = this._getPageInfo(t);return null != x.pageIndex && cl(s, { position: x.contentPosition }, d && t), this._updatePageInfoView(t, x), v;
  }, _pageGo(t, e, i) {
    const n = this._getPageInfo(e)[t];null != n && i.dispatchAction({ type: 'legendScroll', scrollDataIndex: n, legendId: e.id });
  }, _updatePageInfoView(n, o) {
    const a = this._controllerGroup;R(['pagePrev', 'pageNext'], (t) => {
      const e = null != o[`${t}DataIndex`]; const i = a.childOfName(t);i && (i.setStyle('fill', e ? n.get('pageIconColor', !0) : n.get('pageIconInactiveColor', !0)), i.cursor = e ? 'pointer' : 'default');
    });const t = a.childOfName('pageText'); const e = n.get('pageFormatter'); const i = o.pageIndex; const r = null != i ? i + 1 : 0; const s = o.pageCount;t && e && t.setStyle('text', E(e) ? e.replace('{current}', r).replace('{total}', s) : e({ current: r, total: s }));
  }, _getPageInfo(t) {
    const e = t.get('scrollDataIndex', !0); const i = this.getContentGroup(); const n = this._containerGroup.__rectSize; const o = t.getOrient().index; const a = aL[o]; const r = rL[o]; const s = this._findTargetItemIndex(e); const l = i.children(); const u = l[s]; const h = l.length; const c = h ? 1 : 0; const d = { contentPosition: i.position.slice(), pageCount: c, pageIndex: c - 1, pagePrevDataIndex: null, pageNextDataIndex: null };if (!u) return d;const f = y(u);d.contentPosition[o] = -f.s;for (var p = s + 1, g = f, m = f, v = null;p <= h;++p)(!(v = y(l[p])) && m.e > g.s + n || v && !x(v, g.s)) && (g = m.i > g.i ? m : v) && (null == d.pageNextDataIndex && (d.pageNextDataIndex = g.i), ++d.pageCount), m = v;for (p = s - 1, g = f, m = f, v = null;-1 <= p;--p)(v = y(l[p])) && x(m, v.s) || !(g.i < m.i) || (m = g, null == d.pagePrevDataIndex && (d.pagePrevDataIndex = g.i), ++d.pageCount, ++d.pageIndex), g = v;return d;function y(t) {
      if (t) {
        const e = t.getBoundingRect(); const i = e[r] + t.position[o];return { s: i, e: i + e[a], i: t.__legendDataIndex };
      }
    } function x(t, e) {
      return t.e >= e && t.s <= e + n;
    }
  }, _findTargetItemIndex(n) {
    return this._showController ? (this.getContentGroup().eachChild((t, e) => {
      const i = t.__legendDataIndex;null == a && null != i && (a = e), i === n && (o = e);
    }), null != o ? o : a) : 0;let o; let a;
  } });_f('legendScroll', 'legendscroll', (t, e) => {
    const i = t.scrollDataIndex;null != i && e.eachComponent({ mainType: 'legend', subType: 'scroll', query: t }, (t) => {
      t.setScrollDataIndex(i);
    });
  });cD.extend({ type: 'dataZoom.slider', layoutMode: 'box', defaultOption: { show: !0, right: 'ph', top: 'ph', width: 'ph', height: 'ph', left: null, bottom: null, backgroundColor: 'rgba(47,69,84,0)', dataBackground: { lineStyle: { color: '#2f4554', width: .5, opacity: .3 }, areaStyle: { color: 'rgba(47,69,84,0.3)', opacity: .3 } }, borderColor: '#ddd', fillerColor: 'rgba(167,183,204,0.4)', handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z', handleSize: '100%', handleStyle: { color: '#a7b7cc' }, labelPrecision: null, labelFormatter: null, showDetail: !0, showDataShadow: 'auto', realtime: !0, zoomLock: !1, textStyle: { color: '#333' } } });const lL = rs; const uL = Rl; const hL = Bl; const cL = A; const dL = R; const fL = 'horizontal'; const pL = 'vertical'; const gL = ['line', 'bar', 'candlestick', 'scatter']; var mL = pD.extend({ type: 'dataZoom.slider', init(t, e) {
    this._displayables = {}, this._orient, this._range, this._handleEnds, this._size, this._handleWidth, this._handleHeight, this._location, this._dragging, this._dataShadowInfo, this.api = e;
  }, render(t, e, i, n) {
    mL.superApply(this, 'render', arguments), kc(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate'), this._orient = t.get('orient'), !1 !== this.dataZoomModel.get('show') ? (n && 'dataZoom' === n.type && n.from === this.uid || this._buildView(), this._updateView()) : this.group.removeAll();
  }, remove() {
    mL.superApply(this, 'remove', arguments), Pc(this, '_dispatchZoomAction');
  }, dispose() {
    mL.superApply(this, 'dispose', arguments), Pc(this, '_dispatchZoomAction');
  }, _buildView() {
    const t = this.group;t.removeAll(), this._resetLocation(), this._resetInterval();const e = this._displayables.barGroup = new Ci;this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(e), this._positionGroup();
  }, _resetLocation() {
    const t = this.dataZoomModel; const e = this.api; const i = this._findCoordRect(); const n = { width: e.getWidth(), height: e.getHeight() }; const o = this._orient === fL ? { right: n.width - i.x - i.width, top: n.height - 30 - 7, width: i.width, height: 30 } : { right: 7, top: i.y, width: 30, height: i.height }; const a = Iu(t.option);R(['right', 'top', 'width', 'height'], (t) => {
      'ph' === a[t] && (a[t] = o[t]);
    });const r = bu(a, n, t.padding);this._location = { x: r.x, y: r.y }, this._size = [r.width, r.height], this._orient === pL && this._size.reverse();
  }, _positionGroup() {
    const t = this.group; const e = this._location; const i = this._orient; const n = this.dataZoomModel.getFirstTargetAxisModel(); const o = n && n.get('inverse'); const a = this._displayables.barGroup; const r = (this._dataShadowInfo || {}).otherAxisInverse;a.attr(i !== fL || o ? i === fL && o ? { scale: r ? [-1, 1] : [-1, -1] } : i !== pL || o ? { scale: r ? [-1, -1] : [-1, 1], rotation: Math.PI / 2 } : { scale: r ? [1, -1] : [1, 1], rotation: Math.PI / 2 } : { scale: r ? [1, 1] : [1, -1] });const s = t.getBoundingRect([a]);t.attr('position', [e.x - s.x, e.y - s.y]);
  }, _getViewExtent() {
    return [0, this._size[0]];
  }, _renderBackground() {
    const t = this.dataZoomModel; const e = this._size; const i = this._displayables.barGroup;i.add(new lL({ silent: !0, shape: { x: 0, y: 0, width: e[0], height: e[1] }, style: { fill: t.get('backgroundColor') }, z2: -40 })), i.add(new lL({ shape: { x: 0, y: 0, width: e[0], height: e[1] }, style: { fill: 'transparent' }, z2: 0, onclick: A(this._onClickPanelClick, this) }));
  }, _renderDataShadow() {
    const t = this._dataShadowInfo = this._prepareDataShadowInfo();if (t) {
      const e = this._size; const i = t.series; const n = i.getRawData(); const o = i.getShadowDim ? i.getShadowDim() : t.otherDim;if (null != o) {
        let a = n.getDataExtent(o); const r = .3 * (a[1] - a[0]);a = [a[0] - r, a[1] + r];let s; const l = [0, e[1]]; const u = [0, e[0]]; const h = [[e[0], 0], [0, 0]]; const c = []; const d = u[1] / (n.count() - 1); let f = 0; const p = Math.round(n.count() / e[0]);n.each([o], (t, e) => {
          if (0 < p && e % p)f += d;else {
            const i = null == t || isNaN(t) || '' === t; const n = i ? 0 : uL(t, a, l, !0);i && !s && e ? (h.push([h[h.length - 1][0], 0]), c.push([c[c.length - 1][0], 0])) : !i && s && (h.push([f, 0]), c.push([f, 0])), h.push([f, n]), c.push([f, n]), f += d, s = i;
          }
        });const g = this.dataZoomModel;this._displayables.barGroup.add(new Qr({ shape: { points: h }, style: D({ fill: g.get('dataBackgroundColor') }, g.getModel('dataBackground.areaStyle').getAreaStyle()), silent: !0, z2: -20 })), this._displayables.barGroup.add(new ts({ shape: { points: c }, style: g.getModel('dataBackground.lineStyle').getLineStyle(), silent: !0, z2: -19 }));
      }
    }
  }, _prepareDataShadowInfo() {
    const t = this.dataZoomModel; const s = t.get('showDataShadow');if (!1 !== s) {
      let l; const u = this.ecModel;return t.eachTargetAxis(function (a, r) {
        R(t.getAxisProxy(a.name, r).getTargetSeriesModels(), (t) => {
          if (!(l || !0 !== s && _(gL, t.get('type')) < 0)) {
            let e; const i = u.getComponent(a.axis, r).axis; let n = (function (t) {
              return { x: 'y', y: 'x', radius: 'angle', angle: 'radius' }[t];
            }(a.name)); const o = t.coordinateSystem;null != n && o.getOtherAxis && (e = o.getOtherAxis(i).inverse), n = t.getData().mapDimension(n), l = { thisAxis: i, series: t, thisDim: a.name, otherDim: n, otherAxisInverse: e };
          }
        }, this);
      }, this), l;
    }
  }, _renderHandle() {
    const t = this._displayables; const a = t.handles = []; const r = t.handleLabels = []; const s = this._displayables.barGroup; const e = this._size; const l = this.dataZoomModel;s.add(t.filler = new lL({ draggable: !0, cursor: vL(this._orient), drift: cL(this._onDragMove, this, 'all'), ondragstart: cL(this._showDataInfo, this, !0), ondragend: cL(this._onDragEnd, this), onmouseover: cL(this._showDataInfo, this, !0), onmouseout: cL(this._showDataInfo, this, !1), style: { fill: l.get('fillerColor'), textPosition: 'inside' } })), s.add(new lL({ silent: !0, subPixelOptimize: !0, shape: { x: 0, y: 0, width: e[0], height: e[1] }, style: { stroke: l.get('dataBackgroundColor') || l.get('borderColor'), lineWidth: 1, fill: 'rgba(0,0,0,0)' } })), dL([0, 1], function (t) {
      const e = yl(l.get('handleIcon'), { cursor: vL(this._orient), draggable: !0, drift: cL(this._onDragMove, this, t), ondragend: cL(this._onDragEnd, this), onmouseover: cL(this._showDataInfo, this, !0), onmouseout: cL(this._showDataInfo, this, !1) }, { x: -1, y: 0, width: 2, height: 2 }); const i = e.getBoundingRect();this._handleHeight = El(l.get('handleSize'), this._size[1]), this._handleWidth = i.width / i.height * this._handleHeight, e.setStyle(l.getModel('handleStyle').getItemStyle());const n = l.get('handleColor');null != n && (e.style.fill = n), s.add(a[t] = e);const o = l.textStyleModel;this.group.add(r[t] = new Ur({ silent: !0, invisible: !0, style: { x: 0, y: 0, text: '', textVerticalAlign: 'middle', textAlign: 'center', textFill: o.getTextColor(), textFont: o.getFont() }, z2: 10 }));
    }, this);
  }, _resetInterval() {
    const t = this._range = this.dataZoomModel.getPercentRange(); const e = this._getViewExtent();this._handleEnds = [uL(t[0], [0, 100], e, !0), uL(t[1], [0, 100], e, !0)];
  }, _updateInterval(t, e) {
    const i = this.dataZoomModel; const n = this._handleEnds; const o = this._getViewExtent(); const a = i.findRepresentativeAxisProxy().getMinMaxSpan(); const r = [0, 100];sb(e, n, o, i.get('zoomLock') ? 'all' : t, null != a.minSpan ? uL(a.minSpan, r, o, !0) : null, null != a.maxSpan ? uL(a.maxSpan, r, o, !0) : null);const s = this._range; const l = this._range = hL([uL(n[0], o, r, !0), uL(n[1], o, r, !0)]);return !s || s[0] !== l[0] || s[1] !== l[1];
  }, _updateView(t) {
    const n = this._displayables; const o = this._handleEnds; const e = hL(o.slice()); const a = this._size;dL([0, 1], function (t) {
      const e = n.handles[t]; const i = this._handleHeight;e.attr({ scale: [i / 2, i / 2], position: [o[t], a[1] / 2 - i / 2] });
    }, this), n.filler.setShape({ x: e[0], y: 0, width: e[1] - e[0], height: a[1] }), this._updateDataInfo(t);
  }, _updateDataInfo(t) {
    const e = this.dataZoomModel; const a = this._displayables; const r = a.handleLabels; const s = this._orient; let l = ['', ''];if (e.get('showDetail')) {
      const i = e.findRepresentativeAxisProxy();if (i) {
        const n = i.getAxisModel().axis; const o = this._range; const u = t ? i.calculateDataWindow({ start: o[0], end: o[1] }).valueWindow : i.getDataValueWindow();l = [this._formatLabel(u[0], n), this._formatLabel(u[1], n)];
      }
    } const h = hL(this._handleEnds.slice());function c(t) {
      const e = fl(a.handles[t].parent, this.group); const i = gl(0 === t ? 'right' : 'left', e); const n = this._handleWidth / 2 + 5; const o = pl([h[t] + (0 === t ? -n : n), this._size[1] / 2], e);r[t].setStyle({ x: o[0], y: o[1], textVerticalAlign: s === fL ? 'middle' : i, textAlign: s === fL ? i : 'center', text: l[t] });
    }c.call(this, 0), c.call(this, 1);
  }, _formatLabel(t, e) {
    const i = this.dataZoomModel; const n = i.get('labelFormatter'); let o = i.get('labelPrecision');null != o && 'auto' !== o || (o = e.getPixelPrecision());const a = null == t || isNaN(t) ? '' : 'category' === e.type || 'time' === e.type ? e.scale.getLabel(Math.round(t)) : t.toFixed(Math.min(o, 20));return C(n) ? n(t, a) : E(n) ? n.replace('{value}', a) : a;
  }, _showDataInfo(t) {
    t = this._dragging || t;const e = this._displayables.handleLabels;e[0].attr('invisible', !t), e[1].attr('invisible', !t);
  }, _onDragMove(t, e, i, n) {
    this._dragging = !0, Xt(n.event);const o = pl([e, i], this._displayables.barGroup.getLocalTransform(), !0); const a = this._updateInterval(t, o[0]); const r = this.dataZoomModel.get('realtime');this._updateView(!r), a && r && this._dispatchZoomAction();
  }, _onDragEnd() {
    this._dragging = !1, this._showDataInfo(!1), this.dataZoomModel.get('realtime') || this._dispatchZoomAction();
  }, _onClickPanelClick(t) {
    const e = this._size; const i = this._displayables.barGroup.transformCoordToLocal(t.offsetX, t.offsetY);if (!(i[0] < 0 || i[0] > e[0] || i[1] < 0 || i[1] > e[1])) {
      const n = this._handleEnds; const o = (n[0] + n[1]) / 2; const a = this._updateInterval('all', i[0] - o);this._updateView(), a && this._dispatchZoomAction();
    }
  }, _dispatchZoomAction() {
    const t = this._range;this.api.dispatchAction({ type: 'dataZoom', from: this.uid, dataZoomId: this.dataZoomModel.id, start: t[0], end: t[1] });
  }, _findCoordRect() {
    let i;if (dL(this.getTargetCoordInfo(), (t) => {
      if (!i && t.length) {
        const e = t[0].model.coordinateSystem;i = e.getRect && e.getRect();
      }
    }), !i) {
      const t = this.api.getWidth(); const e = this.api.getHeight();i = { x: .2 * t, y: .2 * e, width: .6 * t, height: .6 * e };
    } return i;
  } });function vL(t) {
    return 'vertical' === t ? 'ns-resize' : 'ew-resize';
  }cD.extend({ type: 'dataZoom.inside', defaultOption: { disabled: !1, zoomLock: !1, zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !1, preventDefaultMouseMove: !0 } });const yL = '\0_ec_dataZoom_roams';function xL(t, n) {
    const e = wL(t); const o = n.dataZoomId; const a = n.coordId;R(e, (t, e) => {
      const i = t.dataZoomInfos;i[o] && _(n.allCoordIds, a) < 0 && (delete i[o], t.count--);
    }), bL(e);let i = e[a];i || ((i = e[a] = { coordId: a, dataZoomInfos: {}, count: 0 }).controller = (function (t, r) {
      const e = new Vy(t.getZr());return R(['pan', 'zoom', 'scrollMove'], (a) => {
        e.on(a, (n) => {
          const o = [];R(r.dataZoomInfos, (t) => {
            if (n.isAvailableBehavior(t.dataZoomModel.option)) {
              const e = (t.getRange || {})[a]; const i = e && e(r.controller, n);!t.dataZoomModel.get('disabled', !0) && i && o.push({ dataZoomId: t.dataZoomId, start: i[0], end: i[1] });
            }
          }), o.length && r.dispatchAction(o);
        });
      }), e;
    }(t, i)), i.dispatchAction = T(SL, t)), i.dataZoomInfos[o] || i.count++, i.dataZoomInfos[o] = n;const r = (function (t) {
      let n; const o = { type_true: 2, type_move: 1, type_false: 0, type_undefined: -1 }; let a = !0;return R(t, (t) => {
        const e = t.dataZoomModel; const i = !e.get('disabled', !0) && (!e.get('zoomLock', !0) || 'move');o[`type_${n}`] < o[`type_${i}`] && (n = i), a &= e.get('preventDefaultMouseMove', !0);
      }), { controlType: n, opt: { zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !0, preventDefaultMouseMove: !!a } };
    }(i.dataZoomInfos));i.controller.enable(r.controlType, r.opt), i.controller.setPointerChecker(n.containsPoint), kc(i, 'dispatchAction', n.dataZoomModel.get('throttle', !0), 'fixRate');
  } function _L(t) {
    return `${t.type}\0_${t.id}`;
  } function wL(t) {
    const e = t.getZr();return e[yL] || (e[yL] = {});
  } function bL(i) {
    R(i, (t, e) => {
      t.count || (t.controller.dispose(), delete i[e]);
    });
  } function SL(t, e) {
    t.dispatchAction({ type: 'dataZoom', batch: e });
  } const ML = A; var IL = pD.extend({ type: 'dataZoom.inside', init(t, e) {
    this._range;
  }, render(r, t, s, e) {
    IL.superApply(this, 'render', arguments), this._range = r.getPercentRange(), R(this.getTargetCoordInfo(), function (t, o) {
      const a = O(t, t => _L(t.model));R(t, function (e) {
        const n = e.model; const i = {};R(['pan', 'zoom', 'scrollMove'], function (t) {
          i[t] = ML(TL[t], this, e, o);
        }, this), xL(s, { coordId: _L(n), allCoordIds: a, containsPoint(t, e, i) {
          return n.coordinateSystem.containPoint([e, i]);
        }, dataZoomId: r.id, dataZoomModel: r, getRange: i });
      }, this);
    }, this);
  }, dispose() {
    !(function (t, i) {
      const e = wL(t);R(e, (t) => {
        t.controller.dispose();const e = t.dataZoomInfos;e[i] && (delete e[i], t.count--);
      }), bL(e);
    }(this.api, this.dataZoomModel.id)), IL.superApply(this, 'dispose', arguments), this._range = null;
  } }); var TL = { zoom(t, e, i, n) {
    const o = this._range; const a = o.slice(); const r = t.axisModels[0];if (r) {
      const s = CL[e](null, [n.originX, n.originY], r, i, t); const l = (0 < s.signal ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0]; const u = Math.max(1 / n.scale, 0);a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;const h = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();return sb(0, a, [0, 100], 0, h.minSpan, h.maxSpan), this._range = a, o[0] !== a[0] || o[1] !== a[1] ? a : void 0;
    }
  }, pan: AL((t, e, i, n, o, a) => {
    const r = CL[n]([a.oldX, a.oldY], [a.newX, a.newY], e, o, i);return r.signal * (t[1] - t[0]) * r.pixel / r.pixelLength;
  }), scrollMove: AL((t, e, i, n, o, a) => CL[n]([0, 0], [a.scrollDelta, a.scrollDelta], e, o, i).signal * (t[1] - t[0]) * a.scrollDelta) };function AL(l) {
    return function (t, e, i, n) {
      const o = this._range; const a = o.slice(); const r = t.axisModels[0];if (r) {
        const s = l(a, r, t, e, i, n);return sb(s, a, [0, 100], 'all'), this._range = a, o[0] !== a[0] || o[1] !== a[1] ? a : void 0;
      }
    };
  } function DL(t) {
    let e = t && t.visualMap;L(e) || (e = e ? [e] : []), LL(e, (t) => {
      if (t) {
        kL(t, 'splitList') && !kL(t, 'pieces') && (t.pieces = t.splitList, delete t.splitList);const e = t.pieces;e && L(e) && LL(e, (t) => {
          z(t) && (kL(t, 'start') && !kL(t, 'min') && (t.min = t.start), kL(t, 'end') && !kL(t, 'max') && (t.max = t.end));
        });
      }
    });
  } var CL = { grid(t, e, i, n, o) {
    const a = i.axis; const r = {}; const s = o.model.coordinateSystem.getRect();return t = t || [0, 0], 'x' === a.dim ? (r.pixel = e[0] - t[0], r.pixelLength = s.width, r.pixelStart = s.x, r.signal = a.inverse ? 1 : -1) : (r.pixel = e[1] - t[1], r.pixelLength = s.height, r.pixelStart = s.y, r.signal = a.inverse ? -1 : 1), r;
  }, polar(t, e, i, n, o) {
    const a = i.axis; const r = {}; const s = o.model.coordinateSystem; const l = s.getRadiusAxis().getExtent(); const u = s.getAngleAxis().getExtent();return t = t ? s.pointToCoord(t) : [0, 0], e = s.pointToCoord(e), 'radiusAxis' === i.mainType ? (r.pixel = e[0] - t[0], r.pixelLength = l[1] - l[0], r.pixelStart = l[0], r.signal = a.inverse ? 1 : -1) : (r.pixel = e[1] - t[1], r.pixelLength = u[1] - u[0], r.pixelStart = u[0], r.signal = a.inverse ? -1 : 1), r;
  }, singleAxis(t, e, i, n, o) {
    const a = i.axis; const r = o.model.coordinateSystem.getRect(); const s = {};return t = t || [0, 0], 'horizontal' === a.orient ? (s.pixel = e[0] - t[0], s.pixelLength = r.width, s.pixelStart = r.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = e[1] - t[1], s.pixelLength = r.height, s.pixelStart = r.y, s.signal = a.inverse ? -1 : 1), s;
  } }; var LL = R;function kL(t, e) {
    return t && t.hasOwnProperty && t.hasOwnProperty(e);
  }ku.registerSubTypeDefaulter('visualMap', t => (t.categories || (t.pieces ? 0 < t.pieces.length : 0 < t.splitNumber) && !t.calculable ? 'piecewise' : 'continuous'));const PL = Ld.VISUAL.COMPONENT;function NL(t, e, i, n) {
    for (var o = e.targetVisuals[n], a = g_.prepareVisualTypes(o), r = { color: t.getData().getVisual('color') }, s = 0, l = a.length;s < l;s++) {
      const u = a[s]; const h = o['opacity' === u ? '__alphaForOpacity' : u];h && h.applyVisual(i, c, d);
    } return r.color;function c(t) {
      return r[t];
    } function d(t, e) {
      r[t] = e;
    }
  }Sf(PL, { createOnAllSeries: !0, reset(i, t) {
    const n = [];return t.eachComponent('visualMap', (t) => {
      const e = i.pipelineContext;!t.isTargetSeries(i) || e && e.large || n.push(function (t, f, p, g) {
        const m = {};return R(t, (t) => {
          const e = g_.prepareVisualTypes(f[t]);m[t] = e;
        }), { progress(t, i) {
          function e(t) {
            return i.getItemVisual(o, t);
          } function n(t, e) {
            i.setItemVisual(o, t, e);
          } let o;for (null != g && (g = i.getDimension(g));null != (o = t.next());) {
            const a = i.getRawDataItem(o);if (!a || !1 !== a.visualMap) for (let r = null != g ? i.get(g, o, !0) : o, s = p(r), l = f[s], u = m[s], h = 0, c = u.length;h < c;h++) {
              const d = u[h];l[d] && l[d].applyVisual(r, e, n);
            }
          }
        } };
      }(t.stateList, t.targetVisuals, A(t.getValueState, t), t.getDataDimension(i.getData())));
    }), n;
  } }), Sf(PL, { createOnAllSeries: !0, reset(o, t) {
    const a = o.getData(); const r = [];t.eachComponent('visualMap', (t) => {
      if (t.isTargetSeries(o)) {
        const e = t.getVisualMeta(A(NL, null, o, t)) || { stops: [], outerColors: [] }; const i = t.getDataDimension(a); const n = a.getDimensionInfo(i);null != n && (e.dimension = n.index, r.push(e));
      }
    }), o.getData().setVisual('visualMeta', r);
  } });const OL = function (t, e, i) {
    const n = k((RL[t] || {})[e]);return i && L(n) ? n[n.length - 1] : n;
  }; var RL = { color: { active: ['#006edd', '#e0ffff'], inactive: ['rgba(0,0,0,0)'] }, colorHue: { active: [0, 360], inactive: [0, 0] }, colorSaturation: { active: [.3, 1], inactive: [0, 0] }, colorLightness: { active: [.9, .5], inactive: [0, 0] }, colorAlpha: { active: [.3, 1], inactive: [0, 0] }, opacity: { active: [.3, 1], inactive: [0, 0] }, symbol: { active: ['circle', 'roundRect', 'diamond'], inactive: ['none'] }, symbolSize: { active: [10, 50], inactive: [0, 0] } }; const EL = g_.mapVisual; const zL = g_.eachVisual; const BL = L; const VL = R; const GL = Bl; const FL = Rl; const WL = Tf({ type: 'visualMap', dependencies: ['series'], stateList: ['inRange', 'outOfRange'], replacableOptionKeys: ['inRange', 'outOfRange', 'target', 'controller', 'color'], dataBound: [-1 / 0, 1 / 0], layoutMode: { type: 'box', ignoreSize: !0 }, defaultOption: { show: !0, zlevel: 0, z: 4, seriesIndex: 'all', min: 0, max: 200, dimension: null, inRange: null, outOfRange: null, left: 0, right: null, top: null, bottom: 0, itemWidth: null, itemHeight: null, inverse: !1, orient: 'vertical', backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', contentColor: '#5793f3', inactiveColor: '#aaa', borderWidth: 0, padding: 5, textGap: 10, precision: 0, color: null, formatter: null, text: null, textStyle: { color: '#333' } }, init(t, e, i) {
    this._dataExtent, this.targetVisuals = {}, this.controllerVisuals = {}, this.textStyleModel, this.itemSize, this.mergeDefaultAndTheme(t, i);
  }, optionUpdated(t, e) {
    const i = this.option;v.canvasSupported || (i.realtime = !1), e || WD(i, t, this.replacableOptionKeys), this.textStyleModel = this.getModel('textStyle'), this.resetItemSize(), this.completeVisualOption();
  }, resetVisual(t) {
    const e = this.stateList;t = A(t, this), this.controllerVisuals = FD(this.option.controller, e, t), this.targetVisuals = FD(this.option.target, e, t);
  }, getTargetSeriesIndices() {
    const t = this.option.seriesIndex; let i = [];return null == t || 'all' === t ? this.ecModel.eachSeries((t, e) => {
      i.push(e);
    }) : i = Vo(t), i;
  }, eachTargetSeries(e, i) {
    R(this.getTargetSeriesIndices(), function (t) {
      e.call(i, this.ecModel.getSeriesByIndex(t));
    }, this);
  }, isTargetSeries(e) {
    let i = !1;return this.eachTargetSeries((t) => {
      t === e && (i = !0);
    }), i;
  }, formatValueText(t, e, i) {
    let n; let o; const a = this.option; const r = a.precision; const s = this.dataBound; const l = a.formatter;return i = i || ['<', '>'], L(t) && (t = t.slice(), n = !0), o = e ? t : n ? [u(t[0]), u(t[1])] : u(t), E(l) ? l.replace('{value}', n ? o[0] : o).replace('{value2}', n ? o[1] : o) : C(l) ? n ? l(t[0], t[1]) : l(t) : n ? t[0] === s[0] ? `${i[0]} ${o[1]}` : t[1] === s[1] ? `${i[1]} ${o[0]}` : `${o[0]} - ${o[1]}` : o;function u(t) {
      return t === s[0] ? 'min' : t === s[1] ? 'max' : (+t).toFixed(Math.min(r, 20));
    }
  }, resetExtent() {
    const t = this.option; const e = GL([t.min, t.max]);this._dataExtent = e;
  }, getDataDimension(t) {
    const e = this.option.dimension; const i = t.dimensions;if (null != e || i.length) {
      if (null != e) return t.getDimension(e);for (let n = t.dimensions, o = n.length - 1;0 <= o;o--) {
        const a = n[o];if (!t.getDimensionInfo(a).isCalculationCoord) return a;
      }
    }
  }, getExtent() {
    return this._dataExtent.slice();
  }, completeVisualOption() {
    const t = this.ecModel; const e = this.option; const i = { inRange: e.inRange, outOfRange: e.outOfRange }; const n = e.target || (e.target = {}); const o = e.controller || (e.controller = {});m(n, i), m(o, i);const u = this.isCategory();function a(n) {
      BL(e.color) && !n.inRange && (n.inRange = { color: e.color.slice().reverse() }), n.inRange = n.inRange || { color: t.get('gradientColor') }, VL(this.stateList, (t) => {
        const e = n[t];if (E(e)) {
          const i = OL(e, 'active', u);i ? (n[t] = {}, n[t][e] = i) : delete n[t];
        }
      }, this);
    }a.call(this, n), a.call(this, o), function (t, e, i) {
      const n = t[e]; let o = t[i];n && !o && (o = t[i] = {}, VL(n, (t, e) => {
        if (g_.isValidType(e)) {
          const i = OL(e, 'inactive', u);null != i && (o[e] = i, 'color' !== e || o.hasOwnProperty('opacity') || o.hasOwnProperty('colorAlpha') || (o.opacity = [0, 0]));
        }
      }));
    }.call(this, n, 'inRange', 'outOfRange'), function (a) {
      const r = (a.inRange || {}).symbol || (a.outOfRange || {}).symbol; const s = (a.inRange || {}).symbolSize || (a.outOfRange || {}).symbolSize; const l = this.get('inactiveColor');VL(this.stateList, function (t) {
        const e = this.itemSize; let i = a[t];null == (i = i || (a[t] = { color: u ? l : [l] })).symbol && (i.symbol = r && k(r) || (u ? 'roundRect' : ['roundRect'])), null == i.symbolSize && (i.symbolSize = s && k(s) || (u ? e[0] : [e[0], e[0]])), i.symbol = EL(i.symbol, t => ('none' === t || 'square' === t ? 'roundRect' : t));const n = i.symbolSize;if (null != n) {
          let o = -1 / 0;zL(n, (t) => {
            o < t && (o = t);
          }), i.symbolSize = EL(n, t => FL(t, [0, o], [0, e[0]], !0));
        }
      }, this);
    }.call(this, o);
  }, resetItemSize() {
    this.itemSize = [parseFloat(this.get('itemWidth')), parseFloat(this.get('itemHeight'))];
  }, isCategory() {
    return !!this.option.categories;
  }, setSelected: et, getValueState: et, getVisualMeta: et }); const HL = [20, 140]; var ZL = WL.extend({ type: 'visualMap.continuous', defaultOption: { align: 'auto', calculable: !1, range: null, realtime: !0, itemHeight: null, itemWidth: null, hoverLink: !0, hoverLinkDataSize: null, hoverLinkOnHandle: null }, optionUpdated(t, e) {
    ZL.superApply(this, 'optionUpdated', arguments), this.resetExtent(), this.resetVisual(function (t) {
      t.mappingMethod = 'linear', t.dataExtent = this.getExtent();
    }), this._resetRange();
  }, resetItemSize() {
    ZL.superApply(this, 'resetItemSize', arguments);const t = this.itemSize;'horizontal' === this._orient && t.reverse(), null != t[0] && !isNaN(t[0]) || (t[0] = HL[0]), null != t[1] && !isNaN(t[1]) || (t[1] = HL[1]);
  }, _resetRange() {
    const t = this.getExtent(); const e = this.option.range;!e || e.auto ? (t.auto = 1, this.option.range = t) : L(e) && (e[0] > e[1] && e.reverse(), e[0] = Math.max(e[0], t[0]), e[1] = Math.min(e[1], t[1]));
  }, completeVisualOption() {
    WL.prototype.completeVisualOption.apply(this, arguments), R(this.stateList, function (t) {
      const e = this.option.controller[t].symbolSize;e && e[0] !== e[1] && (e[0] = 0);
    }, this);
  }, setSelected(t) {
    this.option.range = t.slice(), this._resetRange();
  }, getSelected() {
    const t = this.getExtent(); const e = Bl((this.get('range') || []).slice());return e[0] > t[1] && (e[0] = t[1]), e[1] > t[1] && (e[1] = t[1]), e[0] < t[0] && (e[0] = t[0]), e[1] < t[0] && (e[1] = t[0]), e;
  }, getValueState(t) {
    const e = this.option.range; const i = this.getExtent();return (e[0] <= i[0] || e[0] <= t) && (e[1] >= i[1] || t <= e[1]) ? 'inRange' : 'outOfRange';
  }, findTargetDataIndices(n) {
    const o = [];return this.eachTargetSeries(function (t) {
      const i = []; const e = t.getData();e.each(this.getDataDimension(e), (t, e) => {
        n[0] <= t && t <= n[1] && i.push(e);
      }, this), o.push({ seriesId: t.id, dataIndex: i });
    }, this), o;
  }, getVisualMeta(i) {
    const t = UL(this, 'outOfRange', this.getExtent()); const e = UL(this, 'inRange', this.option.range.slice()); const n = [];function o(t, e) {
      n.push({ value: t, color: i(t, e) });
    } for (var a = 0, r = 0, s = e.length, l = t.length;r < l && (!e.length || t[r] <= e[0]);r++)t[r] < e[a] && o(t[r], 'outOfRange');for (var u = 1;a < s;a++, u = 0)u && n.length && o(e[a], 'outOfRange'), o(e[a], 'inRange');for (u = 1;r < l;r++)(!e.length || e[e.length - 1] < t[r]) && (u && (n.length && o(n[n.length - 1].value, 'outOfRange'), u = 0), o(t[r], 'outOfRange'));const h = n.length;return { stops: n, outerColors: [h ? n[0].color : 'transparent', h ? n[h - 1].color : 'transparent'] };
  } });function UL(t, e, i) {
    if (i[0] === i[1]) return i.slice();for (var n = (i[1] - i[0]) / 200, o = i[0], a = [], r = 0;r <= 200 && o < i[1];r++)a.push(o), o += n;return a.push(i[1]), a;
  } const XL = Af({ type: 'visualMap', autoPositionValues: { left: 1, right: 1, top: 1, bottom: 1 }, init(t, e) {
    this.ecModel = t, this.api = e, this.visualMapModel;
  }, render(t, e, i, n) {
    !1 !== (this.visualMapModel = t).get('show') ? this.doRender.apply(this, arguments) : this.group.removeAll();
  }, renderBackground(t) {
    const e = this.visualMapModel; const i = iu(e.get('padding') || 0); const n = t.getBoundingRect();t.add(new rs({ z2: -1, silent: !0, shape: { x: n.x - i[3], y: n.y - i[0], width: n.width + i[3] + i[1], height: n.height + i[0] + i[2] }, style: { fill: e.get('backgroundColor'), stroke: e.get('borderColor'), lineWidth: e.get('borderWidth') } }));
  }, getControllerVisual(i, n, o) {
    const t = (o = o || {}).forceState; const e = this.visualMapModel; const a = {};if ('symbol' === n && (a.symbol = e.get('itemSymbol')), 'color' === n) {
      const r = e.get('contentColor');a.color = r;
    } function s(t) {
      return a[t];
    } function l(t, e) {
      a[t] = e;
    } const u = e.controllerVisuals[t || e.getValueState(i)];return R(g_.prepareVisualTypes(u), (t) => {
      let e = u[t];o.convertOpacityToAlpha && 'opacity' === t && (t = 'colorAlpha', e = u.__alphaForOpacity), g_.dependsOn(t, n) && e && e.applyVisual(i, s, l);
    }), a[n];
  }, positionGroup(t) {
    const e = this.visualMapModel; const i = this.api;Su(t, e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() });
  }, doRender: et });function YL(t, e, i) {
    const n = t.option; const o = n.align;if (null != o && 'auto' !== o) return o;for (var a = { width: e.getWidth(), height: e.getHeight() }, r = 'horizontal' === n.orient ? 1 : 0, s = [['left', 'right', 'width'], ['top', 'bottom', 'height']], l = s[r], u = [0, null, 10], h = {}, c = 0;c < 3;c++)h[s[1 - r][c]] = u[c], h[l[c]] = 2 === c ? i[0] : n[l[c]];const d = [['x', 'width', 3], ['y', 'height', 0]][r]; const f = bu(h, a, n.padding);return l[(f.margin[d[2]] || 0) + f[d[0]] + .5 * f[d[1]] < .5 * a[d[1]] ? 0 : 1];
  } function jL(t, e) {
    return R(t || [], (t) => {
      null != t.dataIndex && (t.dataIndexInside = t.dataIndex, t.dataIndex = null), t.highlightKey = `visualMap${e ? e.componentIndex : ''}`;
    }), t;
  } const qL = Rl; const KL = R; const $L = Math.min; const JL = Math.max; var QL = XL.extend({ type: 'visualMap.continuous', init() {
    QL.superApply(this, 'init', arguments), this._shapes = {}, this._dataInterval = [], this._handleEnds = [], this._orient, this._useHandle, this._hoverLinkDataIndices = [], this._dragging, this._hovering;
  }, doRender(t, e, i, n) {
    n && 'selectDataRange' === n.type && n.from === this.uid || this._buildView();
  }, _buildView() {
    this.group.removeAll();const t = this.visualMapModel; const e = this.group;this._orient = t.get('orient'), this._useHandle = t.get('calculable'), this._resetInterval(), this._renderBar(e);const i = t.get('text');this._renderEndsText(e, i, 0), this._renderEndsText(e, i, 1), this._updateView(!0), this.renderBackground(e), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(e);
  }, _renderEndsText(t, e, i) {
    if (e) {
      let n = e[1 - i];n = null != n ? `${n}` : '';const o = this.visualMapModel; const a = o.get('textGap'); const r = o.itemSize; const s = this._shapes.barGroup; const l = this._applyTransform([r[0] / 2, 0 === i ? -a : r[1] + a], s); const u = this._applyTransform(0 === i ? 'bottom' : 'top', s); const h = this._orient; const c = this.visualMapModel.textStyleModel;this.group.add(new Ur({ style: { x: l[0], y: l[1], textVerticalAlign: 'horizontal' === h ? 'middle' : u, textAlign: 'horizontal' === h ? u : 'center', text: n, textFont: c.getFont(), textFill: c.getTextColor() } }));
    }
  }, _renderBar(t) {
    const e = this.visualMapModel; const i = this._shapes; const n = e.itemSize; const o = this._orient; const a = this._useHandle; const r = YL(e, this.api, n); const s = i.barGroup = this._createBarGroup(r);s.add(i.outOfRange = tk()), s.add(i.inRange = tk(null, a ? ik(this._orient) : null, A(this._dragHandle, this, 'all', !1), A(this._dragHandle, this, 'all', !0)));const l = e.textStyleModel.getTextRect('国'); const u = JL(l.width, l.height);a && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(s, 0, n, u, o, r), this._createHandle(s, 1, n, u, o, r)), this._createIndicator(s, n, u, o), t.add(s);
  }, _createHandle(t, e, i, n, o) {
    const a = A(this._dragHandle, this, e, !1); const r = A(this._dragHandle, this, e, !0); const s = tk((function (t, e) {
      return 0 === t ? [[0, 0], [e, 0], [e, -e]] : [[0, 0], [e, 0], [e, e]];
    }(e, n)), ik(this._orient), a, r);s.position[0] = i[0], t.add(s);const l = this.visualMapModel.textStyleModel; const u = new Ur({ draggable: !0, drift: a, onmousemove(t) {
      Xt(t.event);
    }, ondragend: r, style: { x: 0, y: 0, text: '', textFont: l.getFont(), textFill: l.getTextColor() } });this.group.add(u);const h = ['horizontal' === o ? n / 2 : 1.5 * n, 'horizontal' === o ? 0 === e ? -1.5 * n : 1.5 * n : 0 === e ? -n / 2 : n / 2]; const c = this._shapes;c.handleThumbs[e] = s, c.handleLabelPoints[e] = h, c.handleLabels[e] = u;
  }, _createIndicator(t, e, i, n) {
    const o = tk([[0, 0]], 'move');o.position[0] = e[0], o.attr({ invisible: !0, silent: !0 }), t.add(o);const a = this.visualMapModel.textStyleModel; const r = new Ur({ silent: !0, invisible: !0, style: { x: 0, y: 0, text: '', textFont: a.getFont(), textFill: a.getTextColor() } });this.group.add(r);const s = ['horizontal' === n ? i / 2 : 9, 0]; const l = this._shapes;l.indicator = o, l.indicatorLabel = r, l.indicatorLabelPoint = s;
  }, _dragHandle(t, e, i, n) {
    if (this._useHandle) {
      if (this._dragging = !e, !e) {
        const o = this._applyTransform([i, n], this._shapes.barGroup, !0);this._updateInterval(t, o[1]), this._updateView();
      }e === !this.visualMapModel.get('realtime') && this.api.dispatchAction({ type: 'selectDataRange', from: this.uid, visualMapId: this.visualMapModel.id, selected: this._dataInterval.slice() }), e ? this._hovering || this._clearHoverLinkToSeries() : ek(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1);
    }
  }, _resetInterval() {
    const t = this.visualMapModel; const e = this._dataInterval = t.getSelected(); const i = t.getExtent(); const n = [0, t.itemSize[1]];this._handleEnds = [qL(e[0], i, n, !0), qL(e[1], i, n, !0)];
  }, _updateInterval(t, e) {
    e = e || 0;const i = this.visualMapModel; const n = this._handleEnds; const o = [0, i.itemSize[1]];sb(e, n, o, t, 0);const a = i.getExtent();this._dataInterval = [qL(n[0], o, a, !0), qL(n[1], o, a, !0)];
  }, _updateView(t) {
    const e = this.visualMapModel; const i = e.getExtent(); const n = this._shapes; const o = [0, e.itemSize[1]]; const a = t ? o : this._handleEnds; const r = this._createBarVisual(this._dataInterval, i, a, 'inRange'); const s = this._createBarVisual(i, i, o, 'outOfRange');n.inRange.setStyle({ fill: r.barColor, opacity: r.opacity }).setShape('points', r.barPoints), n.outOfRange.setStyle({ fill: s.barColor, opacity: s.opacity }).setShape('points', s.barPoints), this._updateHandle(a, r);
  }, _createBarVisual(t, e, i, n) {
    const o = { forceState: n, convertOpacityToAlpha: !0 }; const a = this._makeColorGradient(t, o); const r = [this.getControllerVisual(t[0], 'symbolSize', o), this.getControllerVisual(t[1], 'symbolSize', o)]; const s = this._createBarPoints(i, r);return { barColor: new gs(0, 0, 0, 1, a), barPoints: s, handlesColor: [a[0].color, a[a.length - 1].color] };
  }, _makeColorGradient(t, e) {
    const i = []; const n = (t[1] - t[0]) / 100;i.push({ color: this.getControllerVisual(t[0], 'color', e), offset: 0 });for (let o = 1;o < 100;o++) {
      const a = t[0] + n * o;if (a > t[1]) break;i.push({ color: this.getControllerVisual(a, 'color', e), offset: o / 100 });
    } return i.push({ color: this.getControllerVisual(t[1], 'color', e), offset: 1 }), i;
  }, _createBarPoints(t, e) {
    const i = this.visualMapModel.itemSize;return [[i[0] - e[0], t[0]], [i[0], t[0]], [i[0], t[1]], [i[0] - e[1], t[1]]];
  }, _createBarGroup(t) {
    const e = this._orient; const i = this.visualMapModel.get('inverse');return new Ci('horizontal' !== e || i ? 'horizontal' === e && i ? { scale: 'bottom' === t ? [-1, 1] : [1, 1], rotation: -Math.PI / 2 } : 'vertical' !== e || i ? { scale: 'left' === t ? [1, 1] : [-1, 1] } : { scale: 'left' === t ? [1, -1] : [-1, -1] } : { scale: 'bottom' === t ? [1, 1] : [-1, 1], rotation: Math.PI / 2 });
  }, _updateHandle(n, o) {
    if (this._useHandle) {
      const a = this._shapes; const r = this.visualMapModel; const s = a.handleThumbs; const l = a.handleLabels;KL([0, 1], function (t) {
        const e = s[t];e.setStyle('fill', o.handlesColor[t]), e.position[1] = n[t];const i = pl(a.handleLabelPoints[t], fl(e, this.group));l[t].setStyle({ x: i[0], y: i[1], text: r.formatValueText(this._dataInterval[t]), textVerticalAlign: 'middle', textAlign: this._applyTransform('horizontal' === this._orient ? 0 === t ? 'bottom' : 'top' : 'left', a.barGroup) });
      }, this);
    }
  }, _showIndicator(t, e, i, n) {
    const o = this.visualMapModel; const a = o.getExtent(); const r = o.itemSize; const s = [0, r[1]]; const l = qL(t, a, s, !0); const u = this._shapes; const h = u.indicator;if (h) {
      h.position[1] = l, h.attr('invisible', !1), h.setShape('points', (function (t, e, i, n) {
        return t ? [[0, -$L(e, JL(i, 0))], [6, 0], [0, $L(e, JL(n - i, 0))]] : [[0, 0], [5, -5], [5, 5]];
      }(!!i, n, l, r[1])));const c = this.getControllerVisual(t, 'color', { convertOpacityToAlpha: !0 });h.setStyle('fill', c);const d = pl(u.indicatorLabelPoint, fl(h, this.group)); const f = u.indicatorLabel;f.attr('invisible', !1);const p = this._applyTransform('left', u.barGroup); const g = this._orient;f.setStyle({ text: (i || '') + o.formatValueText(e), textVerticalAlign: 'horizontal' === g ? p : 'middle', textAlign: 'horizontal' === g ? 'center' : p, x: d[0], y: d[1] });
    }
  }, _enableHoverLinkToSeries() {
    const n = this;this._shapes.barGroup.on('mousemove', (t) => {
      if (n._hovering = !0, !n._dragging) {
        const e = n.visualMapModel.itemSize; const i = n._applyTransform([t.offsetX, t.offsetY], n._shapes.barGroup, !0, !0);i[1] = $L(JL(0, i[1]), e[1]), n._doHoverLinkToSeries(i[1], 0 <= i[0] && i[0] <= e[0]);
      }
    }).on('mouseout', () => {
      n._hovering = !1, n._dragging || n._clearHoverLinkToSeries();
    });
  }, _enableHoverLinkFromSeries() {
    const t = this.api.getZr();this.visualMapModel.option.hoverLink ? (t.on('mouseover', this._hoverLinkFromSeriesMouseOver, this), t.on('mouseout', this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
  }, _doHoverLinkToSeries(t, e) {
    const i = this.visualMapModel; const n = i.itemSize;if (i.option.hoverLink) {
      const o = [0, n[1]]; const a = i.getExtent();t = $L(JL(o[0], t), o[1]);const r = (function (t, e, i) {
        let n = 6; const o = t.get('hoverLinkDataSize');o && (n = qL(o, e, i, !0) / 2);return n;
      }(i, a, o)); const s = [t - r, t + r]; const l = qL(t, o, a, !0); const u = [qL(s[0], o, a, !0), qL(s[1], o, a, !0)];s[0] < o[0] && (u[0] = -1 / 0), o[1] < s[1] && (u[1] = 1 / 0), e && (u[0] === -1 / 0 ? this._showIndicator(l, u[1], '< ', r) : u[1] === 1 / 0 ? this._showIndicator(l, u[0], '> ', r) : this._showIndicator(l, l, '≈ ', r));const h = this._hoverLinkDataIndices; let c = [];(e || ek(i)) && (c = this._hoverLinkDataIndices = i.findTargetDataIndices(u));const d = (function (t, e) {
        const i = {}; const n = {};return o(t || [], i), o(e || [], n, i), [a(i), a(n)];function o(t, e, i) {
          for (let n = 0, o = t.length;n < o;n++) for (let a = t[n].seriesId, r = Vo(t[n].dataIndex), s = i && i[a], l = 0, u = r.length;l < u;l++) {
            const h = r[l];s && s[h] ? s[h] = null : (e[a] || (e[a] = {}))[h] = 1;
          }
        } function a(t, e) {
          const i = [];for (const n in t) if (t.hasOwnProperty(n) && null != t[n]) if (e)i.push(+n);else {
            const o = a(t[n], !0);o.length && i.push({ seriesId: n, dataIndex: o });
          } return i;
        }
      }(h, c));this._dispatchHighDown('downplay', jL(d[0], i)), this._dispatchHighDown('highlight', jL(d[1], i));
    }
  }, _hoverLinkFromSeriesMouseOver(t) {
    const e = t.target; const i = this.visualMapModel;if (e && null != e.dataIndex) {
      const n = this.ecModel.getSeriesByIndex(e.seriesIndex);if (i.isTargetSeries(n)) {
        const o = n.getData(e.dataType); const a = o.get(i.getDataDimension(o), e.dataIndex, !0);isNaN(a) || this._showIndicator(a, a);
      }
    }
  }, _hideIndicator() {
    const t = this._shapes;t.indicator && t.indicator.attr('invisible', !0), t.indicatorLabel && t.indicatorLabel.attr('invisible', !0);
  }, _clearHoverLinkToSeries() {
    this._hideIndicator();const t = this._hoverLinkDataIndices;this._dispatchHighDown('downplay', jL(t, this.visualMapModel)), t.length = 0;
  }, _clearHoverLinkFromSeries() {
    this._hideIndicator();const t = this.api.getZr();t.off('mouseover', this._hoverLinkFromSeriesMouseOver), t.off('mouseout', this._hideIndicator);
  }, _applyTransform(t, e, i, n) {
    const o = fl(e, n ? null : this.group);return bl[L(t) ? 'applyTransform' : 'transformDirection'](t, o, i);
  }, _dispatchHighDown(t, e) {
    e && e.length && this.api.dispatchAction({ type: t, batch: e });
  }, dispose() {
    this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
  }, remove() {
    this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
  } });function tk(t, e, i, n) {
    return new Qr({ shape: { points: t }, draggable: !!i, cursor: e, drift: i, onmousemove(t) {
      Xt(t.event);
    }, ondragend: n });
  } function ek(t) {
    const e = t.get('hoverLinkOnHandle');return !!(null == e ? t.get('realtime') : e);
  } function ik(t) {
    return 'vertical' === t ? 'ns-resize' : 'ew-resize';
  }_f({ type: 'selectDataRange', event: 'dataRangeSelected', update: 'update' }, (e, t) => {
    t.eachComponent({ mainType: 'visualMap', query: e }, (t) => {
      t.setSelected(e.selected);
    });
  }), yf(DL);var nk = WL.extend({ type: 'visualMap.piecewise', defaultOption: { selected: null, minOpen: !1, maxOpen: !1, align: 'auto', itemWidth: 20, itemHeight: 14, itemSymbol: 'roundRect', pieceList: null, categories: null, splitNumber: 5, selectedMode: 'multiple', itemGap: 10, hoverLink: !0, showLabel: null }, optionUpdated(t, e) {
    nk.superApply(this, 'optionUpdated', arguments), this._pieceList = [], this.resetExtent();const i = this._mode = this._determineMode();ok[this._mode].call(this), this._resetSelected(t, e);const n = this.option.categories;this.resetVisual(function (t, e) {
      'categories' === i ? (t.mappingMethod = 'category', t.categories = k(n)) : (t.dataExtent = this.getExtent(), t.mappingMethod = 'piecewise', t.pieceList = O(this._pieceList, (t) => {
        t = k(t);return 'inRange' !== e && (t.visual = null), t;
      }));
    });
  }, completeVisualOption() {
    const n = this.option; const i = {}; const t = g_.listVisualTypes(); const o = this.isCategory();function a(t, e, i) {
      return t && t[e] && (z(t[e]) ? t[e].hasOwnProperty(i) : t[e] === i);
    }R(n.pieces, (e) => {
      R(t, (t) => {
        e.hasOwnProperty(t) && (i[t] = 1);
      });
    }), R(i, function (t, e) {
      let i = 0;R(this.stateList, (t) => {
        i |= a(n, t, e) || a(n.target, t, e);
      }, this), i || R(this.stateList, (t) => {
        (n[t] || (n[t] = {}))[e] = OL(e, 'inRange' === t ? 'active' : 'inactive', o);
      });
    }, this), WL.prototype.completeVisualOption.apply(this, arguments);
  }, _resetSelected(t, e) {
    const i = this.option; const n = this._pieceList; const o = (e ? i : t).selected || {};if (i.selected = o, R(n, function (t, e) {
      const i = this.getSelectedMapKey(t);o.hasOwnProperty(i) || (o[i] = !0);
    }, this), 'single' === i.selectedMode) {
      let a = !1;R(n, function (t, e) {
        const i = this.getSelectedMapKey(t);o[i] && (a ? o[i] = !1 : a = !0);
      }, this);
    }
  }, getSelectedMapKey(t) {
    return 'categories' === this._mode ? `${t.value}` : `${t.index}`;
  }, getPieceList() {
    return this._pieceList;
  }, _determineMode() {
    const t = this.option;return t.pieces && 0 < t.pieces.length ? 'pieces' : this.option.categories ? 'categories' : 'splitNumber';
  }, setSelected(t) {
    this.option.selected = k(t);
  }, getValueState(t) {
    const e = g_.findPieceIndex(t, this._pieceList);return null != e && this.option.selected[this.getSelectedMapKey(this._pieceList[e])] ? 'inRange' : 'outOfRange';
  }, findTargetDataIndices(n) {
    const o = [];return this.eachTargetSeries(function (t) {
      const i = []; const e = t.getData();e.each(this.getDataDimension(e), function (t, e) {
        g_.findPieceIndex(t, this._pieceList) === n && i.push(e);
      }, this), o.push({ seriesId: t.id, dataIndex: i });
    }, this), o;
  }, getRepresentValue(t) {
    let e;if (this.isCategory())e = t.value;else if (null != t.value)e = t.value;else {
      const i = t.interval || [];e = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
    } return e;
  }, getVisualMeta(o) {
    if (!this.isCategory()) {
      var a = []; var r = []; var s = this; const t = this._pieceList.slice();if (t.length) {
        let e = t[0].interval[0];e !== -1 / 0 && t.unshift({ interval: [-1 / 0, e] }), (e = t[t.length - 1].interval[1]) !== 1 / 0 && t.push({ interval: [e, 1 / 0] });
      } else t.push({ interval: [-1 / 0, 1 / 0] });let i = -1 / 0;return R(t, (t) => {
        const e = t.interval;e && (e[0] > i && n([i, e[0]], 'outOfRange'), n(e.slice()), i = e[1]);
      }, this), { stops: a, outerColors: r };
    } function n(t, e) {
      const i = s.getRepresentValue({ interval: t });e = e || s.getValueState(i);const n = o(i, e);t[0] === -1 / 0 ? r[0] = n : t[1] === 1 / 0 ? r[1] = n : a.push({ value: t[0], color: n }, { value: t[1], color: n });
    }
  } }); var ok = { splitNumber() {
    const t = this.option; const e = this._pieceList; let i = Math.min(t.precision, 20); const n = this.getExtent(); let o = t.splitNumber;o = Math.max(parseInt(o, 10), 1), t.splitNumber = o;for (var a = (n[1] - n[0]) / o;+a.toFixed(i) !== a && i < 5;)i++;t.precision = i, a = +a.toFixed(i), t.minOpen && e.push({ interval: [-1 / 0, n[0]], close: [0, 0] });for (let r = 0, s = n[0];r < o;s += a, r++) {
      const l = r === o - 1 ? n[1] : s + a;e.push({ interval: [s, l], close: [1, 1] });
    }t.maxOpen && e.push({ interval: [n[1], 1 / 0], close: [0, 0] }), $l(e), R(e, function (t, e) {
      t.index = e, t.text = this.formatValueText(t.interval);
    }, this);
  }, categories() {
    const t = this.option;R(t.categories, function (t) {
      this._pieceList.push({ text: this.formatValueText(t, !0), value: t });
    }, this), ak(t, this._pieceList);
  }, pieces() {
    const t = this.option; const d = this._pieceList;R(t.pieces, (t, e) => {
      z(t) || (t = { value: t });const i = { text: '', index: e };if (null != t.label && (i.text = t.label), t.hasOwnProperty('value')) {
        const n = i.value = t.value;i.interval = [n, n], i.close = [1, 1];
      } else {
        for (var o = i.interval = [], a = i.close = [0, 0], r = [1, 0, 1], s = [-1 / 0, 1 / 0], l = [], u = 0;u < 2;u++) {
          for (let h = [['gte', 'gt', 'min'], ['lte', 'lt', 'max']][u], c = 0;c < 3 && null == o[u];c++)o[u] = t[h[c]], a[u] = r[c], l[u] = 2 === c;null == o[u] && (o[u] = s[u]);
        }l[0] && o[1] === 1 / 0 && (a[0] = 0), l[1] && o[0] === -1 / 0 && (a[1] = 0), o[0] === o[1] && a[0] && a[1] && (i.value = o[0]);
      }i.visual = g_.retrieveVisuals(t), d.push(i);
    }, this), ak(t, d), $l(d), R(d, function (t) {
      const e = t.close; const i = [['<', '≤'][e[1]], ['>', '≥'][e[0]]];t.text = t.text || this.formatValueText(null != t.value ? t.value : t.interval, !1, i);
    }, this);
  } };function ak(t, e) {
    const i = t.inverse;('vertical' === t.orient ? !i : i) && e.reverse();
  }XL.extend({ type: 'visualMap.piecewise', doRender() {
    const a = this.group;a.removeAll();const r = this.visualMapModel; const s = r.get('textGap'); const t = r.textStyleModel; const l = t.getFont(); const u = t.getTextColor(); const h = this._getItemAlign(); const c = r.itemSize; const e = this._getViewData(); const i = e.endsText; const d = W(r.get('showLabel', !0), !i);i && this._renderEndsText(a, i[0], c, d, h), R(e.viewPieceList, function (t) {
      const e = t.piece; const i = new Ci;i.onclick = A(this._onItemClick, this, e), this._enableHoverLink(i, t.indexInModelPieceList);const n = r.getRepresentValue(e);if (this._createItemSymbol(i, n, [0, 0, c[0], c[1]]), d) {
        const o = this.visualMapModel.getValueState(n);i.add(new Ur({ style: { x: 'right' === h ? -s : c[0] + s, y: c[1] / 2, text: e.text, textVerticalAlign: 'middle', textAlign: h, textFont: l, textFill: u, opacity: 'outOfRange' === o ? .5 : 1 } }));
      }a.add(i);
    }, this), i && this._renderEndsText(a, i[1], c, d, h), wu(r.get('orient'), a, r.get('itemGap')), this.renderBackground(a), this.positionGroup(a);
  }, _enableHoverLink(t, i) {
    function e(t) {
      const e = this.visualMapModel;e.option.hoverLink && this.api.dispatchAction({ type: t, batch: jL(e.findTargetDataIndices(i), e) });
    }t.on('mouseover', A(e, this, 'highlight')).on('mouseout', A(e, this, 'downplay'));
  }, _getItemAlign() {
    const t = this.visualMapModel; const e = t.option;if ('vertical' === e.orient) return YL(t, this.api, t.itemSize);let i = e.align;return i && 'auto' !== i || (i = 'left'), i;
  }, _renderEndsText(t, e, i, n, o) {
    if (e) {
      const a = new Ci; const r = this.visualMapModel.textStyleModel;a.add(new Ur({ style: { x: n ? 'right' === o ? i[0] : 0 : i[0] / 2, y: i[1] / 2, textVerticalAlign: 'middle', textAlign: n ? o : 'center', text: e, textFont: r.getFont(), textFill: r.getTextColor() } })), t.add(a);
    }
  }, _getViewData() {
    const t = this.visualMapModel; const e = O(t.getPieceList(), (t, e) => ({ piece: t, indexInModelPieceList: e })); let i = t.get('text'); const n = t.get('orient'); const o = t.get('inverse');return ('horizontal' === n ? o : !o) ? e.reverse() : i = i && i.slice().reverse(), { viewPieceList: e, endsText: i };
  }, _createItemSymbol(t, e, i) {
    t.add(wg(this.getControllerVisual(e, 'symbol'), i[0], i[1], i[2], i[3], this.getControllerVisual(e, 'color')));
  }, _onItemClick(t) {
    const e = this.visualMapModel; const i = e.option; const n = k(i.selected); const o = e.getSelectedMapKey(t);'single' === i.selectedMode ? (n[o] = !0, R(n, (t, e) => {
      n[e] = e === o;
    })) : n[o] = !n[o], this.api.dispatchAction({ type: 'selectDataRange', from: this.uid, visualMapId: this.visualMapModel.id, selected: n });
  } });yf(DL);let rk; const sk = 'urn:schemas-microsoft-com:vml'; const lk = 'undefined' === typeof window ? null : window; let uk = !1; const hk = lk && lk.document;function ck(t) {
    return rk(t);
  } if (hk && !v.canvasSupported) try {
    hk.namespaces.zrvml || hk.namespaces.add('zrvml', sk), rk = function (t) {
      return hk.createElement(`<zrvml:${t} class="zrvml">`);
    };
  } catch (t) {
    rk = function (t) {
      return hk.createElement(`<${t} xmlns="${sk}" class="zrvml">`);
    };
  } let dk; const fk = rr.CMD; const pk = Math.round; const gk = Math.sqrt; const mk = Math.abs; const vk = Math.cos; const yk = Math.sin; const xk = Math.max;if (!v.canvasSupported) {
    const _k = ','; const wk = 'progid:DXImageTransform.Microsoft'; const bk = 21600; const Sk = bk / 2; const Mk = function (t) {
      t.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;', t.coordsize = `${bk},${bk}`, t.coordorigin = '0,0';
    }; const Ik = function (t, e, i) {
      return `rgb(${[t, e, i].join(',')})`;
    }; const Tk = function (t, e) {
      e && t && e.parentNode !== t && t.appendChild(e);
    }; const Ak = function (t, e) {
      e && t && e.parentNode === t && t.removeChild(e);
    }; const Dk = function (t, e, i) {
      return 1e5 * (parseFloat(t) || 0) + 1e3 * (parseFloat(e) || 0) + i;
    }; const Ck = Yn; const Lk = function (t, e, i) {
      const n = Fe(e);i = +i, isNaN(i) && (i = 1), n && (t.color = Ik(n[0], n[1], n[2]), t.opacity = i * n[3]);
    }; const kk = function (t, e, i, n) {
      const o = 'fill' === e; let a = t.getElementsByTagName(e)[0];null != i[e] && 'none' !== i[e] && (o || !o && i.lineWidth) ? (t[o ? 'filled' : 'stroked'] = 'true', i[e] instanceof cs && Ak(t, a), a = a || ck(e), o ? (function (t, e, i) {
        let n; let o; const a = e.fill;if (null != a) if (a instanceof cs) {
          let r; let s = 0; let l = [0, 0]; let u = 0; let h = 1; const c = i.getBoundingRect(); const d = c.width; const f = c.height;if ('linear' === a.type) {
            r = 'gradient';var p = i.transform; var g = [a.x * d, a.y * f]; const m = [a.x2 * d, a.y2 * f];p && (bt(g, g, p), bt(m, m, p));const v = m[0] - g[0]; const y = m[1] - g[1];(s = 180 * Math.atan2(v, y) / Math.PI) < 0 && (s += 360), s < 1e-6 && (s = 0);
          } else {
            r = 'gradientradial';g = [a.x * d, a.y * f], p = i.transform;const x = i.scale; let _ = d; let w = f;l = [(g[0] - c.x) / _, (g[1] - c.y) / w], p && bt(g, g, p), _ /= x[0] * bk, w /= x[1] * bk;const b = xk(_, w);u = 0 / b, h = 2 * a.r / b - u;
          } const S = a.colorStops.slice();S.sort((t, e) => t.offset - e.offset);for (var M = S.length, I = [], T = [], A = 0;A < M;A++) {
            const D = S[A]; const C = (n = D.color, void 0, o = Fe(n), [Ik(o[0], o[1], o[2]), o[3]]);T.push(`${D.offset * h + u} ${C[0]}`), 0 !== A && A !== M - 1 || I.push(C);
          } if (2 <= M) {
            const L = I[0][0]; const k = I[1][0]; const P = I[0][1] * e.opacity; const N = I[1][1] * e.opacity;t.type = r, t.method = 'none', t.focus = '100%', t.angle = s, t.color = L, t.color2 = k, t.colors = T.join(','), t.opacity = N, t.opacity2 = P;
          }'radial' === r && (t.focusposition = l.join(','));
        } else Lk(t, a, e.opacity);
      }(a, i, n)) : (function (t, e) {
        e.lineDash && (t.dashstyle = e.lineDash.join(' ')), null == e.stroke || e.stroke instanceof cs || Lk(t, e.stroke, e.opacity);
      }(a, i)), Tk(t, a)) : (t[o ? 'filled' : 'stroked'] = 'false', Ak(t, a));
    }; const Pk = [[], [], []];Ar.prototype.brushVML = function (t) {
      const e = this.style; let i = this._vmlEl;i || (i = ck('shape'), Mk(i), this._vmlEl = i), kk(i, 'fill', e, this), kk(i, 'stroke', e, this);const n = this.transform; const o = null != n; const a = i.getElementsByTagName('stroke')[0];if (a) {
        let r = e.lineWidth;if (o && !e.strokeNoScale) {
          const s = n[0] * n[3] - n[1] * n[2];r *= gk(mk(s));
        }a.weight = `${r}px`;
      } const l = this.path || (this.path = new rr);this.__dirtyPath && (l.beginPath(), l.subPixelOptimize = !1, this.buildPath(l, this.shape), l.toStatic(), this.__dirtyPath = !1), i.path = (function (t, e) {
        let i; let n; let o; let a; let r; let s; const l = fk.M; const u = fk.C; const h = fk.L; const c = fk.A; const d = fk.Q; const f = []; const p = t.data; const g = t.len();for (a = 0;a < g;) {
          switch (n = '', i = 0, o = p[a++]) {
            case l:n = ' m ', i = 1, r = p[a++], s = p[a++], Pk[0][0] = r, Pk[0][1] = s;break;case h:n = ' l ', i = 1, r = p[a++], s = p[a++], Pk[0][0] = r, Pk[0][1] = s;break;case d:case u:n = ' c ', i = 3;var m; var v; var y = p[a++]; var x = p[a++]; var _ = p[a++]; var w = p[a++];o === d ? (_ = ((m = _) + 2 * y) / 3, w = ((v = w) + 2 * x) / 3, y = (r + 2 * y) / 3, x = (s + 2 * x) / 3) : (m = p[a++], v = p[a++]), Pk[0][0] = y, Pk[0][1] = x, Pk[1][0] = _, Pk[1][1] = w, r = Pk[2][0] = m, s = Pk[2][1] = v;break;case c:var b = 0; var S = 0; var M = 1; var I = 1; var T = 0;e && (b = e[4], S = e[5], M = gk(e[0] * e[0] + e[1] * e[1]), I = gk(e[2] * e[2] + e[3] * e[3]), T = Math.atan2(-e[1] / I, e[0] / M));var A = p[a++]; var D = p[a++]; var C = p[a++]; var L = p[a++]; var k = p[a++] + T; var P = p[a++] + k + T;a++;var N = p[a++]; var O = A + vk(k) * C; var R = D + yk(k) * L; var E = (y = A + vk(P) * C, x = D + yk(P) * L, N ? ' wa ' : ' at ');Math.abs(O - y) < 1e-4 && (.01 < Math.abs(P - k) ? N && (O += .0125) : Math.abs(R - D) < 1e-4 ? N && O < A || !N && A < O ? x -= .0125 : x += .0125 : N && R < D || !N && D < R ? y += .0125 : y -= .0125), f.push(E, pk(((A - C) * M + b) * bk - Sk), _k, pk(((D - L) * I + S) * bk - Sk), _k, pk(((A + C) * M + b) * bk - Sk), _k, pk(((D + L) * I + S) * bk - Sk), _k, pk((O * M + b) * bk - Sk), _k, pk((R * I + S) * bk - Sk), _k, pk((y * M + b) * bk - Sk), _k, pk((x * I + S) * bk - Sk)), r = y, s = x;break;case fk.R:var z = Pk[0]; var B = Pk[1];z[0] = p[a++], z[1] = p[a++], B[0] = z[0] + p[a++], B[1] = z[1] + p[a++], e && (bt(z, z, e), bt(B, B, e)), z[0] = pk(z[0] * bk - Sk), B[0] = pk(B[0] * bk - Sk), z[1] = pk(z[1] * bk - Sk), B[1] = pk(B[1] * bk - Sk), f.push(' m ', z[0], _k, z[1], ' l ', B[0], _k, z[1], ' l ', B[0], _k, B[1], ' l ', z[0], _k, B[1]);break;case fk.Z:f.push(' x ');
          } if (0 < i) {
            f.push(n);for (let V = 0;V < i;V++) {
              const G = Pk[V];e && bt(G, G, e), f.push(pk(G[0] * bk - Sk), _k, pk(G[1] * bk - Sk), V < i - 1 ? _k : '');
            }
          }
        } return f.join('');
      }(l, this.transform)), i.style.zIndex = Dk(this.zlevel, this.z, this.z2), Tk(t, i), null != e.text ? this.drawRectText(t, this.getBoundingRect()) : this.removeRectText(t);
    }, Ar.prototype.onRemove = function (t) {
      Ak(t, this._vmlEl), this.removeRectText(t);
    }, Ar.prototype.onAdd = function (t) {
      Tk(t, this._vmlEl), this.appendRectText(t);
    };Qn.prototype.brushVML = function (t) {
      let e; let i; const n = this.style; let o = n.image;if (function (t) {
        return 'object' === typeof t && t.tagName && 'IMG' === t.tagName.toUpperCase();
      }(o)) {
        const a = o.src;if (a === this._imageSrc)e = this._imageWidth, i = this._imageHeight;else {
          const r = o.runtimeStyle; const s = r.width; const l = r.height;r.width = 'auto', r.height = 'auto', e = o.width, i = o.height, r.width = s, r.height = l, this._imageSrc = a, this._imageWidth = e, this._imageHeight = i;
        }o = a;
      } else o === this._imageSrc && (e = this._imageWidth, i = this._imageHeight);if (o) {
        let u = n.x || 0; let h = n.y || 0; const c = n.width; const d = n.height; const f = n.sWidth; const p = n.sHeight; const g = n.sx || 0; const m = n.sy || 0; const v = f && p; let y = this._vmlEl;y || (y = hk.createElement('div'), Mk(y), this._vmlEl = y);let x; const _ = y.style; let w = !1; let b = 1; let S = 1;if (this.transform && (x = this.transform, b = gk(x[0] * x[0] + x[1] * x[1]), S = gk(x[2] * x[2] + x[3] * x[3]), w = x[1] || x[2]), w) {
          const M = [u, h]; const I = [u + c, h]; const T = [u, h + d]; const A = [u + c, h + d];bt(M, M, x), bt(I, I, x), bt(T, T, x), bt(A, A, x);const D = xk(M[0], I[0], T[0], A[0]); const C = xk(M[1], I[1], T[1], A[1]); const L = [];L.push('M11=', x[0] / b, _k, 'M12=', x[2] / S, _k, 'M21=', x[1] / b, _k, 'M22=', x[3] / S, _k, 'Dx=', pk(u * b + x[4]), _k, 'Dy=', pk(h * S + x[5])), _.padding = `0 ${pk(D)}px ${pk(C)}px 0`, _.filter = `${wk}.Matrix(${L.join('')}, SizingMethod=clip)`;
        } else x && (u = u * b + x[4], h = h * S + x[5]), _.filter = '', _.left = `${pk(u)}px`, _.top = `${pk(h)}px`;let k = this._imageEl; let P = this._cropEl;k || (k = hk.createElement('div'), this._imageEl = k);const N = k.style;if (v) {
          if (e && i)N.width = `${pk(b * e * c / f)}px`, N.height = `${pk(S * i * d / p)}px`;else {
            const O = new Image; const R = this;O.onload = function () {
              O.onload = null, e = O.width, i = O.height, N.width = `${pk(b * e * c / f)}px`, N.height = `${pk(S * i * d / p)}px`, R._imageWidth = e, R._imageHeight = i, R._imageSrc = o;
            }, O.src = o;
          }P || ((P = hk.createElement('div')).style.overflow = 'hidden', this._cropEl = P);const E = P.style;E.width = pk((c + g * c / f) * b), E.height = pk((d + m * d / p) * S), E.filter = `${wk}.Matrix(Dx=${-g * c / f * b},Dy=${-m * d / p * S})`, P.parentNode || y.appendChild(P), k.parentNode !== P && P.appendChild(k);
        } else N.width = `${pk(b * c)}px`, N.height = `${pk(S * d)}px`, y.appendChild(k), P && P.parentNode && (y.removeChild(P), this._cropEl = null);let z = ''; const B = n.opacity;B < 1 && (z += `.Alpha(opacity=${pk(100 * B)}) `), z += `${wk}.AlphaImageLoader(src=${o}, SizingMethod=scale)`, N.filter = z, y.style.zIndex = Dk(this.zlevel, this.z, this.z2), Tk(t, y), null != n.text && this.drawRectText(t, this.getBoundingRect());
      }
    }, Qn.prototype.onRemove = function (t) {
      Ak(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, this.removeRectText(t);
    }, Qn.prototype.onAdd = function (t) {
      Tk(t, this._vmlEl), this.appendRectText(t);
    };let Nk; const Ok = 'normal'; let Rk = {}; let Ek = 0; const zk = document.createElement('div');dk = function (t, e) {
      const i = hk;Nk || ((Nk = i.createElement('div')).style.cssText = 'position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;', hk.body.appendChild(Nk));try {
        Nk.style.font = e;
      } catch (t) {} return Nk.innerHTML = '', Nk.appendChild(i.createTextNode(t)), { width: Nk.offsetWidth };
    }, fn.measureText = dk;for (var Bk = new Di, Vk = function (t, e, i, n) {
        const o = this.style;this.__dirty && Rn(o);let a = o.text;if (null != a && (a += ''), a) {
          if (o.rich) {
            const r = In(a, o);a = [];for (let s = 0;s < r.lines.length;s++) {
              for (var l = r.lines[s].tokens, u = [], h = 0;h < l.length;h++)u.push(l[h].text);a.push(u.join(''));
            }a = a.join('\n');
          } let c; let d; let f = o.textAlign; let p = o.textVerticalAlign; const g = (function (t) {
            let e = Rk[t];if (!e) {
              100 < Ek && (Ek = 0, Rk = {});let i; const n = zk.style;try {
                n.font = t, i = n.fontFamily.split(',')[0];
              } catch (t) {}e = { style: n.fontStyle || Ok, variant: n.fontVariant || Ok, weight: n.fontWeight || Ok, size: 0 | parseFloat(n.fontSize || 12), family: i || 'Microsoft YaHei' }, Rk[t] = e, Ek++;
            } return e;
          }(o.font)); const m = `${g.style} ${g.variant} ${g.weight} ${g.size}px "${g.family}"`;i = i || gn(a, m, f, p, o.textPadding, o.textLineHeight);const v = this.transform;if (v && !n && (Bk.copy(e), Bk.applyTransform(v), e = Bk), n)c = e.x, d = e.y;else {
            const y = o.textPosition;if (y instanceof Array)c = e.x + Ck(y[0], e.width), d = e.y + Ck(y[1], e.height), f = f || 'left';else {
              const x = this.calculateTextPosition ? this.calculateTextPosition({}, o, e) : yn({}, o, e);c = x.x, d = x.y, f = f || x.textAlign, p = p || x.textVerticalAlign;
            }
          }c = mn(c, i.width, f), d = vn(d, i.height, p), d += i.height / 2;let _; let w; let b; const S = ck; let M = this._textVmlEl;M ? w = (_ = (b = M.firstChild).nextSibling).nextSibling : (M = S('line'), _ = S('path'), w = S('textpath'), b = S('skew'), w.style['v-text-align'] = 'left', Mk(M), _.textpathok = !0, w.on = !0, M.from = '0 0', M.to = '1000 0.05', Tk(M, b), Tk(M, _), Tk(M, w), this._textVmlEl = M);const I = [c, d]; const T = M.style;v && n ? (bt(I, I, v), b.on = !0, b.matrix = `${v[0].toFixed(3) + _k + v[2].toFixed(3) + _k + v[1].toFixed(3) + _k + v[3].toFixed(3)},0,0`, b.offset = `${pk(I[0]) || 0},${pk(I[1]) || 0}`, b.origin = '0 0', T.left = '0px', T.top = '0px') : (b.on = !1, T.left = `${pk(c)}px`, T.top = `${pk(d)}px`), w.string = (function (t) {
            return String(t).replace(/&/g, '&amp;')
              .replace(/"/g, '&quot;');
          }(a));try {
            w.style.font = m;
          } catch (t) {}kk(M, 'fill', { fill: o.textFill, opacity: o.opacity }, this), kk(M, 'stroke', { stroke: o.textStroke, opacity: o.opacity, lineDash: o.lineDash || null }, this), M.style.zIndex = Dk(this.zlevel, this.z, this.z2), Tk(t, M);
        }
      }, Gk = function (t) {
        Ak(t, this._textVmlEl), this._textVmlEl = null;
      }, Fk = function (t) {
        Tk(t, this._textVmlEl);
      }, Wk = [Kn, Jn, Qn, Ar, Ur], Hk = 0;Hk < Wk.length;Hk++) {
      const Zk = Wk[Hk].prototype;Zk.drawRectText = Vk, Zk.removeRectText = Gk, Zk.appendRectText = Fk;
    }Ur.prototype.brushVML = function (t) {
      const e = this.style;null != e.text ? this.drawRectText(t, { x: e.x || 0, y: e.y || 0, width: 0, height: 0 }, this.getBoundingRect(), !0) : this.removeRectText(t);
    }, Ur.prototype.onRemove = function (t) {
      this.removeRectText(t);
    }, Ur.prototype.onAdd = function (t) {
      this.appendRectText(t);
    };
  } function Uk(t) {
    return parseInt(t, 10);
  } function Xk(t, e) {
    !(function () {
      if (!uk && hk) {
        uk = !0;const t = hk.styleSheets;t.length < 31 ? hk.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)') : t[0].addRule('.zrvml', 'behavior:url(#default#VML)');
      }
    }()), this.root = t, this.storage = e;const i = document.createElement('div'); const n = document.createElement('div');i.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;', n.style.cssText = 'position:absolute;left:0;top:0;', t.appendChild(i), this._vmlRoot = n, this._vmlViewport = i, this.resize();const o = e.delFromStorage; const a = e.addToStorage;e.delFromStorage = function (t) {
      o.call(e, t), t && t.onRemove && t.onRemove(n);
    }, e.addToStorage = function (t) {
      t.onAdd && t.onAdd(n), a.call(e, t);
    }, this._firstPaint = !0;
  }Xk.prototype = { constructor: Xk, getType() {
    return 'vml';
  }, getViewportRoot() {
    return this._vmlViewport;
  }, getViewportRootOffset() {
    const t = this.getViewportRoot();if (t) return { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 };
  }, refresh() {
    const t = this.storage.getDisplayList(!0, !0);this._paintList(t);
  }, _paintList(t) {
    for (var e = this._vmlRoot, i = 0;i < t.length;i++) {
      const n = t[i];n.invisible || n.ignore ? (n.__alreadyNotVisible || n.onRemove(e), n.__alreadyNotVisible = !0) : (n.__alreadyNotVisible && n.onAdd(e), n.__alreadyNotVisible = !1, n.__dirty && (n.beforeBrush && n.beforeBrush(), (n.brushVML || n.brush).call(n, e), n.afterBrush && n.afterBrush())), n.__dirty = !1;
    } this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1);
  }, resize(t, e) {
    t = null == t ? this._getWidth() : t, e = null == e ? this._getHeight() : e;if (this._width !== t || this._height !== e) {
      this._width = t, this._height = e;const i = this._vmlViewport.style;i.width = `${t}px`, i.height = `${e}px`;
    }
  }, dispose() {
    this.root.innerHTML = '', this._vmlRoot = this._vmlViewport = this.storage = null;
  }, getWidth() {
    return this._width;
  }, getHeight() {
    return this._height;
  }, clear() {
    this._vmlViewport && this.root.removeChild(this._vmlViewport);
  }, _getWidth() {
    const t = this.root; const e = t.currentStyle;return (t.clientWidth || Uk(e.width)) - Uk(e.paddingLeft) - Uk(e.paddingRight) | 0;
  }, _getHeight() {
    const t = this.root; const e = t.currentStyle;return (t.clientHeight || Uk(e.height)) - Uk(e.paddingTop) - Uk(e.paddingBottom) | 0;
  } }, R(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], (t) => {
    Xk.prototype[t] = (function (t) {
      return function () {
        vi(`In IE8.0 VML mode painter not support method "${t}"`);
      };
    }(t));
  }), Po('vml', Xk);function Yk(t) {
    return document.createElementNS('http://www.w3.org/2000/svg', t);
  } const jk = rr.CMD; const qk = Array.prototype.join; const Kk = 'none'; const $k = Math.round; const Jk = Math.sin; const Qk = Math.cos; const tP = Math.PI; const eP = 2 * Math.PI; const iP = 180 / tP; const nP = 1e-4;function oP(t) {
    return $k(1e4 * t) / 1e4;
  } function aP(t) {
    return t < nP && -nP < t;
  } function rP(t, e) {
    e && sP(t, 'transform', `matrix(${qk.call(e, ',')})`);
  } function sP(t, e, i) {
    i && ('linear' === i.type || 'radial' === i.type) || t.setAttribute(e, i);
  } function lP(t, e, i, n) {
    if (function (t, e) {
      const i = e ? t.textFill : t.fill;return null != i && i !== Kk;
    }(e, i)) {
      let o = i ? e.textFill : e.fill;sP(t, 'fill', o = 'transparent' === o ? Kk : o), sP(t, 'fill-opacity', null != e.fillOpacity ? e.fillOpacity * e.opacity : e.opacity);
    } else sP(t, 'fill', Kk);if (function (t, e) {
      const i = e ? t.textStroke : t.stroke;return null != i && i !== Kk;
    }(e, i)) {
      let a = i ? e.textStroke : e.stroke;sP(t, 'stroke', a = 'transparent' === a ? Kk : a), sP(t, 'stroke-width', (i ? e.textStrokeWidth : e.lineWidth) / (!i && e.strokeNoScale ? n.getLineScale() : 1)), sP(t, 'paint-order', i ? 'stroke' : 'fill'), sP(t, 'stroke-opacity', null != e.strokeOpacity ? e.strokeOpacity : e.opacity), e.lineDash ? (sP(t, 'stroke-dasharray', e.lineDash.join(',')), sP(t, 'stroke-dashoffset', $k(e.lineDashOffset || 0))) : sP(t, 'stroke-dasharray', ''), e.lineCap && sP(t, 'stroke-linecap', e.lineCap), e.lineJoin && sP(t, 'stroke-linejoin', e.lineJoin), e.miterLimit && sP(t, 'stroke-miterlimit', e.miterLimit);
    } else sP(t, 'stroke', Kk);
  } const uP = {};uP.brush = function (t) {
    const e = t.style; let i = t.__svgEl;i || (i = Yk('path'), t.__svgEl = i), t.path || t.createPathProxy();const n = t.path;if (t.__dirtyPath) {
      n.beginPath(), n.subPixelOptimize = !1, t.buildPath(n, t.shape), t.__dirtyPath = !1;const o = (function (t) {
        for (var e = [], i = t.data, n = t.len(), o = 0;o < n;) {
          let a = ''; let r = 0;switch (i[o++]) {
            case jk.M:a = 'M', r = 2;break;case jk.L:a = 'L', r = 2;break;case jk.Q:a = 'Q', r = 4;break;case jk.C:a = 'C', r = 6;break;case jk.A:var s = i[o++]; var l = i[o++]; var u = i[o++]; var h = i[o++]; var c = i[o++]; var d = i[o++]; var f = i[o++]; var p = i[o++]; var g = Math.abs(d); var m = aP(g - eP) || (p ? eP <= d : eP <= -d); var v = 0 < d ? d % eP : d % eP + eP; var y = !1;y = !!m || !aP(g) && tP <= v == !!p;var x = oP(s + u * Qk(c)); var _ = oP(l + h * Jk(c));m && (d = p ? eP - 1e-4 : 1e-4 - eP, y = !0, 9 === o && e.push('M', x, _));var w = oP(s + u * Qk(c + d)); var b = oP(l + h * Jk(c + d));e.push('A', oP(u), oP(h), $k(f * iP), +y, +p, w, b);break;case jk.Z:a = 'Z';break;case jk.R:w = oP(i[o++]), b = oP(i[o++]);var S = oP(i[o++]); var M = oP(i[o++]);e.push('M', w, b, 'L', w + S, b, 'L', w + S, b + M, 'L', w, b + M, 'L', w, b);
          }a && e.push(a);for (let I = 0;I < r;I++)e.push(oP(i[o++]));
        } return e.join(' ');
      }(n));o.indexOf('NaN') < 0 && sP(i, 'd', o);
    }lP(i, e, !1, t), rP(i, t.transform), null != e.text ? mP(t, t.getBoundingRect()) : yP(t);
  };const hP = { brush(t) {
    const e = t.style; let i = e.image;i instanceof HTMLImageElement && (i = i.src);if (i) {
      const n = e.x || 0; const o = e.y || 0; const a = e.width; const r = e.height; let s = t.__svgEl;s || (s = Yk('image'), t.__svgEl = s), i !== t.__imageSrc && ((function (t, e, i) {
        t.setAttributeNS('http://www.w3.org/1999/xlink', e, i);
      }(s, 'href', i)), t.__imageSrc = i), sP(s, 'width', a), sP(s, 'height', r), sP(s, 'x', n), sP(s, 'y', o), rP(s, t.transform), null != e.text ? mP(t, t.getBoundingRect()) : yP(t);
    }
  } }; const cP = {}; const dP = new Di; const fP = {}; const pP = []; const gP = { left: 'start', right: 'end', center: 'middle', middle: 'middle' }; var mP = function (t, e) {
    const i = t.style; const n = t.transform; const o = t instanceof Ur || i.transformText;t.__dirty && Rn(i);let a = i.text;if (null != a && (a += ''), qn(a, i)) {
      null == a && (a = ''), !o && n && (dP.copy(e), dP.applyTransform(n), e = dP);let r = t.__textSvgEl;r || (r = Yk('text'), t.__textSvgEl = r);const s = r.style; const l = i.font || dn; let u = r.__computedFont;l !== r.__styleFont && (s.font = r.__styleFont = l, u = r.__computedFont = s.font);const h = i.textPadding; const c = i.textLineHeight; let d = t.__textCotentBlock;d && !t.__dirtyText || (d = t.__textCotentBlock = Mn(a, u, h, c, i.truncate));const f = d.outerHeight; const p = d.lineHeight;Hn(fP, t, i, e);const g = fP.baseX; const m = fP.baseY; const v = fP.textAlign || 'left'; const y = fP.textVerticalAlign;!(function (t, e, i, n, o, a, r) {
        re(pP), e && i && se(pP, i);const s = n.textRotation;if (o && s) {
          const l = n.textOrigin;'center' === l ? (a = o.width / 2 + o.x, r = o.height / 2 + o.y) : l && (a = l[0] + o.x, r = l[1] + o.y), pP[4] -= a, pP[5] -= r, he(pP, pP, s), pP[4] += a, pP[5] += r;
        }rP(t, pP);
      }(r, o, n, i, e, g, m));let x = g; let _ = vn(m, f, y);h && (x = (function (t, e, i) {
        return 'right' === e ? t - i[1] : 'center' === e ? t + i[3] / 2 - i[1] / 2 : t + i[3];
      }(g, v, h)), _ += h[0]), _ += p / 2, lP(r, i, !0, t);const w = d.canCacheByTextString; const b = t.__tspanList || (t.__tspanList = []); const S = b.length;if (w && t.__canCacheByTextString && t.__text === a) {
        if (t.__dirtyText && S) for (var M = 0;M < S;++M)vP(b[M], v, x, _ + M * p);
      } else {
        t.__text = a, t.__canCacheByTextString = w;const I = d.lines; const T = I.length;for (M = 0;M < T;M++) {
          let A = b[M]; const D = I[M];A ? A.__zrText !== D && (A.innerHTML = '', A.appendChild(document.createTextNode(D))) : (A = b[M] = Yk('tspan'), r.appendChild(A), A.appendChild(document.createTextNode(D))), vP(A, v, x, _ + M * p);
        } if (T < S) {
          for (;M < S;M++)r.removeChild(b[M]);b.length = T;
        }
      }
    }
  };function vP(t, e, i, n) {
    sP(t, 'dominant-baseline', 'middle'), sP(t, 'text-anchor', gP[e]), sP(t, 'x', i), sP(t, 'y', n);
  } function yP(t) {
    t && t.__textSvgEl && (t.__textSvgEl.parentNode && t.__textSvgEl.parentNode.removeChild(t.__textSvgEl), t.__textSvgEl = null, t.__tspanList = [], t.__text = null);
  } function xP() {} function _P(t, e) {
    for (let i = 0, n = e.length, o = 0, a = 0;i < n;i++) {
      const r = e[i];if (r.removed) {
        for (s = [], l = a;l < a + r.count;l++)s.push(l);r.indices = s, a += r.count;
      } else {
        for (var s = [], l = o;l < o + r.count;l++)s.push(l);r.indices = s, o += r.count, r.added || (a += r.count);
      }
    } return e;
  }cP.drawRectText = mP, cP.brush = function (t) {
    null != t.style.text ? mP(t, !1) : yP(t);
  }, xP.prototype = { diff(l, u, t) {
    t = t || function (t, e) {
      return t === e;
    }, this.equals = t;const h = this;l = l.slice();const c = (u = u.slice()).length; const d = l.length; let f = 1; const e = c + d; const p = [{ newPos: -1, components: [] }]; const i = this.extractCommon(p[0], u, l, 0);if (p[0].newPos + 1 >= c && d <= i + 1) {
      for (var n = [], o = 0;o < u.length;o++)n.push(o);return [{ indices: n, count: u.length }];
    } function a() {
      for (let t = -1 * f;t <= f;t += 2) {
        var e; const i = p[t - 1]; const n = p[t + 1]; let o = (n ? n.newPos : 0) - t;i && (p[t - 1] = void 0);const a = i && i.newPos + 1 < c; const r = n && 0 <= o && o < d;if (a || r) {
          if (!a || r && i.newPos < n.newPos ? (e = { newPos: (s = n).newPos, components: s.components.slice(0) }, h.pushComponent(e.components, void 0, !0)) : ((e = i).newPos++, h.pushComponent(e.components, !0, void 0)), o = h.extractCommon(e, u, l, t), e.newPos + 1 >= c && d <= o + 1) return _P(h, e.components, u, l);p[t] = e;
        } else p[t] = void 0;
      } let s;f++;
    } for (;f <= e;) {
      const r = a();if (r) return r;
    }
  }, pushComponent(t, e, i) {
    const n = t[t.length - 1];n && n.added === e && n.removed === i ? t[t.length - 1] = { count: n.count + 1, added: e, removed: i } : t.push({ count: 1, added: e, removed: i });
  }, extractCommon(t, e, i, n) {
    for (var o = e.length, a = i.length, r = t.newPos, s = r - n, l = 0;r + 1 < o && s + 1 < a && this.equals(e[r + 1], i[s + 1]);)r++, s++, l++;return l && t.components.push({ count: l }), t.newPos = r, s;
  }, tokenize(t) {
    return t.slice();
  }, join(t) {
    return t.slice();
  } };const wP = new xP;function bP(t, e, i, n, o) {
    this._zrId = t, this._svgRoot = e, this._tagNames = 'string' === typeof i ? [i] : i, this._markLabel = n, this._domName = o || '_dom', this.nextId = 0;
  } function SP(t, e) {
    bP.call(this, t, e, ['linearGradient', 'radialGradient'], '__gradient_in_use__');
  } function MP(t, e) {
    bP.call(this, t, e, 'clipPath', '__clippath_in_use__');
  } function IP(t, e) {
    bP.call(this, t, e, ['filter'], '__filter_in_use__', '_shadowDom');
  } function TP(t) {
    return t && (t.shadowBlur || t.shadowOffsetX || t.shadowOffsetY || t.textShadowBlur || t.textShadowOffsetX || t.textShadowOffsetY);
  } function AP(t) {
    return parseInt(t, 10);
  } function DP(t, e) {
    return e && t && e.parentNode !== t;
  } function CP(t, e, i) {
    if (DP(t, e) && i) {
      const n = i.nextSibling;n ? t.insertBefore(e, n) : t.appendChild(e);
    }
  } function LP(t, e) {
    if (DP(t, e)) {
      const i = t.firstChild;i ? t.insertBefore(e, i) : t.appendChild(e);
    }
  } function kP(t, e) {
    e && t && e.parentNode === t && t.removeChild(e);
  } function PP(t) {
    return t.__textSvgEl;
  } function NP(t) {
    return t.__svgEl;
  }bP.prototype.createElement = Yk, bP.prototype.getDefs = function (t) {
    const e = this._svgRoot; let n = this._svgRoot.getElementsByTagName('defs');return 0 === n.length ? t ? ((n = e.insertBefore(this.createElement('defs'), e.firstChild)).contains || (n.contains = function (t) {
      const e = n.children;if (!e) return !1;for (let i = e.length - 1;0 <= i;--i) if (e[i] === t) return !0;return !1;
    }), n) : null : n[0];
  }, bP.prototype.update = function (t, e) {
    if (t) {
      const i = this.getDefs(!1);if (t[this._domName] && i.contains(t[this._domName]))'function' === typeof e && e(t);else {
        const n = this.add(t);n && (t[this._domName] = n);
      }
    }
  }, bP.prototype.addDom = function (t) {
    this.getDefs(!0).appendChild(t);
  }, bP.prototype.removeDom = function (t) {
    const e = this.getDefs(!1);e && t[this._domName] && (e.removeChild(t[this._domName]), t[this._domName] = null);
  }, bP.prototype.getDoms = function () {
    const i = this.getDefs(!1);if (!i) return [];let n = [];return R(this._tagNames, (t) => {
      const e = i.getElementsByTagName(t);n = n.concat([].slice.call(e));
    }), n;
  }, bP.prototype.markAllUnused = function () {
    const t = this.getDoms(); const e = this;R(t, (t) => {
      t[e._markLabel] = '0';
    });
  }, bP.prototype.markUsed = function (t) {
    t && (t[this._markLabel] = '1');
  }, bP.prototype.removeUnused = function () {
    const e = this.getDefs(!1);if (e) {
      const t = this.getDoms(); const i = this;R(t, (t) => {
        '1' !== t[i._markLabel] && e.removeChild(t);
      });
    }
  }, bP.prototype.getSvgProxy = function (t) {
    return t instanceof Ar ? uP : t instanceof Qn ? hP : t instanceof Ur ? cP : uP;
  }, bP.prototype.getTextSvgElement = function (t) {
    return t.__textSvgEl;
  }, bP.prototype.getSvgElement = function (t) {
    return t.__svgEl;
  }, w(SP, bP), SP.prototype.addWithoutUpdate = function (a, r) {
    if (r && r.style) {
      const s = this;R(['fill', 'stroke'], (t) => {
        if (r.style[t] && ('linear' === r.style[t].type || 'radial' === r.style[t].type)) {
          let e; const i = r.style[t]; const n = s.getDefs(!0);i._dom ? (e = i._dom, n.contains(i._dom) || s.addDom(e)) : e = s.add(i), s.markUsed(r);const o = e.getAttribute('id');a.setAttribute(t, `url(#${o})`);
        }
      });
    }
  }, SP.prototype.add = function (t) {
    let e;if ('linear' === t.type)e = this.createElement('linearGradient');else {
      if ('radial' !== t.type) return vi('Illegal gradient type.'), null;e = this.createElement('radialGradient');
    } return t.id = t.id || this.nextId++, e.setAttribute('id', `zr${this._zrId}-gradient-${t.id}`), this.updateDom(t, e), this.addDom(e), e;
  }, SP.prototype.update = function (i) {
    const n = this;bP.prototype.update.call(this, i, () => {
      const t = i.type; const e = i._dom.tagName;'linear' === t && 'linearGradient' === e || 'radial' === t && 'radialGradient' === e ? n.updateDom(i, i._dom) : (n.removeDom(i), n.add(i));
    });
  }, SP.prototype.updateDom = function (t, e) {
    if ('linear' === t.type)e.setAttribute('x1', t.x), e.setAttribute('y1', t.y), e.setAttribute('x2', t.x2), e.setAttribute('y2', t.y2);else {
      if ('radial' !== t.type) return void vi('Illegal gradient type.');e.setAttribute('cx', t.x), e.setAttribute('cy', t.y), e.setAttribute('r', t.r);
    }t.global ? e.setAttribute('gradientUnits', 'userSpaceOnUse') : e.setAttribute('gradientUnits', 'objectBoundingBox'), e.innerHTML = '';for (let i = t.colorStops, n = 0, o = i.length;n < o;++n) {
      const a = this.createElement('stop');a.setAttribute('offset', `${100 * i[n].offset}%`);const r = i[n].color;if (-1 < r.indexOf('rgba')) {
        const s = Fe(r)[3]; const l = Ze(r);a.setAttribute('stop-color', `#${l}`), a.setAttribute('stop-opacity', s);
      } else a.setAttribute('stop-color', i[n].color);e.appendChild(a);
    }t._dom = e;
  }, SP.prototype.markUsed = function (t) {
    if (t.style) {
      let e = t.style.fill;e && e._dom && bP.prototype.markUsed.call(this, e._dom), (e = t.style.stroke) && e._dom && bP.prototype.markUsed.call(this, e._dom);
    }
  }, w(MP, bP), MP.prototype.update = function (t) {
    const e = this.getSvgElement(t);e && this.updateDom(e, t.__clipPaths, !1);const i = this.getTextSvgElement(t);i && this.updateDom(i, t.__clipPaths, !0), this.markUsed(t);
  }, MP.prototype.updateDom = function (t, e, i) {
    if (e && 0 < e.length) {
      let n; let o; const a = this.getDefs(!0); const r = e[0]; const s = i ? '_textDom' : '_dom';r[s] ? (o = r[s].getAttribute('id'), n = r[s], a.contains(n) || a.appendChild(n)) : (o = `zr${this._zrId}-clip-${this.nextId}`, ++this.nextId, (n = this.createElement('clipPath')).setAttribute('id', o), a.appendChild(n), r[s] = n);const l = this.getSvgProxy(r);if (r.transform && r.parent.invTransform && !i) {
        const u = Array.prototype.slice.call(r.transform);le(r.transform, r.parent.invTransform, r.transform), l.brush(r), r.transform = u;
      } else l.brush(r);const h = this.getSvgElement(r);n.innerHTML = '', n.appendChild(h.cloneNode()), t.setAttribute('clip-path', `url(#${o})`), 1 < e.length && this.updateDom(n, e.slice(1), i);
    } else t && t.setAttribute('clip-path', 'none');
  }, MP.prototype.markUsed = function (t) {
    const e = this;t.__clipPaths && R(t.__clipPaths, (t) => {
      t._dom && bP.prototype.markUsed.call(e, t._dom), t._textDom && bP.prototype.markUsed.call(e, t._textDom);
    });
  }, w(IP, bP), IP.prototype.addWithoutUpdate = function (t, e) {
    if (e && TP(e.style)) {
      let i;if (e._shadowDom)i = e._shadowDom, this.getDefs(!0).contains(e._shadowDom) || this.addDom(i);else i = this.add(e);this.markUsed(e);const n = i.getAttribute('id');t.style.filter = `url(#${n})`;
    }
  }, IP.prototype.add = function (t) {
    const e = this.createElement('filter');return t._shadowDomId = t._shadowDomId || this.nextId++, e.setAttribute('id', `zr${this._zrId}-shadow-${t._shadowDomId}`), this.updateDom(t, e), this.addDom(e), e;
  }, IP.prototype.update = function (t, e) {
    if (TP(e.style)) {
      const i = this;bP.prototype.update.call(this, e, () => {
        i.updateDom(e, e._shadowDom);
      });
    } else this.remove(t, e);
  }, IP.prototype.remove = function (t, e) {
    null != e._shadowDomId && (this.removeDom(t), t.style.filter = '');
  }, IP.prototype.updateDom = function (t, e) {
    let i = e.getElementsByTagName('feDropShadow');i = 0 === i.length ? this.createElement('feDropShadow') : i[0];let n; let o; let a; let r; const s = t.style; const l = t.scale && t.scale[0] || 1; const u = t.scale && t.scale[1] || 1;if (s.shadowBlur || s.shadowOffsetX || s.shadowOffsetY)n = s.shadowOffsetX || 0, o = s.shadowOffsetY || 0, a = s.shadowBlur, r = s.shadowColor;else {
      if (!s.textShadowBlur) return void this.removeDom(e, s);n = s.textShadowOffsetX || 0, o = s.textShadowOffsetY || 0, a = s.textShadowBlur, r = s.textShadowColor;
    }i.setAttribute('dx', n / l), i.setAttribute('dy', o / u), i.setAttribute('flood-color', r);const h = `${a / 2 / l} ${a / 2 / u}`;i.setAttribute('stdDeviation', h), e.setAttribute('x', '-100%'), e.setAttribute('y', '-100%'), e.setAttribute('width', `${Math.ceil(a / 2 * 200)}%`), e.setAttribute('height', `${Math.ceil(a / 2 * 200)}%`), e.appendChild(i), t._shadowDom = e;
  }, IP.prototype.markUsed = function (t) {
    t._shadowDom && bP.prototype.markUsed.call(this, t._shadowDom);
  };function OP(t, e, i, n) {
    this.root = t, this.storage = e, this._opts = i = P({}, i || {});const o = Yk('svg');o.setAttribute('xmlns', 'http://www.w3.org/2000/svg'), o.setAttribute('version', '1.1'), o.setAttribute('baseProfile', 'full'), o.style.cssText = 'user-select:none;position:absolute;left:0;top:0;';const a = Yk('g');o.appendChild(a);const r = Yk('g');o.appendChild(r), this.gradientManager = new SP(n, r), this.clipPathManager = new MP(n, r), this.shadowManager = new IP(n, r);const s = document.createElement('div');s.style.cssText = 'overflow:hidden;position:relative', this._svgDom = o, this._svgRoot = r, this._backgroundRoot = a, this._viewport = s, t.appendChild(s), s.appendChild(o), this.resize(i.width, i.height), this._visibleList = [];
  }OP.prototype = { constructor: OP, getType() {
    return 'svg';
  }, getViewportRoot() {
    return this._viewport;
  }, getSvgDom() {
    return this._svgDom;
  }, getSvgRoot() {
    return this._svgRoot;
  }, getViewportRootOffset() {
    const t = this.getViewportRoot();if (t) return { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 };
  }, refresh() {
    const t = this.storage.getDisplayList(!0);this._paintList(t);
  }, setBackgroundColor(t) {
    this._backgroundRoot && this._backgroundNode && this._backgroundRoot.removeChild(this._backgroundNode);const e = Yk('rect');e.setAttribute('width', this.getWidth()), e.setAttribute('height', this.getHeight()), e.setAttribute('x', 0), e.setAttribute('y', 0), e.setAttribute('id', 0), e.style.fill = t, this._backgroundRoot.appendChild(e), this._backgroundNode = e;
  }, _paintList(t) {
    this.gradientManager.markAllUnused(), this.clipPathManager.markAllUnused(), this.shadowManager.markAllUnused();let e; let i; const n = this._svgRoot; const o = this._visibleList; const a = t.length; const r = [];for (e = 0;e < a;e++) {
      var s = t[e]; const l = (i = s) instanceof Ar ? uP : i instanceof Qn ? hP : i instanceof Ur ? cP : uP; var u = NP(s) || PP(s);s.invisible || (s.__dirty && (l && l.brush(s), this.clipPathManager.update(s), s.style && (this.gradientManager.update(s.style.fill), this.gradientManager.update(s.style.stroke), this.shadowManager.update(u, s)), s.__dirty = !1), r.push(s));
    } let h; const c = (function (t, e, i) {
      return wP.diff(t, e, i);
    }(o, r));for (e = 0;e < c.length;e++) {
      if ((p = c[e]).removed) for (var d = 0;d < p.count;d++) {
        u = NP(s = o[p.indices[d]]);var f = PP(s);kP(n, u), kP(n, f);
      }
    } for (e = 0;e < c.length;e++) {
      var p;if ((p = c[e]).added) for (d = 0;d < p.count;d++) {
        u = NP(s = r[p.indices[d]]), f = PP(s);h ? CP(n, u, h) : LP(n, u), u ? CP(n, f, u) : h ? CP(n, f, h) : LP(n, f), CP(n, f, u), h = f || u || h, this.gradientManager.addWithoutUpdate(u || f, s), this.shadowManager.addWithoutUpdate(u || f, s), this.clipPathManager.markUsed(s);
      } else if (!p.removed) for (d = 0;d < p.count;d++) {
        u = NP(s = r[p.indices[d]]), f = PP(s), u = NP(s), f = PP(s);this.gradientManager.markUsed(s), this.gradientManager.addWithoutUpdate(u || f, s), this.shadowManager.markUsed(s), this.shadowManager.addWithoutUpdate(u || f, s), this.clipPathManager.markUsed(s), f && CP(n, f, u), h = u || f || h;
      }
    } this.gradientManager.removeUnused(), this.clipPathManager.removeUnused(), this.shadowManager.removeUnused(), this._visibleList = r;
  }, _getDefs(t) {
    let n; const e = this._svgDom;return 0 !== (n = e.getElementsByTagName('defs')).length ? n[0] : t ? ((n = e.insertBefore(Yk('defs'), e.firstChild)).contains || (n.contains = function (t) {
      const e = n.children;if (!e) return !1;for (let i = e.length - 1;0 <= i;--i) if (e[i] === t) return !0;return !1;
    }), n) : null;
  }, resize(t, e) {
    const i = this._viewport;i.style.display = 'none';const n = this._opts;if (null != t && (n.width = t), null != e && (n.height = e), t = this._getSize(0), e = this._getSize(1), i.style.display = '', this._width !== t || this._height !== e) {
      this._width = t, this._height = e;const o = i.style;o.width = `${t}px`, o.height = `${e}px`;const a = this._svgDom;a.setAttribute('width', t), a.setAttribute('height', e);
    } this._backgroundNode && (this._backgroundNode.setAttribute('width', t), this._backgroundNode.setAttribute('height', e));
  }, getWidth() {
    return this._width;
  }, getHeight() {
    return this._height;
  }, _getSize(t) {
    const e = this._opts; const i = ['width', 'height'][t]; const n = ['clientWidth', 'clientHeight'][t]; const o = ['paddingLeft', 'paddingTop'][t]; const a = ['paddingRight', 'paddingBottom'][t];if (null != e[i] && 'auto' !== e[i]) return parseFloat(e[i]);const r = this.root; const s = document.defaultView.getComputedStyle(r);return (r[n] || AP(s[i]) || AP(r.style[i])) - (AP(s[o]) || 0) - (AP(s[a]) || 0) | 0;
  }, dispose() {
    this.root.innerHTML = '', this._svgRoot = this._backgroundRoot = this._svgDom = this._backgroundNode = this._viewport = this.storage = null;
  }, clear() {
    this._viewport && this.root.removeChild(this._viewport);
  }, toDataURL() {
    return this.refresh(), `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(this._svgDom.outerHTML.replace(/></g, '>\n\r<'))}`;
  } }, R(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'pathToImage'], (t) => {
    OP.prototype[t] = (function (t) {
      return function () {
        vi(`In SVG mode painter not support method "${t}"`);
      };
    }(t));
  }), Po('svg', OP), t.version = '4.9.0', t.dependencies = { zrender: '4.3.2' }, t.PRIORITY = Ld, t.init = function (t, e, i) {
    const n = mf(t);if (n) return n;const o = new Ed(t, e, i);return o.id = `ec_${cf++}`, uf[o.id] = o, Jo(t, ff, o.id), (function (n) {
      const o = '__connectUpdateStatus';function a(t, e) {
        for (let i = 0;i < t.length;i++) {
          t[i][o] = e;
        }
      }Td(ef, (t, e) => {
        n._messageCenter.on(e, (t) => {
          if (hf[n.group] && 0 !== n[o]) {
            if (t && t.escapeConnect) return;const e = n.makeActionFromEvent(t); const i = [];Td(uf, (t) => {
              t !== n && t.group === n.group && i.push(t);
            }), a(i, 0), Td(i, (t) => {
              1 !== t[o] && t.dispatchAction(e);
            }), a(i, 2);
          }
        });
      });
    }(o)), o;
  }, t.connect = function (e) {
    if (L(e)) {
      const t = e;e = null, Td(t, (t) => {
        null != t.group && (e = t.group);
      }), e = e || `g_${df++}`, Td(t, (t) => {
        t.group = e;
      });
    } return hf[e] = !0, e;
  }, t.disConnect = pf, t.disconnect = gf, t.dispose = function (t) {
    'string' === typeof t ? t = uf[t] : t instanceof Ed || (t = mf(t)), t instanceof Ed && !t.isDisposed() && t.dispose();
  }, t.getInstanceByDom = mf, t.getInstanceById = function (t) {
    return uf[t];
  }, t.registerTheme = vf, t.registerPreprocessor = yf, t.registerProcessor = xf, t.registerPostUpdate = function (t) {
    af.push(t);
  }, t.registerAction = _f, t.registerCoordinateSystem = wf, t.getCoordinateSystemDimensions = function (t) {
    const e = lh.get(t);if (e) return e.getDimensionsInfo ? e.getDimensionsInfo() : e.dimensions.slice();
  }, t.registerLayout = bf, t.registerVisual = Sf, t.registerLoading = If, t.extendComponentModel = Tf, t.extendComponentView = Af, t.extendSeriesModel = Df, t.extendChartView = Cf, t.setCanvasCreator = function (t) {
    f('createCanvas', t);
  }, t.registerMap = function (t, e, i) {
    Sd.registerMap(t, e, i);
  }, t.getMap = function (t) {
    const e = Sd.retrieveMap(t);return e && e[0] && { geoJson: e[0].geoJSON, specialAreas: e[0].specialAreas };
  }, t.dataTool = {}, t.zrender = Oo, t.number = Ql, t.format = mu, t.throttle = Lc, t.helper = Sg, t.matrix = pe, t.vector = It, t.color = Je, t.parseGeoJSON = Cg, t.parseGeoJson = Wg, t.util = Hg, t.graphic = Zg, t.List = Yf, t.Model = Cl, t.Axis = Gg, t.env = v;
}));
